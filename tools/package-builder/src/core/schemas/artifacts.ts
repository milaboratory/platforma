import { z } from 'zod/v4';
import * as defaults from '../../defaults';
import * as util from '../util';

// All known artifact types
export const artifactTypes = ['asset', 'environment', 'binary', 'java', 'python', 'R', 'docker', 'conda'] as const;
export type artifactType = (typeof artifactTypes)[number];

// TODO: change these to type definitions, not arrays. This will simplify type narrowing logic throughout the code.
export const archiveArtifactTypes: artifactType[] = ['asset', 'environment', 'binary', 'java', 'python', 'R', 'conda'] as const;
export const crossplatformTypes: artifactType[] = ['asset', 'java', 'python', 'R'] as const;
export const dockerAutogenTypes: artifactType[] = ['python', 'conda'] as const;

export function isBuildable(aType: artifactType): boolean {
  // All known artifact types are buildable. No exceptions so far.
  return artifactTypes.includes(aType);
}

export function isCrossPlatform(aType: artifactType): boolean {
  return crossplatformTypes.includes(aType);
}

export const runEnvironmentTypes = ['java', 'python', 'R'] as const;
export type runEnvironmentType = (typeof runEnvironmentTypes)[number];

export const pythonToolsets = ['pip'] as const;
export type pythonToolsetName = (typeof pythonToolsets)[number];

export const registrySchema = z.strictObject({
  name: z.string(),
  downloadURL: z.string().optional(),
  storageURL: z.string().optional(),
});
export type registry = z.infer<typeof registrySchema>;

export const registryOrRef = z.union([z.string(), registrySchema]);

// common fields for all buildable artifacts
// TODO: create new type for binary packages
const archiveRulesSchema = z.object({
  registry: registryOrRef,

  name: z.string().optional(),
  version: z.string().optional(),

  root: z.string('package archive content directory is required'),
  roots: z
    .partialRecord(
      z.enum(
        util.AllPlatforms as [(typeof util.AllPlatforms)[number], ...(typeof util.AllPlatforms)[number][]],
      ),
      z.string('path to package archive content directory cannot be empty').min(1),
      {
        error: (iss) => {
          if (iss.input === undefined) {
            return 'list of supported platforms is required: { <platform>: <dir> }\n'
              + 'supported platforms:\n  ' + util.AllPlatforms.join('\n  ');
          }
          return null;
        },
      },
    )
    .refine(
      (val) => Object.keys(val).length > 0, {
        message: 'specify at least one platform supported by this software in format: { <platform>: <dir> }\n'
          + 'supported platforms:\n  ' + util.AllPlatforms.join('\n  '),
      })
    .describe(
      'please, provide settings only for supported platforms: ' + util.AllPlatforms.join(', '),
    ),
});
export type archiveRules = z.infer<typeof archiveRulesSchema>;

const dockerRulesSchema = z.object({
  ['docker-registry']: z
    .string('python software is also automatically shipped as docker image. Docker registry cannot be empty')
    .min(1)
    .default(defaults.DOCKER_REGISTRY)
    .describe('registry to use for pushing autogenerated docker image'),

  pkg: z
    .string()
    .default(defaults.DOCKER_PLACEHOLDER_PKG)
    .describe('{pkg} placeholder value to be used in "cmd" and arguments (for docker autogeneration)'),

});

export const artifactIDSchema = z
  .string()
  .regex(/:/, {
    message:
      'tengo artifact ID must have <npmPackage>:<artifactName> format, e.g @milaboratory/runenv-java-corretto:21.2.0.4.1',
  })
  .describe('ID of tengo build artifact');

export type artifactIDString = z.infer<typeof artifactIDSchema>;

export const assetSchema = archiveRulesSchema
  .omit({ roots: true })
  .extend({ type: z.literal('asset') })
  .strict();
export type assetType = z.infer<typeof assetSchema>;

export const environmentSchema = archiveRulesSchema
  .omit({ root: true })
  .extend({
    type: z.literal('environment'),

    runtime: z
      .enum(runEnvironmentTypes)
      .describe('type of runtime this run environment provides: \'java\', \'python\' and so on'),

    ['r-version']: z.string().optional(),
    ['python-version']: z.string().optional(),
    ['java-version']: z.string().optional(),

    envVars: z
      .array(
        z
          .string()
          .regex(
            /=/,
            'environment variable should be specified in format: <var-name>=<var-value>, i.e.: MY_ENV=value',
          ),
      )
      .optional(),

    binDir: z
      .string()
      .describe('path to \'bin\' directory to be added to PATH when software uses this run environment'),
  });

export type environmentType = z.infer<typeof environmentSchema>;

export const binarySchema = archiveRulesSchema
  .omit({ root: true })
  .extend({
    type: z.literal('binary'),
  });
export type binaryType = z.infer<typeof binarySchema>;

export const javaSchema = archiveRulesSchema
  .omit({ roots: true })
  .extend({
    type: z.literal('java'),
    environment: artifactIDSchema,
  });
export type javaType = z.infer<typeof javaSchema>;

const pipToolsetSchema = z.strictObject({
  toolset: z.literal('pip'),
  requirements: z.string().describe('path to requrements.txt inside package archive'),
});

export const pythonToolsetSchema = z.discriminatedUnion('toolset', [pipToolsetSchema]);

export const pythonSchema = archiveRulesSchema
  .omit({ roots: true })
  .extend(dockerRulesSchema.shape)
  .extend({
    type: z.literal('python'),

    environment: artifactIDSchema,
    dependencies: pythonToolsetSchema.optional(),

  });
export type pythonType = z.infer<typeof pythonSchema>;

export const rSchema = archiveRulesSchema
  .omit({ roots: true })
  .extend({
    type: z.literal('R'),
    environment: artifactIDSchema,
  });
export type rType = z.infer<typeof rSchema>;

export const condaSchema = archiveRulesSchema
  .omit({ root: true })
  .extend(dockerRulesSchema.shape)
  .extend({
    type: z.literal('conda'),

    ['micromamba-version']: z
      .string()
      .default(defaults.CONDA_MICROMAMBA_VERSION)
      .describe('version of micromamba to be used to operate with conda environments'),
    ['conda-root-dir']: z
      .string()
      .default(defaults.CONDA_DATA_LOCATION)
      .describe('root directory of conda environment inside package root'),

    spec: z
      .string()
      .default(defaults.CONDA_SOURCE_ENV_SPEC_FILE)
      .describe(`path to conda environment yaml specification relative to package.json`),
  });
export type condaType = z.infer<typeof condaSchema>;

export const dockerSchema = z.object({
  type: z.literal('docker'),

  registry: z
    .string()
    .default(defaults.DOCKER_REGISTRY)
    .describe('registry+repository URL to use for pulling this image'),

  // build from custom Dockerfile
  context: z.string()
    .refine((val) => val !== './' && val !== '.', {
      message: 'Context cannot be "./" or "." - use absolute path or relative path without "./" prefix',
    })
    .describe('relative path to context directory from folder where command is executed or absolute path to context folder (cannot be "./" or ".")'),

  dockerfile: z
    .string()
    .default(defaults.DOCKER_DOCKERFILE)
    .describe('relative path to \'Dockerfile\' file from folder where command is executed or absolute path to the file'),

  pkg: z
    .string()
    .default(defaults.DOCKER_PLACEHOLDER_PKG)
    .describe('{pkg} placeholder value to be used in "cmd" and arguments'),

  // import existing image
  // entrypoint: z
  //   .array(z.string())
  //   .optional()
  //   .describe('replace image\'s ENTRYPOINT with this value when running container'),
});
export type dockerType = z.infer<typeof dockerSchema>;

export const anyArtifactSchema = z.discriminatedUnion('type', [
  assetSchema,
  environmentSchema,
  binarySchema,
  javaSchema,
  pythonSchema,
  rSchema,
  condaSchema,
  dockerSchema,
]);

export type anyArtifactType = z.infer<typeof anyArtifactSchema>;

export const artifactIndexSchema = z.record(z.string(), anyArtifactSchema);
export type artifactIndexType = z.infer<typeof artifactIndexSchema>;

export type withType<Typ, Orig> = Orig & { type: Typ };
export type withId<T> = T & { id: string };
