import * as fs from 'node:fs';
import * as path from 'node:path';
import type winston from 'winston';

import * as defaults from '../defaults';
import * as paths from './paths';
import * as util from './util';

import type * as artifacts from './schemas/artifacts';
import { micromambaDownloadUrl } from './conda/builder';
import { dockerfileAutogenPath } from './docker';

export const tmpSpecFile = 'tmp-env-spec-88344b62d74b9307.yaml';

export interface CondaOptions {
  baseImageTag: string;
  micromambaVersion: string;
  frozenSpecFile: string;
  pkg: string;
}

export interface DockerOptions {
  context: string;
  dockerfile: string;
  entrypoint: string[];
  pkg: string;
}

export interface CondaDockerOptions extends CondaOptions, DockerOptions {}

function generateCondaDockerfileContent(options: CondaOptions): string {
  // Read template from assets
  const templatePath = paths.assets('conda-dockerfile.template');
  const templateContent = fs.readFileSync(templatePath, 'utf-8');

  // Generate Dockerfile with dependencies
  return templateContent
    .replaceAll('${BASE_IMAGE_TAG}', options.baseImageTag)
    .replaceAll('${MAMBA_ROOT_PREFIX}', path.posix.join(options.pkg, defaults.CONDA_DATA_LOCATION))
    .replaceAll('${CONDA_PKGS_DIRS}', path.posix.join(options.pkg, defaults.CONDA_DATA_LOCATION, 'pkgs'))
    .replaceAll('${MICROMAMBA_DOWNLOAD_URL}', micromambaDownloadUrl(options.micromambaVersion, 'linux-x64'))
    .replaceAll('${PKG}', options.pkg)
    .replaceAll('${TMP_SPEC_FILE}', tmpSpecFile)
    .replaceAll('${FROZEN_SPEC_FILE}', options.frozenSpecFile);
}

export function prepareDockerOptions(
  logger: winston.Logger,
  currentPackageRoot: string,
  artifactID: string,
  buildParams: artifacts.condaType,
  arch: util.ArchType,
): DockerOptions {
  logger.debug(`Preparing Docker options for Python package: ${buildParams.name} (id: ${artifactID})`);

  const options = getDefaultCondaOptions();
  options.micromambaVersion = buildParams['micromamba-version'];

  if (buildParams.pkg) {
    options.pkg = buildParams.pkg;
  }

  const platform: util.PlatformType = `linux-${arch}`;

  if (!buildParams.roots) {
    throw util.CLIError('Cannot prepare Docker options: package root directory is not specified. Please ensure the "root" property is set in the build parameters.');
  }
  if (!buildParams.roots[platform]) {
    throw util.CLIError('Cannot prepare Docker options: linux-x64 root directory is not specified. Please ensure the "roots" property is set for artifact.');
  }

  const contextDir = path.resolve(currentPackageRoot, buildParams.roots[platform]);
  if (!fs.existsSync(contextDir)) {
    fs.mkdirSync(contextDir, { recursive: true });
  }

  // Generate a temporary directory for the Dockerfile
  const dockerfilePath = dockerfileAutogenPath(currentPackageRoot, artifactID);
  const dockerfileDir = path.dirname(dockerfilePath);
  fs.mkdirSync(dockerfileDir, { recursive: true });
  logger.debug(`Created directory for autogenerated dockerfiles: ${dockerfileDir}`);

  fs.copyFileSync(path.join(currentPackageRoot, buildParams.spec), path.join(contextDir, tmpSpecFile));
  logger.debug(`Copied spec file to context directory`);

  const dockerfile = {
    content: generateCondaDockerfileContent(options),
    path: dockerfilePath,
  };

  fs.writeFileSync(dockerfile.path, dockerfile.content);
  logger.debug(`Written Dockerfile to: ${dockerfile.path}`);

  const result: DockerOptions = {
    dockerfile: dockerfile.path,
    context: contextDir,
    entrypoint: [],
    pkg: options.pkg,
  };

  logger.debug(`Prepared Docker options: ${JSON.stringify(result)}`);
  verifyDockerOptions(result);
  return result;
}

function getDefaultCondaOptions(): CondaOptions {
  return {
    baseImageTag: defaults.CONDA_DOCKER_BASE_IMAGE,
    micromambaVersion: defaults.CONDA_MICROMAMBA_VERSION,
    frozenSpecFile: defaults.CONDA_FROEZEN_ENV_SPEC_FILE,
    pkg: defaults.DOCKER_PLACEHOLDER_PKG,
  };
}

function verifyDockerOptions(options: DockerOptions) {
  if (!fs.existsSync(options.dockerfile)) {
    throw util.CLIError(`Dockerfile '${options.dockerfile}' not found`);
  }

  if (!fs.existsSync(options.context)) {
    throw util.CLIError(`Context '${options.context}' not found`);
  }
}
