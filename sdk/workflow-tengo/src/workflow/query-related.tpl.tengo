self := import(":tpl")
ll := import(":ll")
slices := import(":slices")
json := import("json")
bquery := import(":workflow.bquery")

self.awaitState("anchorSpecs", { wildcard: "*" }, "ResourceReady")
self.awaitState("related", "ResourceReady")

self.body(func(inputs) {
	ctx := inputs.ctx
	anchors := inputs.anchorSpecs
	related := inputs.related

    outputs := {}

    for relatedId, relatedConfig in related {
        // Extract matcher and fetchData flag
        matcher := relatedConfig.matcher
        fetchData := relatedConfig.fetchData

        // Converting the matcher to a query spec
        queryPredicates := []

        // Add name or namePattern predicate if present
        if !is_undefined(matcher.name) {
            if !is_undefined(matcher.namePattern) {
                ll.panic("Cannot specify both name and namePattern for related item '%s'", relatedId)
            }

            queryPredicates += [ {
                type: "Name",
                name: matcher.name
            } ]
        } else if !is_undefined(matcher.namePattern) {
            queryPredicates += [ {
                type: "NamePattern",
                pattern: matcher.namePattern
            } ]
        }

        // Add domain predicate if present
        if !is_undefined(matcher.domain) || !is_undefined(matcher.domainAnchor) {
            domainPredicate := {
                type: "Domain",
                domain: {}
            }

            // Process domainAnchor if present
            if !is_undefined(matcher.domainAnchor) {
                anchorId := matcher.domainAnchor
                if is_undefined(anchors[anchorId]) {
                    ll.panic("Cannot resolve domain anchor: anchor '%s' not found", anchorId)
                }

                // Copy all domain values from the anchor
                if !is_undefined(anchors[anchorId].domain) {
                    for domainKey, domainValue in anchors[anchorId].domain {
                        domainPredicate.domain[domainKey] = domainValue
                    }
                }
            }

            // Process each domain key-value pair
            if !is_undefined(matcher.domain) {
                for domainKey, domainValue in matcher.domain {
                    // Check if this is an anchored domain reference (has 'anchor' property)
                    if is_map(domainValue) && !is_undefined(domainValue.anchor) {
                        // This is an anchored domain reference
                        // Use the anchor ID to get the domain value from the anchors
                        anchorId := domainValue.anchor
                        if is_undefined(anchors[anchorId]) {
                            ll.panic("Cannot resolve anchored domain: anchor '%s' not found", anchorId)
                        }

                        // Get domain value from the anchor
                        if is_undefined(anchors[anchorId].domain) || is_undefined(anchors[anchorId].domain[domainKey]) {
                            ll.panic("Cannot resolve anchored domain: domain key '%s' not found in anchor '%s'", domainKey, anchorId)
                        }

                        // Use the resolved value
                        domainPredicate.domain[domainKey] = anchors[anchorId].domain[domainKey]
                    } else {
                        // This is a regular domain value
                        domainPredicate.domain[domainKey] = domainValue
                    }
                }
            }

            queryPredicates += [ domainPredicate ]
        }

        // Add axes if present
        if !is_undefined(matcher.axes) {
            axesMatcher := {
                type: "AxesKeys",
                axesKeys: slices.map(matcher.axes, func(axis) {
                    // If axis is a direct AxisId (has name, type properties)
                    if is_map(axis) && !is_undefined(axis.name) && !is_undefined(axis.type) {
                        // This is a direct AxisId
                        return {
                            name: axis.name,
                            type: axis.type,
                            domain: !is_undefined(axis.domain) ? axis.domain : {}
                        }
                    }

                    // If it's an AnchorAxisRef (map with anchor and reference properties)
                    if is_map(axis) && !is_undefined(axis.anchor) {
                        anchorId := axis.anchor

                        // Check if the anchor exists
                        if is_undefined(anchors[anchorId]) {
                            ll.panic("Cannot resolve anchored axis: anchor '%s' not found", anchorId)
                        }

						foundAxis := undefined

                        // Handle different types of AnchorAxisRef
                        if !is_undefined(axis.idx) {
                            // AnchorAxisRefByIdx - has idx property
                            axisIndex := axis.idx
                            if is_undefined(anchors[anchorId].axesSpec) || len(anchors[anchorId].axesSpec) <= axisIndex {
                                ll.panic("Cannot resolve anchored axis by index: axis index %v not found in anchor '%s'", axisIndex, anchorId)
                            }

                            foundAxis = anchors[anchorId].axesSpec[axisIndex]
                        } else if !is_undefined(axis.name) {
                            // AnchorAxisRefByName - has name property
                            axisName := axis.name

                            // Find axis by name in the anchor
                            for _, anchorAxis in anchors[anchorId].axesSpec {
                                if anchorAxis.name == axisName {
									if !is_undefined(foundAxis) {
										ll.panic("Cannot resolve anchored axis by name: multiple axes with name '%s' found in anchor '%s'", axisName, anchorId)
									}
                                    foundAxis = anchorAxis
                                }
                            }

                            if is_undefined(foundAxis) {
                                ll.panic("Cannot resolve anchored axis by name: axis '%s' not found in anchor '%s'", axisName, anchorId)
                            }
                        } else {
                            ll.panic("Unsupported axis reference format: %v", axis)
                        }

						return {
							name: foundAxis.name,
							type: foundAxis.type,
							domain: !is_undefined(foundAxis.domain) ? foundAxis.domain : {}
						}
                    }

                    ll.panic("Unsupported axis format: %v", axis)
                })
            }

			if !is_undefined(matcher.partialAxesMatch) {
				axesMatcher.partialMatch = matcher.partialAxesMatch
			}

            queryPredicates += [ axesMatcher ]
        }

        if len(queryPredicates) == 0 {
            ll.panic("No predicates found for related item '%s'", relatedId)
        }

        querySpec := len(queryPredicates) > 1 ? {
            type: "And",
            operands: queryPredicates
        } : queryPredicates[0]

        expectMultiple := matcher.matchStrategy == "expectMultiple"
        queryOps := {
            spec: true,
            data: fetchData,  // Use the fetchData flag to control whether to fetch data
            first: !expectMultiple,
            single: !expectMultiple
        }

        ll.print("__THE_LOG__ " + string(json.encode(querySpec)))
        ll.print("__THE_LOG__ " + string(json.encode(queryOps)))

        queryResult := bquery.create(querySpec, ctx, queryOps)

        outputs["related/" + relatedId] = queryResult
    }

    return outputs
})

