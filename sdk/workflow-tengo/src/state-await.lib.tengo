/**
 * Library implementing state machine to await certain resource states in
 * ephemeral templates.
 */

tx := import("tx")
ll := import(":ll")
sets := import(":sets")

createContext := func() {
	return {
		activeSubscriptions: {},
		resolvedStates: {}
	}
}

awaitOneState := func(rootField, request) {
	field := rootField
	if !is_map(request) || !is_array(request.path) || !is_string(request.state) {
		ll.panic("Malformed state await request: %v", request)
	}
	for _, step in request.path {
		if !is_string(step) {
			ll.panic("Malformed state await request path: %v", step)
		}
		if !field.isSet() {
			return {
				type: "Subscribe",
				resource: field.id.ResourceID,
				event: "InputSet"
			}
		}
		resource := field.getValue()
		field = resource.inputs()[step]
		if field == undefined {
			if resource.info().InputsLocked {
				ll.panic("field %v not found and inputs locked", step)
			}
			return {
				type: "Subscribe",
				resource: resource.id,
				event: ["FieldCreated", "InputsLocked"]
			}
		}
	}

	if request.state == "Exists" {
		return { type: "Ready" }
	} else {
		if !field.isSet() {
			return {
				type: "Subscribe",
				resource: field.id.ResourceID,
				event: "InputSet"
			}
		}
		resource := field.getValue()
		if request.state == "Set" {
			return { type: "Ready" }
		} else if request.state == "InputsLocked" {
			if resource.info().InputsLocked {
				return { type: "Ready" }
			} else {
				return {
					type: "Subscribe",
					resource: resource.id,
					event: "InputsLocked"
				}
			}
		} else if request.state == "AllInputsSet" {
			if resource.info().AllInputsSet {
				return { type: "Ready" }
			} else {
				return {
					type: "Subscribe",
					resource: resource.id,
					event: "AllInputsSet"
				}
			}
		} else if request.state == "ResourceReady" {
			if resource.info().ResourceReady {
				return { type: "Ready" }
			} else {
				return {
					type: "Subscribe",
					resource: resource.id,
					event: "ResourceReady"
				}
			}
		} else {
			ll.panic("Unknown await state: %v", request.state)
		}
	}
}

/** Returns true if all requested states are reached */
await := func(rootField, ctxStorageResource, requests) {
	pssKey := "await:" + string(rootField.id.ResourceID) + ":" + rootField.id.Name
	prevSubscriptions := ctxStorageResource.kvGetAsJson(pssKey)

	if !is_undefined(prevSubscriptions) && len(prevSubscriptions) == 0 {
		// initialization was finished before, in a previous template execution
		ll.panic("Unexpected state, desired state was reached in the previous call")
	}

	if is_undefined(prevSubscriptions) {
		// initializing previous subscriptions set
		prevSubscriptions = {}
	}

	subscriptions := {}

	addSubscription := func(subscription) {
		key := string(subscription.resource) + ":" + subscription.event
		if !is_undefined(subscriptions[key]) {
			return false
		} else {
			subscriptions[key] = subscription
			return true
		}
	}

	for _, request in requests {
		res := awaitOneState(rootField, request)
		if res.type == "Ready" {
			continue
		} else if res.type == "Subscribe" {
			if is_array(res.event) {
				// multiple events to await
				for _, event in res.event {
					addSubscription({
						resource: res.resource,
						event: event
					})
				}
			} else {
				addSubscription(res)
			}
		} else {
			ll.panic("Unknown result type %v", res.type)
		}
	}

	// creating new subscriptions
	for key, sub in subscriptions {
		if !is_undefined(prevSubscriptions[key]) {
			// don't create subscription, if it was created in the past
			continue
		}
		e := {}
		e[sub.event] = true
		tx.subscribeTo(sub.resource, pssKey + ":" + key, e)
	}

	// unsubscribing from subscriptions we don't need anymore
	for key, _ in prevSubscriptions {
		if !is_undefined(subscriptions[key]) {
			// don't unsubscribe from subscriptions, we still need
			continue
		}
		tx.unsubscribeFrom(pssKey + ":" + key)
	}

	// creating and saving new context; savong only keys
	newPrevSubscriptions := {}
	for key, _ in subscriptions {
		newPrevSubscriptions[key] = true
	}
	// saving the context
	ctxStorageResource.kvSetJson(pssKey, newPrevSubscriptions)

	return len(subscriptions) == 0
}

export ll.toStrict({
	await: await
})
