/*
 * Library provides smart.Resource and smart.Field primitives.
 */

tx := import("tx")
ll := import(":ll")
feats := import(":feats")

oop := import(":oop")
maps := import(":maps")
json := import("json")
times := import("times")
constants := import(":constants")
ffDefault := import(":ll.get-future-field-default")

//////////////// definitions ////////////////

/**
 * A read-only wrapper object around raw platforma resource
 */
resource := undefined

/**
 * A wrapper object around raw platforma resource field
 */
field := undefined

/**
 * A convenient builder for resource objects
 */
resourceBuilder := undefined

/**
 * Builder for structural resource
 *
 * @param resourceType { Name: "", Version: "" }
 */
structBuilder := undefined

/**
 * Builder for map resource
 */
mapBuilder := undefined

/**
 * Builder for ephemeral map resource
 */
ephemeralMapBuilder := undefined

/**
 * Builder for emphemeral resources
 *
 * @param resourceType { Name: "", Version: "" }
 */
ephemeralBuilder := undefined

/**
 * Creates a null resource.
 *
 * @params data, optional, bytes that will go in Data of the resource. Don't use this argument.
 */
createNullResource := undefined

/**
 * Create value resource
 *
 * @param resourceType { Name: "", Version: "" }
 * @param data optional data
 */
createValueResource := undefined

/**
 * Create Json resource
 *
 * @param value value to save in the resource
 */
createJsonResource := undefined

/**
 * Create map resource
 *
 * @param keyToValue: map[string]anyResource
 * @return resource
 */
createMapResource := undefined

/**
 * Create binary map resource
 *
 * @param keyToValue: map[string]valueResource
 * @return resource
 */
createBinaryMapResource := undefined

/**
 * Create blob map resource
 *
 * @param keyToValue: map[string]blobResource
 * @return resource
 */
createBlobMapResource := undefined

////////////////// helpers ///////////////////////////

/**
 * Returns true if given object is a smart.Resource
 */
isResource := func(f) {
	return ll.isStrict(f) && maps.containsKey(f, "_type") && f["_type"] == "resource"
}

/**
 * Returns true if given object is a smart.Field
 */
isField := func(f) {
	return ll.isStrict(f) && maps.containsKey(f, "_type") && f["_type"] == "field"
}

/**
 * Returns true if given object is a smart.Field or smart.Resource
 */
isReference := func(f) {
	return isField(f) || isResource(f)
}

/**
 * Gets future field by given field name and field type.
 *
 * @param from: reference - whether a resource or a field we get a field from.
 * @param name: string - field name
 * @param fieldType: field type: input, output
 * @param isEph: bool - resolve in ephemeral or pure mode
 *
 * @return field: smart field
 */
_getFutureField := func(from, name, fieldType, isEph) {
	ll.assert(isReference(from), "'from' must be either a resource or a field, got: %#v", from)
	if is_bytes(name) {
		name = string(name)
	}
	ll.assert(is_string(name) && name != "", "field name must be a non-empty string")

	futureField := tx.createFutureFieldID(fieldType, name, !isEph)
	f := field(futureField.ResourceFID)
	f.set(from)

	return field(futureField.ResultFID)
}

/**
 * @deprecated Use buildFutureField instead.
 * Gets future field given field name or a path
 *
 * @param resourceOrField: reference - resource or field to get future field from
 * @param nameOrPath: string|string[]|object|object[]
 *                           - field name, an array representing a path to be traversed,
 *                             an object with {name: string, type?: string, optional?: bool, eph?: bool} structure,
 *                             an array of such objects/strings
 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
 *                               to pass deduplication before resolution.
 *
 * @return field: smart field
 */
_buildFutureField := func(resourceOrField, nameOrPath, ...eph) {
	globalIsEph := undefined
	if len(eph) > 0 && is_bool(eph[0]) {
		globalIsEph = eph[0]
	}

	// set to true if optional is encountered, all further fields are resolved as optional
	optional := false

	// Helper function to process a single element (string or object)
	processSingleElement := func(resource, element) {
		// Default field type is "input" if not specified
		fieldType := "input"
		fieldName := undefined
		isEph := globalIsEph

		if is_map(element) {
			if !is_undefined(globalIsEph) {
				ll.panic("global eph is not supported for structural path elements")
			}

			if !is_undefined(element.type) {
				fieldType = element.type
			}

			fieldName = element.name
			optional = optional || element.optional
			isEph = element.eph
		} else {
			fieldName = element
		}

		if optional {
			return resource.getFutureFieldOptional(fieldName, fieldType, isEph)
		} else {
			return resource.getFutureField(fieldName, fieldType, isEph)
		}
	}

	if is_array(nameOrPath) {
		current := resourceOrField
		for i, pathElement in nameOrPath {
			current = processSingleElement(current, pathElement)
		}
		return current
	} else {
		return processSingleElement(resourceOrField, nameOrPath)
	}
}

/**
 * @deprecated Use buildFutureField instead.
 */
_getFutureInputField := func(resourceOrField, nameOrPath, ...eph) {
	return _buildFutureField(resourceOrField, nameOrPath, eph...)
}

/**
 * Returns true if given object is a StdMap resource
 */
isMapResource := func(r) {
	return isResource(r) && (
		r.info().Type.Name == constants.RTYPE_MAP.Name ||
			r.info().Type.Name == constants.RTYPE_MAP_ALT.Name) // @TODO get rid of alt name

}

/**
 * Returns true if given object is an ephemeral std map resource
 */
isEphMapResource := func(r) {
	return isResource(r) &&  r.info().Type.Name == constants.RTYPE_MAP_EPH.Name
}

/**
 * Returns true if given object is an ephemeral std map resource with locked inputs (so the list of inputs is final)
 */
isLockedEphMapResource := func(r) {
	return isEphMapResource(r) && r.info().InputsLocked
}

/**
 * Returns true if given object is a map or ephemeral map resource
 */
isAnyMapResource := func(r) {
	return isMapResource(r) || isEphMapResource(r)
}

/**
 * Returns true if given object is a json resource
 */
isJsonResource := func(r) {
	return isResource(r) && r.info().Type.Name == constants.RTYPE_JSON.Name
}

/**
 * Returns true if given object is a null resource
 */
isNullResource := func(r) {
	return isResource(r) && r.info().Type.Name == constants.RTYPE_NULL.Name
}

// deep check whether map has resources somewhere inside
_hasReferenceValues := func(object) {
	if isReference(object) {
		// first check is reference since resource/field will return true on ll.isMap
		return true
	} else if ll.isMap(object) {
		for _, v in object {
			if _hasReferenceValues(v) {
				return true
			}
		}
	} else if is_array(object) {
		for v in object {
			if _hasReferenceValues(v) {
				return true
			}
		}
	}
	return false
}

/**
 * Convert given object to resource. If object is a true json, then
 * a simple Json resource will be created, otherwise a resource map.
 */
_toRefOrJson := func(object) {
	if isReference(object) {
		// first check is reference since resource/field will return true on ll.isMap
		return object
	} else if ll.isMap(object) {

		// just json if there are no nested resources
		if !_hasReferenceValues(object)  {
			return createJsonResource(object)
		}

		mb := mapBuilder()
		for k, v in object {
			mb.add(k, _toRefOrJson(v))
		}

		return mb.build()
	} else if is_array(object) {

		// assert we are not having refs inside
		ll.assert(!_hasReferenceValues(object), "array can't contain references")

		return createJsonResource(object)
	} else {
		return createJsonResource(object)
	}
}

resourceTypesEqual := func(rType1, rType2) {
	return rType1.Name == rType2.Name && rType1.Version == rType2.Version
}

////////////////// implementation ///////////////////////////

/**
 * @param r either resource id or resource info
 */
resource = func(r) {
	self := undefined
	strictSelf := undefined

	if isResource(r) {
		return r
	}

	id := ll.isStrict(r) ? r.ID : r

	if !is_int(id) {
		ll.panic("resource id should be int for ", r)
	}

	if id == 0 {
		ll.panic("null resource id for ", r)
	}

	self = {
		_type: "resource",

		/**
		 * Resource id (int64)
		 */
		id: id,

		/**
		 * Resource info:
		 *  ID:            int64
		 *  Kind:          "string": Structural or Value
		 *  CanonicalID:   byte[]
		 *  Data:          byte[],
		 *  Type:          { Name: string, Version: string }
		 *  Features:      { ephemeral: bool }
		 *
		 *  Fields:        strict map: all the fields
		 *  Inputs:        strict map
		 *  Outputs:       strict map
		 *  Dynamic:       strict map
		 *  OTW:           strict map
		 *  ServiceFields: strict map
		 *
		 *  ResourceReady:  bool
		 *  IsFinal:        bool
		 *  AllFieldsLoaded bool
		 *  AllInputsSet:   bool
		 *  AllOutputsSet:  bool
		 *  IsDuplicate:    bool
		 *  InputsLocked:   bool
		 *  OutputsLocked:  bool
		 *  HasErrors:      bool
		 */
		info: func() {
			_resourceInfo := tx.getResource(self.id)
			// Converting type to normal map to allow for easy "==" comparison
			_resourceInfo.Type = { Name: _resourceInfo.Type.Name, Version: _resourceInfo.Type.Version }
			return _resourceInfo
		},

		/**
		 * Returns true if resource has type equal to the one provided as an agrument.
		 *
		 * @param expectedType type to compare resource type with
		 * @return true if type matches, false otherwise
		 */
		checkResourceType: func(expectedType) {
			return resourceTypesEqual(self.info().Type, expectedType)
		},

		/**
		 * Resource is ready when all inputs are set to the terminal values.
		 */
		isFinal: func() {
			// FIXME: it failed with some tests although it should be the same line as below.
			if false /* feats.fullFeaturedApi */ {
				return self.info().IsFinal
			}

			info := self.info()

			return info.ResourceReady || info.IsDuplicate || info.HasErrors
		},

		isEphemeral: func() {
			resourceInfo := self.info()

			if !maps.containsKey(resourceInfo, "Features") {
				// by default we consider all resources to be ephemeral for backward compatiblity to keep stable logic
				// in platforma backend before v1.16.0.
				// TODO: once we consider this version old enough, we can panic here instead of 'return true'
				return true
			}

			return resourceInfo.Features.ephemeral
		},

		/**
		 * Get raw resource data
		 *
		 * @return data: []byte - raw resource data
		 */
		getData: func() {
			if self.hasError() {
				ll.panic("resource has errors: ", self.info())
			}
			return self.info().Data;
		},

		/**
		 * Get resource data as Json
		 */
		getDataAsJson: func() {
			return json.decode(self.getData());
		},

		/**
		 * Whether this resource has error
		 */
		hasError: func() {
			return self._hasField("OneTimeWritables", "resourceError")
		},

		/**
		 * Whether any of the input fields have errors. The resource itself may still not have
		 * error status because error propagation was not yet happened.
		 */
		hasInputErrors: func() {
			return self.info().HasErrors
		},

		/**
		 * Return error set in the resource
		 */
		getError: func() {
			if !self.info().HasErrors {
				ll.panic("no error set in resource")
			}
			return self.getField("resourceError").getError()
		},

		_hasField: func(fieldMapName, fieldName) {
			return ll.fromStrict(self.info()[fieldMapName])[fieldName] != undefined
		},

		/**
		 * Whether resource has input field with specified name
		 *
		 * @param name field name
		 */
		hasInputField: func(name) {
			return self._hasField("Inputs", name)
		},

		/**
		 * Whether resource has output field with specified name
		 *
		 * @param name field name
		 */
		hasOutputField: func(name) {
			return self._hasField("Outputs", name)
		},

		/**
		 * Whether resource has any field with specified name
		 *
		 * @param name field name
		 */
		hasField: func(name) {
			return self._hasField("Inputs", name) ||
				self._hasField("Outputs", name) ||
				self._hasField("DynamicFields", name) ||
				self._hasField("OneTimeWritables", name)
		},

		// cached input fields (smart.Field)
		_inputs: undefined,
		/**
		 * Returns resource inputs map name -> smart.Field
		 */
		inputs: func() {
			if self._inputs == undefined {
				info := self.info()
				inputs := maps.mapValues(info.Inputs, field)

				if !info.InputsLocked {
					return inputs
				}
				self._inputs = inputs
			}
			return self._inputs
		},

		// cached meta fields (smart.Field)
		_metaInputs: undefined,
		/**
		 * @deprecated Use metaInputs instead.
		 * Returns resource meta fields map name -> smart.Field
		 */
		metaInputs: func() {
			if self._metaInputs == undefined {
				info := self.info()

				if !maps.containsKey(info, "ServiceFields") {
					// old Workflow controller API with bug (no service fields in resource info struct)
					// FIXME: remove this safely after 2026-02-01
					self._metaInputs = {}
					return self._metaInputs
				}

				svcs := maps.mapValues(info.ServiceFields, field)

				if !info.InputsLocked {
					return svcs
				}
				self._metaInputs = svcs
			}
			return self._metaInputs
		},

		/**
		 * @deprecated Use metaInputs instead.
		 * Returns resource service fields map name -> smart.Field
		 */
		serviceInputs: func() {
			return self.metaInputs()
		},

		// cached resource outputs (smart.Field)
		_outputs: undefined,
		/**
		 * Returns resource outputs map name -> smart.Field
		 */
		outputs: func() {
			if(self._outputs == undefined) {
				info := self.info()
				outputs := ll.toStrict(maps.mapValues(info.Outputs, field))
				if !info.OutputsLocked {
					return outputs
				}
				self._outputs = outputs
			}
			return self._outputs
		},

		/**
		 * Get smart.Field by name
		 *
		 * @param name field name
		 */
		getField: func(name) {
			if(!self.hasField(name)) {
				ll.panic("field %v is not found", name)
			}

			return field(ll.fieldId(self.id, name))
		},

		/**
		 * Get future field given field name and field type.
		 *
		 * @param name: string - field name
		 * @param fieldType: field type - input, output
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart.field
		 */
		getFutureField: func(name, fieldType, ...eph) {
			isEph := strictSelf.isEphemeral()
			if len(eph) > 0 && is_bool(eph[0]) {
				isEph = eph[0]
			}
			return _getFutureField(strictSelf, name, fieldType, isEph)
		},

		/**
		 * Gets a field with a default value (null) if field is not found
		 * after inputs/outputs are locked.
		 *
		 * @param name: string - field name
		 * @param fieldType: field type - input, output
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart.field - field referencing the result or null if field not found
		 */
		getFutureFieldOptional: func(name, fieldType, ...eph) {
			isEph := strictSelf.isEphemeral()
			if len(eph) > 0 && is_bool(eph[0]) {
				isEph = eph[0]
			}

			if is_bytes(name) {
				name = string(name)
			}
			ll.assert(is_string(name) && name != "", "field name must be a non-empty string")
			fieldId := ffDefault.getFutureFieldWithDefault(self.id, name, fieldType, isEph)
			return field(fieldId)
		},

		/**
		 * Get future input field given field name or a path
		 *
		 * @param nameOrPath: string|string[]|object|object[]
		 *                           - field name, an array representing a path to be traversed,
		 *                             an object with {name: string, optional?: bool, eph?: bool} structure,
		 *                             an array of such objects/strings
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart field
		 */
		getFutureInputField: func(nameOrPath, ...eph) {
			return _getFutureInputField(strictSelf, nameOrPath, eph...)
		},

		/**
		 * Get future output field given field name
		 *
		 * @param name: string - field name
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart.field
		 */
		getFutureOutputField: func(name, ...eph) {
			isEph := strictSelf.isEphemeral()
			if len(eph) > 0 {
				isEph = eph[0]
			}

			if !feats.pureFutureFields && !isEph {
				// Dirty hack that saves from issues with buggy pure getField before v1.16.1
				// We can safely drop it when we consider v1.16.0 old enough.
				return self.getFutureField(name, "output", true).expectNonEphemeral()
			}

			return self.getFutureField(name, "output", isEph)
		},

		/**
		 * Build a future field by traversing a specified path
		 *
		 * @param nameOrPath: string|string[]|object|object[]
		 *                           - field name, an array representing a path to be traversed,
		 *                             an object with {name: string, type?: string, optional?: bool, eph?: bool} structure,
		 *                             an array of such objects/strings
		 *
		 * @return field: smart field
		 */
		buildFutureField: func(nameOrPath) {
			return _buildFutureField(self, nameOrPath)
		},

		/**
		 * Get a resource set in field of a given field name
		 *
		 * @param name field name
		 */
		get: func(name) {
			return self.getField(name).getValue()
		},

		/**
		 * Get a resource set in field of a given field name,
		 * or a reference to the field itself if resource is not set yet.
		 *
		 * @param name field name
		 */
		getFieldOrResource: func(name) {
			field := self.getField(name)
			if field.isSet() {
				return field.getValue()
			} else {
				return field
			}
		},

		/**
		 * Create new dynamic field with given name.
		 * Dynamic fields are fields that can be created modified and deleted.
		 *
		 * @param name field name
		 */
		createDynamicField: func(name) {
			if is_bytes(name) {
				name = string(name)
			}
			ll.assert(is_string(name) && name != "", "field name must be a non-empty string")
			fid := ll.fieldId(self.id, name)
			tx.createField(fid, constants.FTYPE_DYNAMIC)
			return field(fid)
		},

		/**
		 * Gets value from key value storage associated with resource if corresponding
		 * record exists.
		 *
		 * Note: it uses resourceKeyValueGetIfExists under the hood.
		 *
		 * @param key: string - key
		 * @return bytes
		 */
		kvGet: func(key) {
			return tx.resourceKeyValueGet(self.id, key)
		},

		/**
		 * Gets a flag from key value storage associated with resource
		 *
		 * @param key: string - key
		 * @return bool
		 */
		kvGetFlag: func(key) {
			ll.assert(feats.fullFeaturedApi, "smart.resource.kvGetFlag: the feature is not available on older backends. Please, update the backend.")
			return tx.resourceKeyValueGetFlag(self.id, key)
		},

		/**
		 * Sets bytes or string value to a key value storage associated
		 * with resource.
		 *
		 * @param key string key
		 * @param value to be set
		 */
		kvSet: func(key, value) {
			tx.resourceKeyValueSet(self.id, key, value)
		},

		/**
		 * Sets a flag to a key value storage associated with resource
		 *
		 * @param key: string - key
		 * @param flag: bool
		 */
		kvSetFlag: func(key, flag) {
			ll.assert(feats.fullFeaturedApi, "smart.resource.kvSetFlag: the feature is not available on older backends. Please, update the backend.")
			tx.resourceKeyValueSetFlag(self.id, key, flag)
		},

		/**
		 * Gets value as string from key value storage associated with resource if
		 * corresponding record exists.
		 *
		 * @param key string key
		 * @return string or undefined
		 */
		kvGetAsString: func(key) {
			value := tx.resourceKeyValueGet(self.id, key)
			if is_undefined(value) {
				return undefined
			} else {
				return string(value)
			}
		},

		/**
		 * Gets value from key value storage associated with resource and
		 * decodes as json if corresponding record exists.
		 *
		 * @param key string key
		 * @return value or undefined
		 */
		kvGetAsJson: func(key) {
			bytes := self.kvGet(key)
			if is_undefined(bytes){
				return undefined
			} else {
				return json.decode(bytes)
			}
		},

		/**
		 * Sets json value to a key value storage associated with resource.
		 *
		 * @param key string key
		 * @param value to be set
		 */
		kvSetJson: func(key, value) {
			self.kvSet(key, json.encode(value))
		}
	}

	strictSelf = ll.toStrict(self)

	return strictSelf
}

field = func(f) {
	self := undefined
	strictSelf := undefined

	id := ll.isFieldId(f) ? f : f.ID

	if (is_undefined(id)) {
		ll.panic("undefined id in smart.field. <f>="+f)
	}

	self = {
		_type: "field",

		/**
		 * Field id struct:
		 *
		 *	ResourceID: int64
		 *	Name:		string
		 *
		 */
		id: id,

		/**
		 * Field name
		 */
		name: func() {
			return self.id.Name
		},

		/**
		 * Associated smart.Resource
		 */
		resource: func() {
			return resource(self.id.ResourceID)
		},

		/**
		 * Field info:
		 *
		 *	ID:			{ ResourceId: int64, Name: string }
		 *	Type:		string - see constants.FTYPE_* for possible values
		 *	Features:	{ ephemeral: bool }
		 *	Value:		int64 - value resource id
		 *	Error:		int64 - error resource id
		 *	IsSet:		bool  - whether field is set
		 */
		info: func() {
			return tx.getField(self.id)
		},

		/**
		 * Whether the field points to resource or error
		 */
		isSet: func() {
			return self.info().IsSet
		},

		/**
		 * Whether field is resolved to a value
		 */
		isValueSet: func() {
			return self.info().Value != 0
		},

		/**
		 * Whether field is resolved to a error
		 */
		isErrorSet: func() {
			return self.info().Error != 0
		},

		/**
		 * Some fields cannot point to ephemeral resources.
		 * This method checks, if current field can.
		 *
		 * @return bool - "true' when field can point to ephemeral resource, 'false' when not
		 */
		isEphemeral: func() {
			fieldInfo := self.info()

			if !maps.containsKey(fieldInfo, "Features") {
				// by default we consider all fields can point to ephemeral resources for backward compatiblity to keep stable logic
				// in platforma backend before v1.16.0.
				// TODO: once we consider this version old enough, we can panic here instead of 'return true'
				return true
			}

			isParentResourceEphemeral := fieldInfo.Features.ephemeral
			if isParentResourceEphemeral {
				return true
			}

			return fieldInfo.Type != constants.FTYPE_INPUT &&
				fieldInfo.Type != constants.FTYPE_OUTPUT
		},

		expectNonEphemeral: func() {
			rr := field(self.id)
			rr.isEphemeral = func() { return false }
			return rr
		},

		/**
		 * Use cacheMillis, cacheSeconds, cacheMinutes, cacheHours and cacheDays to not make hidden mistakes in cache time ranges.
		 * Sets the cache time.
		 *
		 * @param time: duration - the cache time from 'times' library.
		 */
		setCache: func(time) {
			ll.assert(is_int(time) && time >= times.millisecond,
				"smart.field.setCache: cache time must be an integer >= millisecond. Did you forget to import a standard tengo library 'times'?")

			tx.cacheSetToField(self.id, time)
			return strictSelf
		},

		/**
		 * Sets the cache time in milliseconds.
		 *
		 * @param millis: number
		 */
		setCacheMillis: func(millis) {
			ll.assert(is_int(millis) && millis > 0,
				"smart.field.setCacheMillis: cache time must be a number of milliseconds (> 0)")
			return self.setCache(millis * times.millisecond)
		},

		/**
		 * Sets the cache time in seconds.
		 *
		 * @param seconds: number
		 */
		setCacheSeconds: func(seconds) {
			ll.assert(is_int(seconds) && seconds > 0,
				"smart.field.setCacheSeconds: cache time must be a number of seconds (> 0)")
			return self.setCache(seconds * times.second)
		},

		/**
		 * Sets the cache time in minutes.
		 *
		 * @param minutes: number
		 */
		setCacheMinutes: func(minutes) {
			ll.assert(is_int(minutes) && minutes > 0,
				"smart.field.setCacheMinutes: cache time must be a number of minutes (> 0)")
			return self.setCache(minutes * times.minute)
		},

		/**
		 * Sets the cache time in hours.
		 *
		 * @param hours: number
		 */
		setCacheHours: func(hours) {
			ll.assert(is_int(hours) && hours > 0, "smart.field.setCacheHours: cache time must be a number of hours (> 0)")
			return self.setCache(hours * times.hour)
		},

		/**
		 * Sets the cache time in days
		 *
		 * @param days: number
		 */
		setCacheDays: func(days) {
			ll.assert(is_int(days) && days > 0, "smart.field.setCacheDays: cache time must be a number of days (> 0)")
			return self.setCache(days * 24 * times.hour)
		},

		/**
		 * Returns a smart.Resource object from the resolved field value
		 */
		getValue: func() {
			if self.isErrorSet() {
				err := self.getError().getDataAsJson()
				if !is_undefined(err.message) {
					err = err.message
				}
				ll.panic("failed to get the value of field %v, error is not empty: %v", self.name(), err)
			}

			ll.assert(self.isSet(), "field value is not set; field = %v", self.name())

			return resource(self.info().Value)
		},

		/**
		 * Returns a smart.Resource object from the resolved field error
		 */
		getError: func() {
			return resource(self.info().Error)
		},

		/**
		 * Set (resolve) this field to a Json resource
		 *
		 * @param value any
		 */
		setJson: func(value) {
			self.set(createJsonResource(value))
			return strictSelf
		},

		/**
		 * Set (resolve) this field to a Map resource
		 *
		 * @param keyToValue any
		 */
		setMap: func(keyToValue) {
			self.set(createMapResource(keyToValue))
			return strictSelf
		},

		/**
		 * Set (resolve) this field to either another resource or field
		 *
		 * @param reference smart.resource or smart.field
		 */
		set: func(reference) {
			ll.assert(!self.isSet(), "field ", self.name(), " is already set")

			if isResource(reference) {
				tx.setFieldToResource(self.id, reference.id)
			} else if isField(reference) {
				tx.setFieldToField(self.id, reference.id)
			} else {
				ll.panic("smart resource or smart field expected (target field %v), got %#v: ", self.name(), reference)
			}

			return strictSelf
		},

		/**
		 * Sets this field to either another resource, field or a JSON value.
		 *
		 * @param refOrJson: resource|field|JSON
		 * @return nothing
		 */
		setRefOrJson: func(refOrJson) {
			if is_undefined(refOrJson) {
				ll.panic("attempt to assign undefined value to field %v", self.name())
			}
			self.set(_toRefOrJson(refOrJson))
		},

		/**
		 * Returns a json encoded data of the resolved value resource
		 */
		getValueAsJson: func() {
			return self.getValue().getDataAsJson()
		},

		/**
		 * Get future field given field name and field type.
		 *
		 * @param name: string - field name
		 * @param fieldType: field type: input, output
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart.field
		 */
		getFutureField: func(name, fieldType, ...eph) {
			isEph := strictSelf.isEphemeral()
			if len(eph) > 0 && is_bool(eph[0]) {
				isEph = eph[0]
			}
			return _getFutureField(strictSelf, name, fieldType, isEph)
		},

		/**
		 * Gets a field with a default value (null) if field is not found
		 * after inputs/outputs are locked.
		 *
		 * @param name: string - field name
		 * @param fieldType: field type: input, output
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart.field - field referencing the result or null if field not found
		 */
		getFutureFieldOptional: func(name, fieldType, ...eph) {
			isEph := strictSelf.isEphemeral()
			if len(eph) > 0 && is_bool(eph[0]) {
				isEph = eph[0]
			}

			if is_bytes(name) {
				name = string(name)
			}
			ll.assert(is_string(name) && name != "", "field name must be a non-empty string")
			fieldId := ffDefault.getFutureFieldWithDefault(self.id, name, fieldType, isEph)
			return field(fieldId)
		},

		/**
		 * Get future input field given field name or a path
		 *
		 * @param nameOrPath: string|string[]|object|object[]
		 *                           - field name, an array representing a path to be traversed,
		 *                             an object with {name: string, optional?: bool, eph?: bool} structure,
		 *                             an array of such objects/strings
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart field
		 */
		getFutureInputField: func(nameOrPath, ...eph) {
			return _getFutureInputField(strictSelf, nameOrPath, eph...)
		},

		/**
		 * Get future output field given field name
		 *
		 * @param name: string - field name
		 * @param eph: bool (optional) - when false, the operation becomes pure function, waiting for resource
		 *                               to pass deduplication before resolution.
		 *
		 * @return field: smart field
		 */
		getFutureOutputField: func(name, ...eph) {
			isEph := strictSelf.isEphemeral()
			if len(eph) > 0 {
				isEph = eph[0]
			}

			if !feats.pureFutureFields && !isEph {
				// Dirty hack that saves from issues with buggy pure getField before v1.16.1
				// We can safely drop it when we consider v1.16.0 old enough.
				return self.getFutureField(name, "output", true).expectNonEphemeral()
			}

			return self.getFutureField(name, "output", isEph)
		},

		/**
		 * Build a future field by traversing a specified path
		 *
		 * @param nameOrPath: string|string[]|object|object[]
		 *                           - field name, an array representing a path to be traversed,
		 *                             an object with {name: string, type?: string, optional?: bool, eph?: bool} structure,
		 *                             an array of such objects/strings
		 *
		 * @return field: smart field
		 */
		buildFutureField: func(nameOrPath) {
			return _buildFutureField(strictSelf, nameOrPath)
		},

		/**
		 * Removes a value from multi-time writable fields (e.g. a dynamic field).
		 */
		reset: func() {
			ll.assert(feats.fullFeaturedApi, "smart.field.reset: the feature is not available on older backends. Please, update the backend.")
			tx.resetField(self.id)
		},

		/**
		 * Removes a multi-time writable (such as dynamic) field entirely.
		 */
		remove: func() {
			ll.assert(feats.fullFeaturedApi, "smart.field.remove: the feature is not available on older backends. Please, update the backend.")
			tx.removeField(self.id)
		}
	}

	strictSelf = ll.toStrict(self)

	return strictSelf
}


/**
 * Universal resource builder.
 *
 * @param r either resource id or resource info
 */
resourceBuilder = func(r) {
	super := resource(r)

	self := undefined

	// Mutator methods of the builder cannot be used after it was built.
	built := false
	assertNotBuilt := func() {
		ll.assert(!built, "builder methods must not be used after a build() was called")
	}

	self = ll.toStrict(oop.inherit(super, {
		/**
		 * Create new field with given name and field type.
		 *
		 * @param name field name
		 * @param fieldType: field type - input, output, dynamic, service, OTW. Use FTYPE_* constants.
		 */
		createField: func(name, fieldType) {
			assertNotBuilt()
			if is_bytes(name) {
				name = string(name)
			}
			ll.assert(is_string(name) && name != "", "field name must be a non-empty string")
			fid := ll.fieldId(super.id, name)
			tx.createField(fid, fieldType)
			return field(fid)
		},

		/**
		 * Create meta field with given name.
		 * Meta fields behave very like inputs, but with deduplication disabled.
		 * This means, that if you create 2 resources, each having 1 input field with value "A" and the meta
		 * field with different values, they would be considered the same by backend.
		 */
		createMetaField: func(name) {
			assertNotBuilt()
			return self.createField(name, constants.FTYPE_SERVICE)
		},

		/**
		 * @deprecated Use createMetaField instead.
		 * Create service field with given name.
		 * Service fields behave very like inputs, but with deduplication disabled.
		 * This means, that if you create 2 resources, each having 1 input field with value "A" and the service
		 * field with different values, they would be considered the same by backend.
		 */
		createServiceField: func(name) {
			return self.createMetaField(name)
		},

		/**
		 * Create new input field with given name.
		 *
		 * @param name field name
		 */
		createInputField: func(name) {
			assertNotBuilt()
			return self.createField(name, constants.FTYPE_INPUT)
		},

		/**
		 * Create new output field with given name.
		 *
		 * @param name field name
		 */
		createOutputField: func(name) {
			assertNotBuilt()
			return self.createField(name, constants.FTYPE_OUTPUT)
		},

		/**
		 * Lock resource outputs
		 */
		lockOutputs: func() {
			assertNotBuilt()
			tx.lockOutputs(super.id)
		},

		/**
		 * Lock resource inputs
		 */
		lockInputs: func() {
			assertNotBuilt()
			tx.lockInputs(super.id)
		},

		/**
		 * Lock both resource inputs and outputs
		 */
		lock: func() {
			assertNotBuilt()
			self.lockInputs()
			self.lockOutputs()
		},

		/**
		 * Lock inputs and outputs and return resulting smart.Resource
		 */
		lockAndBuild: func() {
			self.lock()
			built = true
			return super
		},

		/**
		 * Lock outputs and return resulting smart.Resource
		 */
		lockOutputsAndBuild: func() {
			self.lockOutputs()
			built = true
			return super
		},

		/**
		 * Lock inputs and return resulting smart.Resource
		 */
		lockInputsAndBuild: func() {
			self.lockInputs()
			built = true
			return super
		},

		/**
		 * Return smart.Resource without locking inputs and outputs
		 */
		buildUnlocked: func() {
			built = true
			return super
		}
	}))

	return self
}

/**
 * Creates a structural resource and returns a builder from it.
 *
 * @params resourceType a resource type
 * @params data, optional, bytes that will go in Data of the resource.
 */
structBuilder = func(resourceType, ...data) {
	id := undefined
	if len(data) > 0 {
		id = tx.createStruct(resourceType.Name, resourceType.Version, data[0])
	} else {
		id = tx.createStruct(resourceType.Name, resourceType.Version)
	}

	return resourceBuilder(id)
}

/**
 * @param isEph: is ephemeral map
 * @param resourceType: optional resource type for the map
 */
_mapBuilder := func(isEph, ...resourceType) {
	mapType := undefined
	if len(resourceType) > 0 {
		mapType = resourceType[0]
	} else {
		mapType = isEph ? constants.RTYPE_MAP_EPH : constants.RTYPE_MAP
	}

	builder := isEph ? ephemeralBuilder(mapType) : structBuilder(mapType)
	// ensure no outputs will be created
	builder.lockOutputs()

	self := undefined

	applyCache := func(field, ...opts) {
		if len(opts) > 0 {
			opt := opts[0]
			if is_map(opt) && !is_undefined(opt.cache) && opt.cache > 0 {
				field.setCache(opt.cache)
			}
		}
	}

	self = ll.toStrict(oop.inherit(builder, {
		/**
		 * Adds a reference to the map by a given key.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: reference - a field or resource that will be set in the field
		 * @param opts: optional map - cache options, e.g. { cache: times.hour }
		 * @return self: mapBuilder
		 */
		addRef: func(key, value, ...opts) {
			field := builder.createInputField(key)
			applyCache(field, opts...)
			field.set(value)
			return self
		},

		/**
		 * Adds a primitive value that can be converted to JSON to the map.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: any - a primitive value, e.g. Tengo's map.
		 * @param opts: optional map - cache options, e.g. { cache: times.hour }
		 * @return self: mapBuilder
		 */
		addJson: func(key, value, ...opts) {
			field := builder.createInputField(key)
			applyCache(field, opts...)
			field.set(createJsonResource(value))
			return self
		},

		/**
		 * Adds object automatically converting non-reference objects into Json values.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: any - a reference or a primitive value
		 * @param opts: optional map - cache options, e.g. { cache: times.hour }
		 * @return self: mapBuilder
		 */
		add: func(key, value, ...opts) {
			field := builder.createInputField(key)
			applyCache(field, opts...)
			field.setRefOrJson(value)
			return self
		},

		/**
		 * Adds object automatically converting non-reference objects into Json values.
		 * The object is added into meta field, meaning the value would not affect deduplication of the map.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: any - a reference or a primitive value
		 * @return self: mapBuilder
		 */
		addMeta: func(key, value) {
			builder.createMetaField(key).setRefOrJson(value)
			return self
		},

		/**
		 * @deprecated Use addMeta instead.
		 * Adds object automatically converting non-reference objects into Json values.
		 * The object is added into service field, meaning the value would not affect deduplication of the map.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: any - a reference or a primitive value
		 * @return self: mapBuilder
		 */
		addService: func(key, value) {
			return self.addMeta(key, value)
		},

		/**
		 * Creates a map in the platforma
		 *
		 * @return nothing
		 */
		build: func() {
			return builder.lockAndBuild()
		}
	}))

	return self
}

/**
 * Builder for map resource
 *
 * @param resourceType: optional { Name: "", Version: "" } - custom resource type for the map
 */
mapBuilder = func(...resourceType) {
	return _mapBuilder(false, resourceType...)
}

/**
 * Builder for ephemeral map resource
 *
 * @param resourceType: optional { Name: "", Version: "" } - custom resource type for the map
 */
ephemeralMapBuilder = func(...resourceType) {
	return _mapBuilder(true, resourceType...)
}

ephemeralBuilder = func(resourceType, ...data) {
	id := undefined
	if (len(data) > 0) {
		id = tx.createEphemeral(resourceType.Name, resourceType.Version, data[0])
	} else {
		id = tx.createEphemeral(resourceType.Name, resourceType.Version)
	}

	return resourceBuilder(id)
}

createNullResource = func(...data) {
	ll.assert(len(data) <= 1, "can't create null resource with more than one argument")
	if len(data) > 0 && !is_undefined(data[0]) {
		return resource(tx.createValue(constants.RTYPE_NULL.Name, constants.RTYPE_NULL.Version, data[0]))
	} else {
		return resource(tx.createValue(constants.RTYPE_NULL.Name, constants.RTYPE_NULL.Version, ""))
	}
}

createValueResource = func(resourceType, data) {
	ll.assert(data != undefined, "can't create resource with undefined data")
	return resource(tx.createValue(resourceType.Name, resourceType.Version, data))
}

createJsonResource = func(value) {
	ll.assert(value != undefined, "can't create Json value from undefined")

	// important: strict map can't be encoded to JSON

	ll.assert(!ll.isStrict(value), "can't encode strict map: ", value)
	// value = ll.ensureNonStrict(value)

	encoded := json.encode(value)

	return createValueResource(constants.RTYPE_JSON, encoded)
}

createMapResourceWithType := func(resourceType, keyToValue) {
	builder := structBuilder(resourceType)

	for key, value in keyToValue {
		builder.createInputField(key).setRefOrJson(value)
	}

	return builder.lockAndBuild()
}

createMapResource = func(keyToValue) {
	return createMapResourceWithType(constants.RTYPE_MAP, keyToValue)
}

createBinaryMapResource = func(keyToValue) {
	return createMapResourceWithType(constants.RTYPE_BINARY_MAP, keyToValue)
}

createBlobMapResource = func(keyToValue) {
	return createMapResourceWithType(constants.RTYPE_BLOB_MAP, keyToValue)
}

export ll.toStrict({
	isResource: isResource,
	isField: isField,
	isReference: isReference,
	isMapResource: isMapResource,
	isEphMapResource: isEphMapResource,
	isAnyMapResource: isAnyMapResource,
	isLockedEphMapResource: isLockedEphMapResource,
	isJsonResource: isJsonResource,
	isNullResource: isNullResource,
	resource: resource,
	field: field,
	resourceBuilder: resourceBuilder,
	structBuilder: structBuilder,
	mapBuilder: mapBuilder,
	ephemeralMapBuilder: ephemeralMapBuilder,
	ephemeralBuilder: ephemeralBuilder,
	createValueResource: createValueResource,
	createJsonResource: createJsonResource,
	createMapResourceWithType: createMapResourceWithType,
	createMapResource: createMapResource,
	createBinaryMapResource: createBinaryMapResource,
	createBlobMapResource: createBlobMapResource,
	createNullResource: createNullResource
})
