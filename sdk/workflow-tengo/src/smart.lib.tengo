/*
 * Library provides smart.Resource and smart.Field primitives.
 */

tx := import("tx")
ll := import(":ll")
maps := import(":maps")
json := import("json")
constants := import(":constants")
oop := import(":oop")

//////////////// definitions ///////////////////////////

/**
 * A read-only wrapper object around raw platforma resource
 */
resource := undefined

/**
 * A wrapper object around raw platforma resource field
 */
field := undefined

/**
 * A convenient builder for resource objects
 */
resourceBuilder := undefined

/**
 * Builder for structural resource
 *
 * @param resourceType {Name: "", Version: ""}
 */
structBuilder := undefined

/**
 * Builder for map resource
 */
mapBuilder := undefined

/**
 * Builder for emphemeral resources
 *
 * @param resourceType {Name: "", Version: ""}
 */
ephemeralBuilder := undefined

/**
 * Create value resource
 *
 * @param resourceType {Name: "", Version: ""}
 * @param data optional data
 */
createValueResource := undefined

/**
 * Create Json resource
 *
 * @param value value to save in the resource
 */
createJsonResource := undefined

/**
 * Create map resource
 *
 * @param map string -> smart resource or field
 */
createMapResource := undefined



////////////////// helpers ///////////////////////////

// internal helper function
isFieldId := func(val) {
	return ll.isStrict(val) && ll.fromStrict(val)["ResourceID"] != undefined
}

/**
 * Returns true if given object is a smart.Resource
 */
isResource := func(f) {
	return ll.isStrict(f) && ll.fromStrict(f)["_type"] == "resource"
}

/**
 * Returns true if given object is a smart.Field
 */
isField := func(f) {
	return ll.isStrict(f) && ll.fromStrict(f)["_type"] == "field"
}

/**
 * Returns true if given object is a smart.Field or smart.Resource
 */
isReference := func(f) {
	return isField(f) || isResource(f)
}

////////////////// implementation ///////////////////////////

/**
 * @param r either resource id or resource info
 */
resource = func(r) {
	self := undefined
	strictSelf := undefined

	id := ll.isStrict(r) ? r.ID : r

	if !is_int(id) {
		ll.panic("resource id should be int")
	}

	if id == 0 {
		ll.panic("null resource id")
	}

	self = {
		_type: "resource",

		/**
		 * Resource id (int64)
		 */
		id: id,

		/**
		 * Resource info:
		 *
		 *	ID:			   int64
		 *	Data:		   byte[],
		 *	Type:		   { Name: string, Version: string }
		 *	Inputs:		   strict map
		 *	Outputs:	   strict map
		 *	Dynamic:	   strict map
		 *	OTW:		   strict map
		 *	ResourceReady: bool
		 *	AllInputsSet:  bool
		 *	AllOutputsSet: bool
		 *	IsDuplicate:   bool
		 *	InputsLocked:  bool
		 *	OutputsLocked: bool
		 *	HasErrors:	   bool
		 */
		info: func() {
			return tx.getResource(self.id)
		},

		/**
		 * Get resource data as Json
		 */
		getDataAsJson: func() {
			return json.decode(self.info().Data);
		},

		_hasField: func(fieldMapName, fieldName) {
			return ll.fromStrict(self.info()[fieldMapName])[fieldName] != undefined
		},

		/**
		 * Whether ressource has input field with specified name
		 *
		 * @param name field name
		 */
		hasInputField: func(name) {
			return self._hasField("Inputs", name)
		},

		/**
		 * Whether ressource has output field with specified name
		 *
		 * @param name field name
		 */
		hasOutputField: func(name) {
			return self._hasField("Outputs", name)
		},

		/**
		 * Whether ressource has any field with specified name
		 *
		 * @param name field name
		 */
		hasField: func(name) {
			return self._hasField("Inputs", name) ||
				self._hasField("Outputs", name) ||
				self._hasField("DynamicFields", name) ||
				self._hasField("OneTimeWritables", name)
		},

		// cached _inputs
		_inputs: undefined,

		/**
		 * Returns resource inputs map name -> smart.Field
		 */
		inputs: func() {
			if self._inputs == undefined {
				info := self.info()
				inputs := maps.mapValues(info.Inputs, field)
				if !info.InputsLocked {
					return inputs
				}
				self._inputs = inputs
			}
			return self._inputs
		},

		// cached _outputs
		_outputs: undefined,
		/**
		 * Returns resource outputs map name -> smart.Field
		 */
		outputs: func() {
			if(self._outputs == undefined) {
				info := self.info()
				outputs := maps.mapValues(info.Outputs, field)
				if !info.OutputsLocked {
					return outputs
				}
				self._outputs = outputs
			}
			return self._outputs
		},

		/**
		 * Get smart.Field by name
		 *
		 * @param name field name
		 */
		getField: func(name) {
			if(!self.hasField(name)) {
				ll.panic("field %v is not found", name)
			}

			return field(ll.fieldId(self.id, name))
		},

		/**
		 * Get future field given field name and field type.
		 *
		 * @param name: field name
		 * @param fieldType: field type: input, output
		 * @return field: smart field
		 */
		getFutureField: func(name, fieldType) {
			futureField := tx.createFutureFieldID(fieldType, name)
			f := field(futureField.ResourceFID)
			f.set(strictSelf)

			return field(futureField.ResultFID)
		},

		/**
		 * Get future input field given field name
		 *
		 * @param name field name
		 * @return field: smart field
		 */
		getFutureInputField: func(name) {
			return self.getFutureField(name, "input")
		},

		/**
		 * Get future output field given field name
		 *
		 * @param name field name
		 * @return field: smart field
		 */
		getFutureOutputField: func(name) {
			return self.getFutureField(name, "output")
		},

		/**
		 * Get a resource set in field of a given field name
		 *
		 * @param name field name
		 */
		get: func(name) {
			return self.getField(name).getValue()
		}
	}

	strictSelf = ll.toStrict(self)

	return strictSelf
}

field = func(f) {
	self := undefined

	self = ll.toStrict({
		_type: "field",

		/**
		 * Field id struct:
		 *
		 *	ResourceID: int64
		 *	Name:		string
		 *
		 */
		id: isFieldId(f) ? f : f.ID,

		/**
		 * Field name
		 */
		name: func() {
			return self.id.Name
		},

		/**
		 * Associated smart.Resource
		 */
		resource: func() {
			return resource(self.id.ResourceID)
		},

		/**
		 * Field info:
		 *
		 *	ID:	   { ResourceId: int64, Name: string }
		 *	Value: int64 - value resource id
		 *	Error: int64 - error resource id
		 *	IsSet: bool	 - whether field is set
		 */
		info: func() {
			return tx.getField(self.id)
		},

		/**
		 * Whether field is set to either some resource or future from other field
		 */
		isSet: func() {
			return self.info().IsSet
		},

		/**
		 * Whether field is resolved to a value
		 */
		isValueSet: func() {
			return self.info().Value != 0
		},

		/**
		 * Whether field is resolved to a error
		 */
		isErrorSet: func() {
			return self.info().Error != 0
		},

		/**
		 * Returns a smart.Resource object from the resolved field value
		 */
		getValue: func() {
			if self.isErrorSet() {
				err := self.getError().getDataAsJson()
				ll.panic("failed to get the value of field ", field, ", error is not empty: ", err)
			}

			return resource(self.info().Value)
		},

		/**
		 * Returns a smart.Resource object from the resolved field error
		 */
		getError: func() {
			return resource(self.info().Error)
		},

		/**
		 * Set (resolve) this field to a Json resource
		 *
		 * @param value any
		 */
		setJson: func(value) {
			self.set(createJsonResource(value))
		},

		/**
		 * Set (resolve) this field to a Map resource
		 *
		 * @param keyToValue any
		 */
		setMap: func(keyToValue) {
			self.set(createMapResource(keyToValue))
		},

		/**
		 * Set (resolve) this field to either another resource or field
		 *
		 * @param reference smart.resource or smart.field
		 */
		set: func(reference) {
			ll.assert(!self.isSet(), "field ", self.name(), " is already set")

			if isResource(reference) {
				tx.setFieldToResource(self.id, reference.id)
			} else if isField(reference) {
				tx.setFieldToField(self.id, reference.id)
			} else {
				ll.panic("smart resource or smart field expected, got %#v: ", reference)
			}
		},

		/**
		 * Sets this field to either another resource, field or a JSON value.
		 *
		 * @param refOrJson: resource|field|JSON
		 * @return nothing
		 */
		setRefOrJson: func(refOrJson) {
			if isReference(refOrJson) {
				self.set(refOrJson)
			} else {
				// TODO deep check for map resource
				self.set(createJsonResource(refOrJson))
			}
		},

		/**
		 * Returns a json encoded data of the resolved value resource
		 */
		getValueAsJson: func() {
			return self.getValue().getDataAsJson()
		}
	})

	return self
}


/**
 * Universal resource builder.
 *
 * @param r either resource id or resource info
 */
resourceBuilder = func(r) {
	super := resource(r)

	self := undefined

	// Mutator methods of the builder cannot be used after it was built.
	built := false
	assertNotBuilt := func() {
		ll.assert(!built, "builder methods must not be used after a build() was called")
	}

	self = ll.toStrict(oop.inherit(super, {

		/**
		 * Create new field with given name and field type.
		 *
		 * @param name field name
		 * @param fieldType field type: input, output, dynamic, service, OTW (one-time writable)
		 */
		createField: func(name, fieldType) {
			assertNotBuilt()
			fid := ll.fieldId(super.id, name)
			tx.createField(fid, fieldType)
			return field(fid)
		},

		/**
		 * Create new input field with given name.
		 *
		 * @param name field name
		 */
		createInputField: func(name) {
			assertNotBuilt()
			return self.createField(name, "input")
		},

		/**
		 * Create new output field with given name.
		 *
		 * @param name field name
		 */
		createOutputField: func(name) {
			assertNotBuilt()
			return self.createField(name, "output")
		},

		/**
		 * Lock resource outputs
		 */
		lockOutputs: func() {
			assertNotBuilt()
			tx.lockOutputs(super.id)
		},

		/**
		 * Lock resource inputs
		 */
		lockInputs: func() {
			assertNotBuilt()
			tx.lockInputs(super.id)
		},

		/**
		 * Lock both resource inputs and outputs
		 */
		lock: func() {
			assertNotBuilt()
			self.lockInputs()
			self.lockOutputs()
		},

		/**
		 * Lock inputs and outputs and return resulting smart.Resource
		 */
		lockAndBuild: func() {
			self.lock()
			built = true
			return super
		},

		/**
		 * Lock outputs and return resulting smart.Resource
		 */
		lockOutputsAndBuild: func() {
			self.lockOutputs()
			built = true
			return super
		},

		/**
		 * Lock inputs and return resulting smart.Resource
		 */
		lockInputsAndBuild: func() {
			self.lockInputs()
			built = true
			return super
		},

		/**
		 * Return smart.Resource without locking inputs and outputs
		 */
		buildUnlocked: func() {
			built = true
			return super
		}
	}))

	return self
}

/**
 * Creates a structural resource and returns a builder from it.
 *
 * @params resourceType a resource type
 * @params data, optional, bytes that will go in Data of the resource.
 */
structBuilder = func(resourceType, ...data) {
	id := undefined
	if len(data) > 0 {
		id = tx.createStruct(resourceType.Name, resourceType.Version, data[0])
	} else {
		id = tx.createStruct(resourceType.Name, resourceType.Version)
	}

	return resourceBuilder(id)
}

mapBuilder = func() {
	builder := structBuilder(constants.RTYPE_MAP)
	// ensure no outputs will be created
	builder.lockOutputs()

	self := undefined

	self = ll.toStrict({
		/**
		 * Adds a reference to the map by a given key.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: reference - a field or resource that will be set in the field
		 * @return self: mapBuilder
		 */
		addRef: func(key, value) {
			builder.createInputField(key).set(value)
			return self
		},

		/**
		 * Adds a primitive value that can be converted to JSON to the map.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: any - a primitive value, e.g. Tengo's map.
		 * @return self: mapBuilder
		 */
		addJson: func(key, value) {
			builder.createInputField(key).set(createJsonResource(value))
			return self
		},

		/**
		 * Adds object automatically converting non-reference objects into Json values.
		 *
		 * @param key: string - how the field will be named in the map
		 * @param value: any - a reference or a primitive value
		 * @return self: mapBuilder
		 */
		add: func(key, value) {
			builder.createInputField(key).setRefOrJson(value)
			return self
		},


		/**
		 * Creates a map in the platforma
		 *
		 * @return nothing
		 */
		build: func() {
			return builder.lockAndBuild()
		}
	})

	return self
}

ephemeralBuilder = func(resourceType, ...data) {
	id := undefined
	if (len(data) > 0) {
		id = tx.createEphemeral(resourceType.Name, resourceType.Version, data[0])
	} else {
		id = tx.createEphemeral(resourceType.Name, resourceType.Version)
	}

	return resourceBuilder(id)
}

createValueResource = func(resourceType, data) {
	ll.assert(data != undefined, "can't create resource with undefined data")
	return resource(tx.createValue(resourceType.Name, resourceType.Version, data))
}

createJsonResource = func(value) {
	ll.assert(value != undefined, "can't create Json value from undefined")
	encoded := json.encode(value)
	return createValueResource(constants.RTYPE_JSON, encoded)
}

createMapResource = func(keyToValue) {
	builder := structBuilder(constants.RTYPE_MAP)

	for key, value in keyToValue {
		builder.createInputField(key).set(value)
	}

	return builder.lockAndBuild()
}

export ll.toStrict({
	isResource: isResource,
	isField: isField,
	isReference: isReference,
	resource: resource,
	field: field,
	resourceBuilder: resourceBuilder,
	structBuilder: structBuilder,
	mapBuilder: mapBuilder,
	ephemeralBuilder: ephemeralBuilder,
	createValueResource: createValueResource,
	createJsonResource: createJsonResource,
	createMapResource: createMapResource
})
