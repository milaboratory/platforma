test := import(":test")
ll := import(":ll")
plapi := import("plapi")

Test_ll_MethodExists := func() {
	//
	// Library module checks
	//
	test.isTrue(ll.methodExists(ll, "assert"), "wrong result from 'methodExists' check for ll.assert")
	test.isFalse(ll.methodExists(ll, "nonexistent"), "wrong result from 'methodExists' check for ll.nonexistent")

	//
	// Builtin module checks
	//
	test.isTrue(ll.methodExists(plapi, "newFieldID"), "wrong result from 'methodExists' check for plapi.newFieldID")
	test.isFalse(ll.methodExists(plapi, "nonexistent"), "wrong result from 'methodExists' check for plapi.nonexistent")
}

// The test just checks that a binding to Go backend works.
// Ideally we should test that the value is stored between template runs,
// but it's not possible to do it here.
// TODO: add a test in TypeScript.
Test_ll_getPersistentCtx := func() {
	ctx := ll.getPersistentCtx()
	ctx["theAnswer"] = 42

	test.isEqual(ll.getPersistentCtx()["theAnswer"], 42, "wrong value in persistent ctx")
}

// The test just checks that the value is stored between function calls.
Test_ll_getExecutionCtx := func() {
	ctx := ll.getExecutionCtx()
	ctx["theAnswer"] = 42

	test.isEqual(ll.getExecutionCtx()["theAnswer"], 42, "wrong value in execution ctx")
}

// The test checks that global variables are stored between different moduleVars invocations.
Test_ll_moduleVars := func() {
	vars := ll.moduleVars("mySuperFineModule")
	vars.set("theAnswer", 42)

	test.isEqual(vars.get("theAnswer"), 42, "wrong value in module vars")

	vars2 := ll.moduleVars("mySuperFineModule")
	test.isEqual(vars2.get("theAnswer"), 42, "wrong value in module vars")
}

Test_ll_sha256Encode := func() {
	hash := ll.sha256Encode(bytes("hello"))
	test.isEqual(hash, "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824", "wrong sha256 hash")
}
