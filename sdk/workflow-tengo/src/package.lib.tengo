ll := import(":ll")
smart := import(":smart")
oop := import(":oop")
maps := import(":maps")

META_KEY_DESCRIPTOR := "ctl/runner/software/descriptor"

_RTYPE_PACKAGE_GET := { Name: "PackageGet/exec", Version: "1" }
_INPUT_PACKAGE_NAME := "packageName"
_INPUT_REGISTRY := "registry"
_OUTPUT_ARCHIVE := "archive"

_RTYPE_PACKAGE_INSTALL := { Name: "PackageInstall/exec", Version: "1" }
_INPUT_PACKAGE := "package"
_OUTPUT_SOFTWARE := "software"

_getFromSource := func(binarySource, descriptor) {
	res := smart.structBuilder(_RTYPE_PACKAGE_GET)

	res.inputs()[_INPUT_REGISTRY].setRefOrJson(binarySource.registry)
	res.inputs()[_INPUT_PACKAGE_NAME].setRefOrJson(binarySource.package)
	res.kvSetJson(META_KEY_DESCRIPTOR, ll.fromStrict(descriptor))

	self := undefined
	self = oop.inherit(res, {
		/**
		 * Reference to the software package archive downloaded by 'get'
		 *
		 * @return archive: field - output field, where info on downloaded archive will appear
		 */
		archive: func() {
			return res.outputs()[_OUTPUT_ARCHIVE]
		}
	})

	return self
}

get := func(soft) {
	ll.assert(ll.isSoftwareInfo(soft),
		"package.get: <soft> must be software info. Get it from ll.importSoftware()")

	descriptor := soft.descriptor

	if (maps.containsKey(descriptor, "runEnv")) {
		return _getFromSource(descriptor.runEnv, descriptor)
	}

	if (maps.containsKey(descriptor, "binary")) {
		return _getFromSource(descriptor.binary, descriptor)
	}

	ll.panic(
		"software '%s v%s' is not available in binary format (no 'binary' or 'runEnv' sources in software descriptor)\n\t%s",
		soft.name, soft.version, descriptor
	)
}

install := func(pkg) {
	ll.assert(smart.isReference(pkg),
		"package.install: <pkg> must be reference to software package. It is usually obtained from package.get().archive")

	res := smart.structBuilder(_RTYPE_PACKAGE_INSTALL)

	res.inputs()[_INPUT_PACKAGE].set(pkg)

	self := undefined
	self = oop.inherit(res, {
		/**
		 * Reference to installed software
		 *
		 * @return software: field - output field, where info on downloaded archive will appear
		 */
		software: func() {
			return res.outputs()[_OUTPUT_SOFTWARE]
		}
	})

	return self
}

export ll.toStrict({
	META_KEY_DESCRIPTOR                : META_KEY_DESCRIPTOR,

	get                                : get,
	install                            : install
})
