/*
 * Library provides development kit for workflows
 */

tx := import("tx")
ll := import(":ll")
text := import("text")

constants := import(":constants")
context := import(":context")
smart := import(":smart")
maps := import(":maps")
sets := import(":sets")
tpl := import(":tpl-eph")

//
// Internal function helpers:
//

_RESULTS_FIELD_NAME			:= "result"
_INPUT_CONTEXT_FIELD_NAME	:= "context"
_OUTPUT_CONTEXT_FIELD_NAME	:= "context"

_isProduction := func() {
	return tpl.inputs().isProduction.getValueAsJson()
}

_isStaging := func() {
	return !_isProduction()
}

//
// Definitions and exports:
//

_args := undefined

/**
 * Returns a map of block Json arguments
 */
args := func() {
	if _args == undefined {
		field := tpl.inputs().args
		ll.assert(!is_undefined(field), "args are not set in workflow inputs")

		_args = ll.toStrict(field.getValueAsJson())
	}

	return _args
}

_blockId := undefined

/**
 * Id of corresponding block
 */
blockId := func() {
	if _blockId == undefined {
		_blockId = tpl.inputs().blockId
		ll.assert(!is_undefined(_blockId), "block id is not set in workflow inputs")
	}

	return _blockId
}

__parentContext := undefined

/**
 * Parent context
 */
_parentContext := func() {
	if __parentContext == undefined {
		__parentContext = tpl.inputs()[_INPUT_CONTEXT_FIELD_NAME]
		if __parentContext == undefined {
			ll.panic("parent context is not set in inputs")
		}
	}

	return __parentContext
}

/**
 * Utility function to build final template outputs given block results
 */
_buildOutputs := func(results) {
	ll.assert(ll.isMap(results), "expected to see map result from body function")
	ll.assert(
		sets.fromSlice(["outputs", "exports"]) == sets.fromMapKeys(results),
		"expected only results and exports in the returned map"
	)

	ll.assert(!is_undefined(results.outputs), "outputs are not defined in the results")
	ll.assert(!is_undefined(results.exports), "exports are not defined in the results")

	ll.assert(ll.isMap(results.outputs), "expected a map in outputs returned from workflow.body")
	ll.assert(ll.isMap(results.exports), "expected a map in exports returned from workflow.body")

	// block outputs
	o := results.outputs
	// block exports
	e := results.exports

	// create results map
	resBuilder := smart.mapBuilder()
	for name, value in o {
		if smart.isReference(value) {
			resBuilder.add(name, value)
		} else {
			// TODO replace with smart conversion
			resBuilder.addJson(name, value)
		}
	}

	// create ctx and save exports
	ctxBuilder := context.builder(blockId(), _parentContext())
	for name, value in e {
		ctxBuilder.add(name, value)
	}

	// final temlate outputs
	tplOutputs := {}
	tplOutputs[_RESULTS_FIELD_NAME] = resBuilder.build()
	tplOutputs[_OUTPUT_CONTEXT_FIELD_NAME] = ctxBuilder.build()

	return tplOutputs
}

/**
 * Defines main entry point for current workflow
 */
body := func(bodyFn) {
	return tpl.body(func(_) {

		if !_isProduction() {
			// nothing to do
			return {}
		}

		workflowInputArgs := args()
		result := bodyFn(workflowInputArgs)

		return _buildOutputs(result)
	})
}

/**
 * Defines a pre run entry point for a current workflow
 */
preRun := func(preRunFn) {
	return tpl.body(func(_) {

		if !_isStaging() {
			// nothing to do
			return {}
		}

		workflowInputArgs := args()
		result := preRunFn(workflowInputArgs)

		return _buildOutputs(result)
	})
}

export ll.toStrict({
	body: body,
	preRun: preRun
})
