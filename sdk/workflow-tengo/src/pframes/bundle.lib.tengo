smart := import(":smart")
json := import("json")
text := import("text")
pConstants := import(":pframes.constants")
bquery := import(":workflow.bquery")
canonical := import(":canonical")
pSpec := import(":pframes.spec")
pBuilder := import(":pframes.builder")
maps := import(":maps")
ll := import(":ll")
xsv := import(":pframes.xsv")
assets := import(":assets")
render := import(":render")

/**
 * Creates a collector to asynchronously aggregate PColumns into a resolved PColumnBundle.
 *
 * The PColumnBundleCollector maintains references, anchors, and queries which are used to fetch
 * and resolve PColumns asynchronously from a given result pool. The final PColumnBundle provides
 * easy and direct access to resolved PColumns.
 *
 * === Usage Flow ===
 *
 * 1. Add anchors, anchored queries and standalone references and queries to the collector
 * 2. Call `build` and pass the result to a different template or use in preload
 * 3. Use the PColumnBundle from the arguments of the nested template to interact with the data
 *
 * === Available Methods ===
 *
 *   addRef(ref)
 *     - Adds a standalone reference to be resolved separately from anchors
 *
 *   addAnchor(anchorId, ref)
 *     - Adds an anchor with the given ID and reference to be resolved
 *
 *   addById(id)
 *     - Adds a PColumn by its anchored or absolute ID
 *
 *   addQuery(queryId, query)
 *     - Adds a custom query with the given ID to be resolved
 *
 *   build()
 *     - Resolves all references and queries and returns a PColumnBundle
 *
 * === Parameters ===
 *
 * @param ctx {Context} - The context to use for resolution
 *
 * === Returns ===
 *
 * @returns {Object} PColumnBundleCollector object with methods to add and resolve references
 */
createBuilder := func(ctx) {
	// reference key -> anchor id or ref
	//   - if points to string resolution result can be taken from the anchor query
	//   - if points to object resolution should be done separately
	refs := {}
	// anchor id -> ref
	anchors := {}
	// query id -> query
	queries := {}

	self := undefined
	self = {
		/**
		 * Adds a reference to the bundle collector.
		 *
		 * @param ref: PlRef - The reference to the anchor
		 */
		addRef: func(ref) {
			refKey := canonical.encode(ref)

			// if ref points to string resolution result can be taken from the anchor
			if !is_string(refs[refKey]) {
				refs[refKey] = ref
			}
		},

		/**
		 * Adds an anchor to the bundle collector.
		 *
		 * @param anchorId: string - The ID of the anchor to add
		 * @param ref: string - The reference to the anchor
		 */
		addAnchor: func(anchorId, ref) {
			anchors[anchorId] = ref
			refKey := canonical.encode(ref)
			if is_undefined(refs[refKey]) || is_map(refs[refKey]) {
				refs[refKey] = anchorId
			} else {
				refs[refKey] = ref
			}
		},

		/**
		 * Adds a PColumn to the bundle collector by PColumnId or APColumnId.
		 *
		 * @param id: string or object - The ID of the PColumn (can be anchored or absolute)
		 */
		addById: func(id) {
			if is_string(id) {
				queries[id] = json.decode(id)
			} else {
				queries[canonical.encode(id)] = id
			}
		},

		/**
		 * Adds a query to the bundle collector.
		 *
		 * @param queryId: string - The ID of the query
		 * @param query: APColumnSelector - The query
		 */
		addQuery: func(queryId, query) {
			queries[queryId] = query
		},

		/**
		 * Builds the bundle.
		 *
		 * @return PColumnBundle - The resolved bundle with all references and queries
		 */
		build: func() {
			resolveResult := bquery.anchoredQuery(ctx, anchors, queries)

			bundle := smart.mapBuilder(pConstants.RTYPE_P_COLUMN_BUNDLE)

			for refKey, ref in refs {
				if is_string(ref) {
					bundle.addRef(refKey, resolveResult.getAnchor(ref))
				} else {
					bundle.addRef(refKey, bquery.resolve(ref, ctx))
				}
			}

			for queryId, query in queries {
				bundle.addRef(queryId, resolveResult.getResult(queryId))
			}

			return bundle.build()
		}
	}

	return self
}

nameCleanPattern := text.re_compile("[-_,.:; \\[\\]}{\"\\\\/:]+")

cleanColumnName := func(name) {
	return nameCleanPattern.replace(name, "_")
}

/**
 * Creates an unmarshaller for PColumnBundle resources.
 *
 * The PColumnBundleUnmarshaller processes PColumnBundle resources into a structured
 * object that provides easy way to interact with the data in the pool.
 *
 * @returns Object that implements the unmarshaller interface {canParse, parse}
 */
pColumnBundleUnmarshaller := func() {
	return {
		canParse: func(resource) {
			return smart.isResource(resource) &&
				resource.info().Type.Name == pConstants.RTYPE_P_COLUMN_BUNDLE.Name
		},

		parse: func(resource, parser) {
			bResultUnmarshaller := bquery.resultUnmarshaller()

			pool := {}

			for resultKey, value in resource.inputs() {
				if !bResultUnmarshaller.canParse(value.getValue()) {
					ll.panic("Failed to unmarshal value for key: " + resultKey)
				}

				result := bResultUnmarshaller.parse(value.getValue(), parser)

				pool[resultKey] = {
					safeName: cleanColumnName(resultKey),
					spec: result.spec,
					data: result.data
				}
			}

			// Holds overrides to default headers for axes and columns in xsv exported outputs
			// Array of:
			//   [{ name: string, domain: {[domainKey: string]: string} }, header: string]
			headerOverrides := []

			bundle := undefined
			bundle = ll.toStrict({
				/**
				 * Gets a specific column by its ID
				 * @param resultKey - The ID of the column to retrieve
				 * @returns The column object with its spec, data and distilled spec
				 */
				getColumn: func(resultKey) {
					if !is_string(resultKey) {
						resultKey = canonical.encode(resultKey)
					}

					if is_undefined(pool[resultKey]) {
						ll.panic("Column not found: " + resultKey)
					}
					return pool[resultKey]
				},

				/**
				 * Sets a header override for a specific axis or column
				 * @param matcher - Either a matcher object {name, domain} or a string (which will be used as the name)
				 * @param header - The header text to use instead of the default
				 * @returns The bundle object for chaining
				 */
				setHeader: func(matcher, header) {
					if is_string(matcher) {
						matcher = { name: matcher, domain: {} }
					}

					headerOverrides = [[matcher, header]] + headerOverrides
					return bundle
				},

				/**
				 * Creates a builder object to help create XSV tables from the bundle data
				 */
				xsvTableBuilder: func() {
					// Create a local copy of the header overrides
					localHeaderOverrides := copy(headerOverrides)

					findHeaderOverride := func(name) {
						for _, override in localHeaderOverrides {
							if override[0].name == name {
								return override[1]
							}
						}
						return undefined
					}

					// Generate a label for a spec based on various inputs
					generateLabel := func(spec, headerOverride, axisFilters, columnKey, distiller) {
						name := spec.name
						label := undefined

						// If explicit header override is provided, use it
						if !is_undefined(headerOverride) {
							return headerOverride
						}

						// Try to find a matching header override
						label = findHeaderOverride(name)

						// If no override, use the spec name if there are no discriminative domains
						if is_undefined(label) {
							discriminativeDomains := distiller.getDiscriminativeDomains(name)

							if len(discriminativeDomains) == 0 {
								label = name
							} else {
								ll.panic("Cannot deduce header for %s in column / axis: %s. Discriminative domains: %s. Please provide a header override.",
									name, columnKey, discriminativeDomains)
							}
						}

						if is_undefined(label) {
							ll.panic("Cannot deduce header for %s in column / axis: %s. Please provide a header override.",
								name, columnKey)
						}

						// Append filter values to label if provided
						if !is_undefined(axisFilters) && len(axisFilters) > 0 {
							// Create a canonical string representation of axis filters
							filtersStr := ""
							for _, filter in axisFilters {
								if filtersStr != "" {
									filtersStr += "_"
								}
								filtersStr += string(filter[1])
							}

							label = label + "_" + filtersStr
						}

						return label
					}

					addLabel := func(spec, headerOverride, columnKey, distiller, axisFilters) {
						label := generateLabel(spec, headerOverride, axisFilters, columnKey, distiller)
						return maps.deepMerge(spec, { annotations: { "pl7.app/label": label } })
					}

					requests := []

					tableBuilder := undefined
					tableBuilder = {
						/**
						 * Adds a column to the table
						 * @param key - The ID of the column to add (string or GeneralizedPColumnId object)
						 * @param ops - Optional operations, can include:
						 *   - header: string - Override for the column header
						 *   - axisFilters: [number|string, any][] - Filters to apply to axes
						 */
						add: func(key, ...ops) {
							columnKey := key
							columnAxisFilters := undefined

							// Handle GeneralizedPColumnId (SlicedPColumnId or CanonicalPColumnId)
							if is_map(key) {
								if !is_undefined(key.source) {
									// This is a SlicedPColumnId
									columnKey = key.source
									columnAxisFilters = key.axisFilters
								} else {
									columnKey = key
								}

								// Convert to string for lookup
								if !is_string(columnKey) {
									columnKey = canonical.encode(columnKey)
								}
							}

							if is_undefined(pool[columnKey]) {
								ll.panic("Column not found: " + columnKey)
							}

							request := {
								key: columnKey
							}

							if !is_undefined(columnAxisFilters) {
								request.axisFilters = columnAxisFilters
							}

							if len(ops) > 0 {
								if !is_undefined(ops[0].header) {
									request.headerOverride = ops[0].header
								}

								if !is_undefined(ops[0].axisFilters) {
									if !is_undefined(request.axisFilters) {
										request.axisFilters = request.axisFilters + ops[0].axisFilters
									} else {
										request.axisFilters = ops[0].axisFilters
									}
								}
							}

							requests = append(requests, request)
							return tableBuilder
						},

						/**
						 * Sets a header override for a specific axis or column in this table
						 * @param matcher - Either a matcher object {name, domain} or a string (which will be used as the name)
						 * @param header - The header text to use instead of the default
						 * @returns The table builder object for chaining
						 */
						setHeader: func(matcher, header) {
							if is_string(matcher) {
								matcher = { name: matcher, domain: {} }
							}

							localHeaderOverrides = [[matcher, header]] + localHeaderOverrides
							return tableBuilder
						},

						/**
						 * Builds the table for XSV export
						 * @param format - Format for export, either 'csv' or 'tsv'
						 */
						build: func(format) {
							columnsToDistill := []
							sliceDataTemplate := assets.importTemplate(":pframes.slice-data")

							for request in requests {
								col := pool[request.key]
								columnsToDistill = append(columnsToDistill, col.spec)
							}

							columnDistiller := pSpec.createSpecDistiller(columnsToDistill)

							pFrame := pBuilder.pFrameBuilder()

							for request in requests {
								col := pool[request.key]
								colSpec := col.spec
								colData := col.data
								preparedAxisFilters := undefined

								// Process axis filters if present
								if !is_undefined(request.axisFilters) {
									prepared := pSpec.prepareAxisFilters(request.axisFilters, colSpec)

									// Update the column spec to the filtered one
									colSpec = prepared.columnSpec
									preparedAxisFilters = prepared.axisFilters

									// Slice the data using the slice-data template
									slicingParamsResource := smart.createJsonResource(prepared.axisFilters)
									colData = render.createEphemeral(sliceDataTemplate, {
										data: colData,
										slicingParams: slicingParamsResource
									}).output("result")
								}

								preparedSpec := columnDistiller.distill(colSpec)
								preparedSpec = addLabel(preparedSpec, request.headerOverride, request.key, columnDistiller, preparedAxisFilters)

								for i, axis in preparedSpec.axesSpec {
									preparedSpec.axesSpec[i] = addLabel(axis, undefined, request.key, columnDistiller, undefined)
								}

								pFrame.add(col.safeName, preparedSpec, colData)
							}

							return xsv.exportFrame(pFrame.build(), format, {})
						}
					}

					return tableBuilder
				}
			})

			return bundle
		}
	}
}

export ll.toStrict({
	createBuilder: createBuilder,
	pColumnBundleUnmarshaller: pColumnBundleUnmarshaller
})
