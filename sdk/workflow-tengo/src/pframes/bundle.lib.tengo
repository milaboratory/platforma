smart := import(":smart")
json := import("json")
pConstants := import(":pframes.constants")
bquery := import(":workflow.bquery")
canonical := import(":canonical")
pSpec := import(":pframes.spec")
maps := import(":maps")
ll := import(":ll")
slices := import(":slices")
xsv := import(":pframes.xsv")

/**
 * Creates a collector to asynchronously aggregate PColumns into a resolved PColumnBundle.
 *
 * The PColumnBundleCollector maintains references, anchors, and queries which are used to fetch
 * and resolve PColumns asynchronously from a given result pool. The final PColumnBundle provides
 * easy and direct access to resolved PColumns.
 *
 * === Usage Flow ===
 *
 * 1. Add anchors, anchored queries and standalone references and queries to the collector
 * 2. Call `build` and pass the result to a different template or use in preload
 * 3. Use the PColumnBundle from the arguments of the nested template to interact with the data
 *
 * === Available Methods ===
 *
 *   addRef(ref)
 *     - Adds a standalone reference to be resolved separately from anchors
 *
 *   addAnchor(anchorId, ref)
 *     - Adds an anchor with the given ID and reference to be resolved
 *
 *   addById(id)
 *     - Adds a PColumn by its anchored or absolute ID
 *
 *   addQuery(queryId, query)
 *     - Adds a custom query with the given ID to be resolved
 *
 *   build()
 *     - Resolves all references and queries and returns a PColumnBundle
 *
 * === Parameters ===
 *
 * @param ctx {Context} - The context to use for resolution
 *
 * === Returns ===
 *
 * @returns {Object} PColumnBundleCollector object with methods to add and resolve references
 */
pColumnBundleCollector := func(ctx) {
	// reference key -> anchor id or ref
	//   - if points to string resolution result can be taken from the anchor query
	//   - if points to object resolution should be done separately
	refs := {}
	// anchor id -> ref
	anchors := {}
	// query id -> query
	queries := {}

	self := undefined
	self = {
		/**
		 * Adds a reference to the bundle collector.
		 *
		 * @param ref: PlRef - The reference to the anchor
		 */
		addRef: func(ref) {
			refKey := canonical.encode(ref)

			// if ref points to string resolution result can be taken from the anchor
			if !is_string(refs[refKey]) {
				refs[refKey] = ref
			}
		},

		/**
		 * Adds an anchor to the bundle collector.
		 *
		 * @param anchorId: string - The ID of the anchor to add
		 * @param ref: string - The reference to the anchor
		 */
		addAnchor: func(anchorId, ref) {
			anchors[anchorId] = ref
			refKey := canonical.encode(ref)
			if is_undefined(refs[refKey]) || is_map(refs[refKey]) {
				refs[refKey] = anchorId
			} else {
				refs[refKey] = ref
			}
		},

		/**
		 * Adds a PColumn to the bundle collector by PColumnId or APColumnId.
		 *
		 * @param id: string or object - The ID of the PColumn (can be anchored or absolute)
		 */
		addById: func(id) {
			if is_string(id) {
				queries[id] = json.decode(id)
			} else {
				queries[canonical.encode(id)] = id
			}
		},

		/**
		 * Adds a query to the bundle collector.
		 *
		 * @param queryId: string - The ID of the query
		 * @param query: APColumnSelector - The query
		 */
		addQuery: func(queryId, query) {
			queries[queryId] = query
		},

		/**
		 * Builds the bundle.
		 *
		 * @return PColumnBundle - The resolved bundle with all references and queries
		 */
		build: func() {
			resolveResult := bquery.anchoredQuery(ctx, anchors, queries)

			bundle := smart.mapBuilder(pConstants.RTYPE_P_COLUMN_BUNDLE)

			for refKey, ref in refs {
				if is_string(ref) {
					bundle.addRef(refKey, resolveResult.getAnchor(ref))
				} else {
					bundle.addRef(refKey, bquery.resolve(ref, ctx))
				}
			}

			for queryId, query in queries {
				bundle.addRef(queryId, resolveResult.getResult(queryId))
			}

			return bundle.build()
		}
	}
}

/**
 * Creates an unmarshaller for PColumnBundle resources.
 *
 * The PColumnBundleUnmarshaller processes PColumnBundle resources into a structured
 * object that provides easy way to interact with the data in the pool.
 *
 * @returns Object that implements the unmarshaller interface {canParse, parse}
 */
pColumnBundleUnmarshaller := func() {
	return {
		canParse: func(resource) {
			return smart.isResource(resource) &&
				resource.info().Type.Name == pConstants.RTYPE_P_COLUMN_BUNDLE.Name
		},

		parse: func(resource, parser) {
			bResultUnmarshaller := bquery.resultUnmarshaller()

			columnPool := {}
			allSpecs := []

			for resultKey, value in resource.inputs() {
				if !bResultUnmarshaller.canParse(value.getValue()) {
					ll.panic("Failed to unmarshal value for key: " + resultKey)
				}

				result := bResultUnmarshaller.parse(value.getValue(), parser)

				columnPool[resultKey] = {
					name: resultKey,
					spec: result.spec,
					data: result.data
				}

				allSpecs = append(allSpecs, result.spec)
			}

			distiller := pSpec.createSpecDistiller(allSpecs)

			for resultKey, poolEntry in columnPool {
				poolEntry.distilledSpec = maps.deepMerge(
					distiller.distill(poolEntry.spec),
					{ annotations: { "pl7.app/label": poolEntry.name } }
				)
			}

			// Holds overrides to default headers for axes and columns in xsv exported outputs
			// Array of:
			//   [{ name: string, domain: {[domainKey: string]: string} }, header: string]
			headerOverrides := []

			bundle := undefined
			bundle = ll.toStrict({
				/**
				 * Gets a specific column by its ID
				 * @param resultKey - The ID of the column to retrieve
				 * @returns The column object with its spec, data and distilled spec
				 */
				getColumn: func(resultKey) {
					if is_undefined(columnPool[resultKey]) {
						ll.panic("Column not found: " + resultKey)
					}
					return columnPool[resultKey]
				},

				/**
				 * Sets a header override for a specific axis or column
				 * @param matcher - Either a matcher object {name, domain} or a string (which will be used as the name)
				 * @param header - The header text to use instead of the default
				 * @returns The bundle object for chaining
				 */
				setHeader: func(matcher, header) {
					if is_string(matcher) {
						matcher = { name: matcher, domain: {} }
					}

					headerOverrides = [[matcher, header]] + headerOverrides
					return bundle
				},

				/**
				 * Creates a builder object to help create XSV tables from the bundle data
				 */
				buildTable: func() {
					columns := []
					// Create a local copy of the header overrides
					localHeaderOverrides := slices.copy(headerOverrides)

					findHeaderOverride := func(name) {
						for _, override in localHeaderOverrides {
							if override[0].name == name {
								return override[1]
							}
						}
						return undefined
					}

					addLabel := func(spec, headerOverride, columnKey, distiller) {
						name := spec.name
						label := undefined

						if !is_undefined(headerOverride) {
							label = headerOverride
						} else {
							label = findHeaderOverride(name)

							if is_undefined(label) {
								hasDiscriminativeDomains := len(distiller.getDiscriminativeDomainsSet(name)) > 0

								if !hasDiscriminativeDomains {
									label = name
								}
							}
						}

						if is_undefined(label) {
							ll.panic("Cannot deduce header for " + name + " in column: " + columnKey + ". Please provide a header override.")
						}

						return maps.deepMerge(spec, { annotations: { "pl7.app/label": label } })
					}

					tableBuilder := undefined
					tableBuilder = {
						/**
						 * Adds a column to the table
						 */
						add: func(key, ...ops) {
							if is_undefined(columnPool[key]) {
								ll.panic("Column not found: " + key)
							}

							entry := {
								key: key
							}

							if len(ops) > 0 && !is_undefined(ops[0].header) {
								entry.headerOverride = ops[0].header
							}

							columns = append(columns, entry)
							return tableBuilder
						},

						/**
						 * Sets a header override for a specific axis or column in this table
						 * @param matcher - Either a matcher object {name, domain} or a string (which will be used as the name)
						 * @param header - The header text to use instead of the default
						 * @returns The table builder object for chaining
						 */
						setHeader: func(matcher, header) {
							if is_string(matcher) {
								matcher = { name: matcher, domain: {} }
							}

							localHeaderOverrides = [[matcher, header]] + localHeaderOverrides
							return tableBuilder
						},

						/**
						 * Builds the table for XSV export
						 * @param format - Format for export, either 'csv' or 'tsv'
						 */
						build: func(format) {
							pframe := {}
							columnsToDistill := []

							for _, entry in columns {
								col := columnPool[entry.key]

								pframe[entry.key] = {
									spec: col.spec,
									data: col.data
								}

								columnsToDistill = append(columnsToDistill, col.spec)
							}

							columnDistiller := pSpec.createSpecDistiller(columnsToDistill)

							for _, entry in columns {
								col := columnPool[entry.key]
								colSpec := col.spec
								distilledSpec := columnDistiller.distill(colSpec)

								distilledSpec = addLabel(distilledSpec, entry.headerOverride, entry.key, columnDistiller)

								for i, axis in distilledSpec.axesSpec {
									distilledSpec.axesSpec[i] = addLabel(axis, undefined, entry.key, columnDistiller)
								}

								pframe[entry.key].spec = distilledSpec
							}

							return xsv.exportFrame(pframe, format, {})
						}
					}

					return tableBuilder
				}
			})

			return bundle
		}
	}
}

export ll.toStrict({
	pColumnBundleCollector: pColumnBundleCollector,
	pColumnBundleUnmarshaller: pColumnBundleUnmarshaller
})
