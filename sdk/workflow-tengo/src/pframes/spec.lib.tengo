/**
 * PFrames spec library:
 *  - well known domains, annotations and column names.
 *  - utility methods to manipulate column and axis spec
 */

ll := import(":ll")
maps := import(":maps")
validation := import(":validation")
json := import("json")

//
// Common schemas
//

P_AXIS_SPEC_SCHEMA := {
	// `__options__,closed`: ``, // commented out to keep the room for future schema modifications
	`type`: `string,regex=Int|Long|Float|Double|String`,
	`name`: `string`,
	`domain,?`: { any: `string` },
	`annotations,?`: { any: `string` },
	`parentAxes,?`: `any` // [ `number` ]
}

P_COLUMN_SPEC_SCHEMA := {
	// `__options__,closed`: ``, // commented out to keep the room for future schema modifications
	`kind`: `string,regex=PColumn`,
	`valueType`: `string`,
	`name`: `string`,
	`domain,?`: { any: `string` },
	`annotations,?`: { any: `string` },
	`parentAxes,?`: `any`, // [ `number` ]
	`axesSpec,?`: [ P_AXIS_SPEC_SCHEMA ]
}

KIND_P_COLUMN := "PColumn"

//
// Column / axis names
//

/** Column containing labels for axis keys */
N_LABEL := "pl7.app/label"

//
// Column / axis domains
//

/** Domain marking column or axis as block-specific, value must contain block id */
D_BLOCK := "pl7.app/block"

//
// Column / axis annotations
//

/** Annotation with axis or column label */
A_LABEL := "pl7.app/label"
/**
 * Annotation containing trace of operations resulting in a corresponding column.
 *
 * Value must containe JSON encoded array of structures:
 *   {
 *      type: string       - type of the step, often equals to block package name (i.e. milaboratories.mixcr-clonotyping)
 *      label: string      - string representation of the operation often a block title
 *      importance: number - higher the number higher the change label from trace step will be used to derive column label
 *      id: string         - unique identifier of operation, often a block id
 *   }
 */
A_TRACE := "pl7.app/trace"

//
// Matchers
//

_P_MATCHER_SCHEMA := {
	`__options__,closed`: ``,
	`type,?`: `string,regex=Int|Long|Float|Double|String`,
	`name`: `string`,
	`domain,?`: { any: `string` }
}

_normalizeMatcher := func(matcher) {
	if is_string(matcher) {
		return { name: matcher }
	} else {
		validation.assertType(matcher, _P_MATCHER_SCHEMA)
		return matcher
	}
}

_checkAxisMatch := func(axisSpec, matcher) {
	if axisSpec.name != matcher.name {
		return false
	}
	if !is_undefined(matcher.type) && axisSpec.type != matcher.type {
		return false
	}
	if !is_undefined(matcher.domain) {
		for domain, domainValue in matcher.domain {
			if is_undefined(axisSpec.domain) || axisSpec.domain[domain] != domainValue {
				return false
			}
		}
	}
	return true
}

/**
 * For a given array of axes specs tries find the index of matching axis:
 *   - if multiple matches are found - panics
 *   - if axis not found returns -1
 */
tryMatchAxis := func(axesSpec, matcher) {
	validation.assertType(axesSpec, [ P_AXIS_SPEC_SCHEMA ])
	matcher = _normalizeMatcher(matcher)
	found := -1
	for idx, axisSpec in axesSpec {
		if !_checkAxisMatch(axisSpec, matcher) {
			continue
		}
		if found != -1 {
			ll.panic("multiple matches found for %v in %v", matcher, axesSpec)
		}
		found = idx
	}
	return found
}

/**
 * For a given array of axes specs returns the index of matching axis:
 *   - if multiple matches are found - panics
 *   - if axis not found - panics
 */
matchAxis := func(axesSpec, matcher) {
	found := tryMatchAxis(axesSpec, matcher)
	if found == -1 {
		ll.panic("match not found for %v in %v", matcher, axesSpec)
	}
	return found
}

/**
 * For a given array of axes specs and array of matchers returns array of indices of mathed axes
 * in the same order as matchers:
 *   - if multiple matches are found - panics
 *   - if any axis not found - panics
 *   - if multiple matchers matches the same axis - panics
 */
matchAxes := func(axesSpec, matchers) {
	result := []
	resultSet := {}
	for matcher in matchers {
		idx := matchAxis(axesSpec, matcher)
		idxS := string(idx)
		if resultSet[idxS] {
			ll.panic("duplicate match detecterd for %v in %v (idx = %v)", matchers, axesSpec, idx)
		}
		resultSet[idxS] = true
		result = append(result, idx)
	}
	return result
}

//
// Utility methods
//

_TRACE_STEP_SCHEMA := {
	`type`: `string`,
	`label`: `string`,
	`importance,?`: `number`,
	`id,?`: `string`,
	`__options__,closed`: ``
}

_TRACE_SCHEMA := [_TRACE_STEP_SCHEMA]

/**
 * Calculates content of pl7.app/trace annotation, given input column spec, or annotations section
 * of specs, or directly content of pl7.app/trace from the input column spec.
 *
 * Basically validates and adds provided steps.
 */
makeTrace := func(input, ...steps) {
	// validating input step structure
	validation.assertType(steps, _TRACE_SCHEMA)

	currentTraceContent := undefined
	if is_string(input) {
		currentTraceContent = input
	} else if is_string(input[A_TRACE]) {
		currentTraceContent = input[A_TRACE]
	} else if is_string(input["annotations"][A_TRACE]) {
		currentTraceContent = input["annotations"][A_TRACE]
	}

	currentTrace := []
	if !is_undefined(currentTraceContent) {
		currentTrace = json.decode(currentTraceContent)
		// validating trace we just parsed
		validation.assertType(currentTrace, _TRACE_SCHEMA)
	}

	currentTrace = append(currentTrace, steps...)
	currentTraceStr := string(json.encode(currentTrace))

	return ll.toStrict({
		value: currentTrace,
		valueStr: currentTraceStr,
		/** Injects trace information into column spec */
		inject: func(spec) {
			validation.assertType(spec, P_COLUMN_SPEC_SCHEMA)
			return maps.deepMerge(spec, {annotations: {"pl7.app/trace": currentTraceStr}})
		}
	})
}

export ll.toStrict({
	KIND_P_COLUMN: KIND_P_COLUMN,

	N_LABEL: N_LABEL,

	D_BLOCK: D_BLOCK,

	A_LABEL: A_LABEL,
	A_TRACE: A_TRACE,

	tryMatchAxis: tryMatchAxis,
	matchAxis: matchAxis,
	matchAxes: matchAxes,

	makeTrace: makeTrace
})
