// pframes ll aggregate

self := import(":tpl")

ll := import(":ll")
render := import(":render")
smart := import(":smart")
constants := import(":pframes.constants")

json := import("json")

self.awaitState("InputsLocked")
self.awaitState("data", "InputsLocked")

self.body(func(inputs) {

    // parameters of aggragation
	//   indices: int[]
	//   eph: bool
    params := inputs.params
	indices := params.indices
	eph := params.eph

    // map of resources to aggregate over
    data := inputs.data

	// template implementing aggregation body
    body := inputs.body

	extraInputs := {}
	for name, field in inputs {
		if name != "params" && name != "data" && name != "body" {
			extraInputs[name] = field
		}
	}

	if data.checkResourceType(constants.RTYPE_P_COLUMN_DATA_RESOURCE_MAP) {
		meta := data.getDataAsJson()

		// calculating group indices
		groupIndices := []
		for i:=0; i<meta.keyLength; i++ {
			groupIndices = append(groupIndices, i)
		}
		for j:=len(indices)-1; j>=0; j-- {
			splice(groupIndices, indices[j], 1)
		}

		// group key -> group resource
		groups := {}

		for sKey, field in data.inputs() {
			key := json.decode(sKey)

			groupKey := []
			for i in groupIndices {
				groupKey = append(groupKey, key[i])
			}

			inGroupKey := []
			for i in indices {
				inGroupKey = append(inGroupKey, key[i])
			}

			sGroupKey := json.encode(groupKey)
			sInGroupKey := json.encode(inGroupKey)

			group := groups[sGroupKey]
			if is_undefined(group) {
				group = smart.structBuilder(
					constants.RTYPE_P_COLUMN_DATA_RESOURCE_MAP,
					json.encode({ keyLength: len(indices) })
				)
				groups[sGroupKey] = group
			}
			group.createInputField(sInGroupKey).set(field)
		}

		outputMap := smart.structBuilder(
			constants.RTYPE_P_COLUMN_DATA_RESOURCE_MAP,
			json.encode({ keyLength: len(groupIndices) })
		)

		for sGroupKey, group in groups {
			group = group.lockAndBuild()
			renderInputs := {}
			renderInputs[constants.KEY_FIELD_NAME] := json.decode(sGroupKey)
			renderInputs[constants.VALUE_FIELD_NAME] := group
			for name, field in extraInputs {
				renderInputs[name] := field
			}
			renderResult := render.createUniversal(body, eph, renderInputs)
			outputMap.createInputField(sGroupKey).set(renderResult.output(constants.RESULT_FIELD_NAME))
		}

		return {
			result: outputMap
		}
	} else {
		ll.panic("Unexpected input resource type: %v", data.info().Type)
	}
})
