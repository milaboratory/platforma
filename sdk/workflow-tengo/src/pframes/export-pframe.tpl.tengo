//
// wrap all p-frame files with file.exportFile
//


ll := import(":ll")
assets := import(":assets")
tpl := import(":tpl")
smart := import(":smart")
render := import(":render")
file := import(":file")
pConstants := import(":pframes.constants")
constants := import(":constants")
validation := import(":validation")

text := import("text")

// await all inputs are locked
tpl.awaitState("pf", { wildcard: "*" }, "InputsLocked")
tpl.awaitState("pf", { match: "\\.spec$" }, "ResourceReady")

// tpl.validateInputs({
// 	pf: { `any`: validation.resource() }
// })

eMulTpl := assets.importTemplate(":pframes.export-multiple-pcolumns")

tpl.body(func(inputs) {

	columns := {}

	getColumn := func(name) {
		c := columns[name]
		if is_undefined(c) {
			c = {}
			columns[name] = c
		}
		return c
	}

	pfResource := tpl.rawInputs().pf.getValue()

	// rawFields := pfResource.inputs()

	// if context is passed as an input we differently treat the field names (see below)
	isContext := pfResource.checkResourceType(constants.RTYPE_CONTEXT)

	for rawFieldName, fieldValue in pfResource.inputs() {
		fieldName := rawFieldName
		if isContext {
			if text.has_prefix(fieldName, "values/") {
				fieldName = fieldName[7:]
			} else if fieldName == "id" || fieldName == "parent" {
				// there are other fields in context resource, we are only interesetd in "values/..."
				continue
			} else {
				ll.panic("Unexpected context field: %v", fieldName)
			}
		}

		if text.has_suffix(fieldName, ".spec") {
			if !(fieldValue.getValue().checkResourceType(constants.RTYPE_JSON) || fieldValue.getValue().checkResourceType(constants.RTYPE_OBJECT_SPEC)) {
				ll.panic("Unexpected spec value type: %v", fieldValue.getValue().info().Type)
			}
			col := getColumn(fieldName[:len(fieldName) - 5])
			col.spec = fieldValue.getValue().getDataAsJson()
			col.specRaw = fieldValue
		} else if text.has_suffix(fieldName, ".data") {
			col := getColumn(fieldName[:len(fieldName) - 5])
			col.data = fieldValue
		} else {
			ll.panic("Unexpected field name: %v", fieldName)
		}
	}

	result := smart.structBuilder(pConstants.RTYPE_P_FRAME)

	// serves as an input to the export-pcolumn template
	eMulTplInput := smart.structBuilder(constants.RTYPE_MAP)
	// export-pcolumn export instance
	eMulTplRender := render.createEphemeral(eMulTpl, { data: eMulTplInput })

	for colName, col in columns {
		if is_undefined(col.spec) || (
		    col.spec.kind == "PColumn" && (
				is_undefined(col.spec.valueType) ||
				col.spec.valueType == "file" || col.spec.valueType == "blob" ||
				col.spec.valueType == "File" || col.spec.valueType == "Blob" ||
				col.spec.valueType == "Int" || col.spec.valueType == "Long" ||
				col.spec.valueType == "Float" || col.spec.valueType == "Double" ||
				col.spec.valueType == "String" || col.spec.valueType == "Bytes")) {
			if !is_undefined(col.spec) {
				result.createInputField(colName + ".spec").set(col.specRaw)
			}
			eMulTplInput.createInputField(colName).set(col.data)
			result.createInputField(colName + ".data").set(eMulTplRender.output(colName))
		} else if col.spec.kind == "File" {
			result.createInputField(colName + ".spec").set(col.specRaw)
			result.createInputField(colName + ".data").set(file.exportFile(col.data))
		} else {
			result.createInputField(colName + ".spec").set(col.specRaw)
			result.createInputField(colName + ".data").set(col.data)
		}
	}

	eMulTplInput.lockAndBuild()

	return {
		result: result.lockAndBuild()
	}
})
