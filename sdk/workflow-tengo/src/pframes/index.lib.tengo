/**
 * Working with p-frames
 */

ll := import(":ll")
maps := import(":maps")
smart := import(":smart")
slices := import(":slices")
assets := import(":assets")
render := import(":render")
builder := import(":pframes.builder")
pUtil := import(":pframes.util")
pSpec := import(":pframes.spec")
validation := import(":validation")

llProcessTpl := assets.importTemplate(":pframes.process-pcolumn-data")

/**
 * Given a reference to the p-frame, converts all inner resource files into resources that can be
 * downloaded from the UI side.
 */
exportFrame := func(pf) {
	return render.createEphemeral(assets.importTemplate(":pframes.export-pframe"), { pf: pf }).output("result")
}

/**
 * Export single PColumn data
 */
exportColumnData := func(data) {
	return render.createEphemeral(assets.importTemplate(":pframes.export-single-pcolumn"), { data: data }).output("result")
}

/**
 * Creates a builder for a resource map p-column's data.
 */
pColumnResourceMapDataBuilder := func(keyLength) {
	ll.panic("pframes.pColumnResourceMapDataBuilder is not supported any more; use pcolumn.resourceMapBuilder")
}

/**
 * Constructs a mapping or aggregation pipeline for a given input PColumn and returns a specialized
 * output object for accessing the processing results.
 *
 * === Body Template Contract ===
 *
 *   Inputs:
 *     "__key__"   - When passKey is true, contains the JSON representation of the group/element key:
 *                     - Without aggregation: represents a single key
 *                     - With aggregation: represents all keys in positions not specified by indices
 *                   Not provided if passKey is false or omitted from ops
 *     "__group_axes_spec__"
 *                 - When passGroupAxesSpec is true, contains the axes specification for aggregation
 *                     Can be used to adapt body behavior when optional aggregation axes are unmatched
 *                   Not provided if passGroupAxesSpec is false or omitted from ops
 *     "__value__" - Content depends on aggregation setting:
 *                     - Without aggregation: single value (only for ResourceMap PColumns)
 *                     - With aggregation: "PColumnData/*" resource containing all records in current group
 *     ...extra    - Additional values/references passed via the options.extra parameter
 *                   are forwarded to the template unchanged
 *
 * === Parameters ===
 *
 * @param input         Primary input column data and specifications
 *
 *                      Required structure:
 * 							{
 * 							 	// PColumn specifications (must be explicit, not a reference)
 * 							 	spec: <PColumnSpec>,
 *
 * 							 	// Reference to the data resource
 * 							 	data: <resource ref>
 *							}
 *
 * @param bodyTpl       Template executed for each iteration (see contract above)
 * @param isEphemeral   Whether to run mapping in ephemeral mode
 *
 * @param outputs 		Array of output configurations to collect from rendered templates
 *
 *                  Common fields for all types:
 *                     {
 *                       name:  string     // Output name
 *                       path?: string[]   // [Optional] Override path inside body template result
 *                                            First element interpreted as output name
 *                                            Defaults to [name] if omitted
 *                     }
 *
 *                  Available types:
 *                    | {
 *                        type: "Resource",     // Single resource output
 *                        spec: PColumnSpec     // Result column spec (must have zero axes specs,
 *                                              // input axes specs added automatically)
 *                      }
 *                    | {
 *                        type: "ResourceMap",  // ResourceMap output
 *                        spec: PColumnSpec     // Result column spec (list only axes specs
 *                                              // produced by body template, input axes added automatically)
 *                      }
 *                    | {
 *                        type: "BinaryPartitioned" | "JsonPartitioned",
 *                                              // Partitioned Json/Binary PColumn data
 *                        spec: PColumnSpec     // Result column spec (list only axes specs
 *                                              // produced by body template, input axes added automatically)
 *                        partitionKeyLength: number
 *                                              // Expected partition length per operation
 *                      }
 *                    | {
 *                        type: "Xsv",          // CSV/TSV formatted text file for xsv conversion
 *						  xsvType: "tsv"|"csv", // Expected file format
 *                        settings: object      // Xsv conversion specification
 *                      }
 *
 * @param opts 			Optional additional settings
 *
 *                    {
 *                      aggregate?: AxisMatcher[],
 *                                              // If specified, selected axes are combined and
 *                                              // passed to each iteration as a group. These axes
 *                                              // won't be automatically added to output specs
 *                                              // Examples:
 *                                              //   - "pl7.app/sequencing/readIndex"
 *                                              //   - { name: "pl7.app/sequencing/readIndex" }
 *                                              //   - { type: "String", name: "pl7.app/sequencing/lane" }
 *                                              //   - { type: "String", name: "pl7.app/sequencing/lane", optional: true }
 *                                              //   - { type: "String", name: "pl7.app/rna-seq/geneId", domain: { "pl7.app/species": "homo-sapiens" } }
 *                                              // With optional: true, matcher won't error if unmatched
 *                                              // Use passGroupAxesSpec for custom handling in body template
 *
 *                      passKey?: boolean       // Pass __key__ to body template if true
 *
 *                      passGroupAxesSpec?: boolean
 *                                              // Pass aggregation group specs to body template
 *                                              // via __group_axes_spec__ input
 *
 *                      extra?: Map<string, Ref>,
 *                                              // Additional parameters passed to each body invocation
 *                                              // Keys match template input names
 *                    }
 *
 * === Return ===
 *
 * @returns Object with methods for retrieving processing results
 *          See source code for method documentation and signatures
 */
processColumn := func(input, bodyTpl, isEphemeral, outputs, ...opts) {
	if len(opts) == 0 {
		opts = {}
	} else if len(opts) == 1 {
		opts = opts[0]
	} else {
		ll.panic("too many arguments")
	}

	validation.assertType(input.spec, pSpec.P_COLUMN_SPEC_SCHEMA)

	if is_undefined(opts.passKey) {
		opts.passKey = false
	}

	if is_undefined(opts.passGroupAxesSpec) {
		opts.passGroupAxesSpec = false
	}

	if opts.passGroupAxesSpec && is_undefined(opts.aggregate) {
		ll.panic("can't use passGroupAxesSpec without aggregate")
	}

	// JSON params passed as a single resource to the template
	processTemplateParams := {
		eph: isEphemeral,
		outputs: outputs,
		passKey: opts.passKey
	}

	extra := opts.extra
	if is_undefined(extra) {
		extra = {}
	}

	iterationAxesSpec := input.spec.axesSpec
	processTemplateParams.expectedKeyLength = len(input.spec.axesSpec)
	if !is_undefined(opts.aggregate) {
		aggregationIndices := pSpec.matchAxes(input.spec.axesSpec, opts.aggregate)
		processTemplateParams.aggregationIndices = aggregationIndices

		// calculate iteration axes spec
		groupAxesIndices := pUtil.calculateGroupAxesIndices(len(input.spec.axesSpec), aggregationIndices)
		processTemplateParams.expectedKeyLength = len(groupAxesIndices)
		iterationAxesSpec = []
		for i in groupAxesIndices {
			iterationAxesSpec = append(iterationAxesSpec, input.spec.axesSpec[i])
		}

		if opts.passGroupAxesSpec {
			aggregationAxesSpec := []
			for i in aggregationIndices {
				aggregationAxesSpec = append(aggregationAxesSpec, input.spec.axesSpec[i])
			}

			extra["__group_axes_spec__"] = smart.createJsonResource(aggregationAxesSpec)
		}
	}

	processedOutputs := []
	outputSpecs := {}
	for output in outputs {
		if output.type == "Resource" || output.type == "BinaryPartitioned" || output.type == "JsonPartitioned" {
			outputSpecs[output.name] = maps.merge(output.spec, { axesSpec: iterationAxesSpec + slices.normalize(output.spec.axesSpec) })
			processedOutputs.append(maps.merge(output, {spec: undefined })) // removing spec field
		} else if output.type == "ResourceMap" {
			processedOutputs.append(maps.merge(output,
				{ keyLength: len(output.spec.axesSpec), spec: undefined }))
			outputSpecs[output.name] = maps.merge(output.spec, { axesSpec: iterationAxesSpec + slices.normalize(output.spec.axesSpec) })
		} else if output.type == "Xsv" {
			decomposition := pUtil.decomposePfconvImportCfg(output.settings, {
				additionalAxesSpec: iterationAxesSpec
			})
			purifiedPfconvCfg := decomposition.purifiedCfg
			outputSpecs[output.name] = decomposition.columnsSpec
			processedOutputs.append(maps.merge(output,
				{ settings: purifiedPfconvCfg }))
		} else {
			ll.panic("unknown output type: " + output.type)
		}
	}

	renderInputs := {
		params: smart.createJsonResource(processTemplateParams),
		body: bodyTpl,
		data: input.data
	}

	for k, v in extra {
		renderInputs["__extra_" + k] = v
	}

	renderResult := render.createEphemeral(llProcessTpl, renderInputs)

	self := undefined
	self = ll.toStrict({
		renderResult: renderResult
	})

	return self
}

export ll.toStrict({
	// aggregationBuilder: aggregationBuilder,
	exportFrame: exportFrame,
	pFrameBuilder: builder.pFrameBuilder,
	exportColumnData: exportColumnData,
	pColumnResourceMapDataBuilder: pColumnResourceMapDataBuilder
})
