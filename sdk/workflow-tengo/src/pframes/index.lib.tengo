/**
 * Working with p-frames
 */

ll := import(":ll")
assets := import(":assets")
render := import(":render")
builder := import(":pframes.builder")

/**
 * Given a reference to the p-frame, converts all inner resource files into resources that can be
 * downloaded from the UI side.
 */
exportFrame := func(pf) {
	return render.createEphemeral(assets.importTemplate(":pframes.export-pframe"), { pf: pf }).output("result")
}

/**
 * Export single PColumn data
 */
exportColumnData := func(data) {
	return render.createEphemeral(assets.importTemplate(":pframes.export-single-pcolumn"), { data: data }).output("result")
}

/**
 * Creates a builder for a resource map p-column's data.
 */
pColumnResourceMapDataBuilder := func(keyLength) {
	ll.panic("pframes.pColumnResourceMapDataBuilder is not supported any more; use pcolumn.resourceMapBuilder")
}

/**
 * Construct a mapping or aggregation pipeline for a given input PColumn, and returns a special
 * output object that can be used to access processing results.
 *
 * === Contract for body template ===
 *
 *   Inputs:
 *     "__key__"   - if passKey == true, will be set to the json representation of the group / element key
 *                     - if aggregate option is not specified, key will be a key
 *                     - if aggregate option is specified, will represent all the keys
 *                       in all positions not specified in the indices parameter
 *                   if passKey == false or not present in ops, body template will not receive this input
 *     "__group_axes_spec__"
 *                 - if passGroupAxesSpec == true, will have axes spec for the aggregation
 *                     this input can be used to adjust body behaviour if some of the optional aggregation axes are not matched
 *                   if passGroupAxesSpec == false or not present in ops, body template will not receive this input
 *     "__value__" - depends on presence of the aggregate parameter
 *                     - if aggregate option is not specified, value (applicable only for input ResourceMap PColumns)
 *                     - if aggregate option is specified, a "PColumnData/*" resource with all the records in current group
 *     ...extra    - all values or references passed to extra section of options
 *                   will be forwarded to the template as is
 *
 * === Parameters ===
 *
 * @param input         main input column data and specs
 *
 *                      Parameter must have the following structure:
 * 							{
 * 							 	// specs of the input PColumn
 * 							 	spec: <explicit PColumnSpec, not resource reference>,
 *
 * 							 	// reference to the data resource
 * 							 	data: <resource ref>
 *							}
 *
 * @param bodyTpl       template to be executed for each iteration (see contract above)
 * @param isEphemeral   whether to run mapping in ephemeral or in non-ephemeral mode
 *
 * @param outputs 		array of output settings to to collect from rendered templates
 *
 *                  Common fields for all subtypes:
 *                     {
 *                       name:  string     - name of the output
 *                       path?: string[]   - [optional] overrides the path inside the body template
 *                                           result, first name is interpreted as output name. If
 *                                           not specified path equals to `[name]`.
 *                     }
 *
 *                  Variants:
 *                    | {
 *                        type: "Resource",     // - assume normal singular resource is produced by this output
 *                        spec: PColumnSpec     // - spec for the resulting column, must have zero axes specs,
 *                                              //   input axes specs will be added automatically
 *                      }
 *                    | {
 *                        type: "ResourceMap",  // - assume the output is ResourceMap
 *                        spec: PColumnSpec     // - spec for the resulting column, must list only those
 *                                              //   axes specs that are produced by the body template,
 *                                              //   input axes specs will be added automatically
 *                      }
 *                    | {
 *                        type: "BinaryPartitioned" | "JsonPartitioned",
 *                                              // - assume the output is a partitionded Json or Binary PColumn data itself
 *                        spec: PColumnSpec     // - spec for the resulting column, must list only those
 *                                              //   axes specs that are produced by the body template,
 *                                              //   input axes specs will be added automatically
 *                        partitionKeyLength: number
 *                                              // - expected partition length of result for each operation
 *                      }
 *                    | {
 *                        type: "Xsv",          // - assume the output is a csv or tsv formatted text file
 *                                              //   intended to be converted by the xsv conversion subsystem
 *						  xsvType: "tsv"|"csv", // - expected file format
 *                        settings: object      // - xsv conversion specification
 *                      }
 *
 * @param opts 			optional parameter with additional settings
 *
 *                    {
 *                      aggregate?: AxisMatcher[],
 *                                              // - if specified, selected axes will be combined and
 *                                                   passed to each iteration as a group, those axes will
 *                                                   not be automatically added to the output specs
 *                                                   Examples:
 *                                                     - "pl7.app/sequencing/readIndex"
 *                                                     - { name: "pl7.app/sequencing/readIndex" }
 *                                                     - { type: "String", name: "pl7.app/sequencing/lane" }
 *                                                     - { type: "String", name: "pl7.app/sequencing/lane", optional: true }
 *                                                     - { type: "String", name: "pl7.app/rna-seq/geneId", domain: { "pl7.app/species": "homo-sapiens" } }
 *                                                   If "optional" is set to true, corresponding matcher
 *                                                   will not invoke an error if not matched, use "passGroupAxesSpec"
 *                                                   option to implement different behaviour in body template
 *
 *                      passKey?: boolean        // - if true, __key__ will be passed to the body template
 *
 *                      passGroupAxesSpec?: boolean
 *                                              // - will pass resulting aggregation group specs to the
 *                                                   body template via the __group_axes_spec__ input
 *
 *                      extra?: Map<string, Ref>,
 *                                              // - map of any additional parameters to be passed to each
 *                                                   body invocation. Keys will match template input names.
 *                    }
 *
 * === Return ===
 *
 * @returns an object allowing to flexibly retrieve processing results, see sorce code for the list of
 *          methods, their docs and signatures
 */
// processColumn := func(input, bodyTpl, isEphemeral, outputs, ...opts) {
// 	if len(ops) == 0 {
// 		ops = {}
// 	} else if len(ops) == 1 {
// 		ops = ops[0]
// 	} else {
// 		ll.panic("too many arguments")
// 	}

// 	if is_undefined(ops.passKey) {
// 		ops.passKey = false
// 	}

// 	if is_undefined(ops.passGroupAxesSpec) {
// 		ops.passGroupAxesSpec = false
// 	}

// 	if ops.passGroupAxesSpec && !is_undefined(ops.aggregate) {
// 		ll.panic("can't use passGroupAxesSpec without aggregate")
// 	}



// 	isEphemeral := undefined

// 	self = ll.toStrict({
// 		body: func(commandName) {
// 			assertEntrypointNotSet()

// 			cmd = commandName
// 			entrypointSet = true
// 			return self
// 		},
// 	})

// 	return self
// }

export ll.toStrict({
	// aggregationBuilder: aggregationBuilder,
	exportFrame: exportFrame,
	pFrameBuilder: builder.pFrameBuilder,
	exportColumnData: exportColumnData,
	pColumnResourceMapDataBuilder: pColumnResourceMapDataBuilder
})
