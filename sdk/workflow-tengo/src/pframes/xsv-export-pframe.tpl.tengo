util := import(":pframes.util")
canonical := import(":canonical")
execConstants := import(":exec.constants")
pframesSpec := import(":pframes.spec")
slices := import(":slices")
pt := import(":pt")
ll := import(":ll")
maps := import(":maps")

self := import(":tpl.light")

self.defineOutputs(["result"])

self.body(func(inputs) {
    pf := inputs.pf
    xsvType := inputs.xsvType
    params := inputs.params

    queue := inputs.queue
    cpu := inputs.cpu
    mem := inputs.mem
    inputCache := inputs.inputCache
    
    resultFile := "result." + xsvType

	columnEntries := []
	rawColumns := []
	maps.forEach(util.pFrameToColumnsMap(pf), func(frameUniqueColumnId, columnInfo) {
		columnEntries = append(columnEntries, pt.p.column(frameUniqueColumnId, columnInfo))
		rawColumns = append(rawColumns, { id: frameUniqueColumnId, spec: columnInfo.spec })
	})

	frameInput := undefined
	if params.joinType == "Inner" {
		frameInput = pt.p.inner(columnEntries...)
	} else {
		frameInput = pt.p.full(columnEntries...)
	}

	numericSelector := pt.sc.numeric()
	if is_string(params.naStr) {
		numericSelector = numericSelector.fillNull(params.naStr)
	}
	stringSelector := pt.sc.string()
	if is_string(params.nullStr) {
		stringSelector = stringSelector.fillNull(params.nullStr)
	}

	labelsMap := {}
	getLabel := func(spec) {
		label := spec.annotations["pl7.app/label"]
		ll.assert(is_string(label) && label != "", "label must be a non-empty string, got %v", label)
		ll.assert(is_undefined(labelsMap[label]),
			"label '%s' is not unique, it is used for %v, and now %v",
			label, labelsMap[label], spec)
		labelsMap[label] = spec
		return label
	}

	specDistiller := pframesSpec.createSpecDistiller(slices.map(rawColumns, func(c) { return c.spec }))
	canonicalMap := {}
	uniqueAxes := []
	for column in rawColumns {
		for axis in column.spec.axesSpec {
			distilledAxis := specDistiller.distill(axis)
			canonicalizedAxisSpec := canonical.encode(distilledAxis)
			if is_undefined(canonicalMap[canonicalizedAxisSpec]) {
				canonicalMap[canonicalizedAxisSpec] = true
				distilledAxis.label = getLabel(axis)
				uniqueAxes = append(uniqueAxes, distilledAxis)
			}
		}
	}

	columnSelectors := []
	sortSelectors := []
	for axis in uniqueAxes {
		label := axis.label
		delete(axis, "label")
		columnSelectors = append(columnSelectors, pt.sc.axis(axis).alias(label))
		sortSelectors = append(sortSelectors, pt.sc.byName(label))
	}
	for column in rawColumns {
		label := getLabel(column.spec)
		columnSelectors = append(columnSelectors, pt.col(column.id).alias(label))
	}

	wf := pt.workflow()
	if queue == execConstants.LIGHT_QUEUE {
		wf.inLightQueue()
	} else if queue == execConstants.MEDIUM_QUEUE {
		wf.inMediumQueue()
	} else if queue == execConstants.HEAVY_QUEUE {
		wf.inHeavyQueue()
	} else if queue == execConstants.UI_TASKS_QUEUE {
		wf.inUiQueue()
	} else if !is_undefined(queue) {
		ll.panic("Unsupported queue: %v", queue)
	}
	if !is_undefined(cpu) {
		wf.cpu(cpu)
	}
	if !is_undefined(mem) {
		wf.mem(mem)
	}
	if !is_undefined(inputCache) {
		wf.cacheInputs(inputCache)
	}
	wf.frame(frameInput).
		select(numericSelector, stringSelector).
		select(columnSelectors...).
		sort(sortSelectors, {
			descending: false,
			nulls_last: false
		}).
		save(resultFile)

	result := wf.run()
    return {
        result: result.getFile(resultFile)
    }
})
