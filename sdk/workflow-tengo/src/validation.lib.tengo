ll := import(":ll")
sets := import(":sets")
fmt := import("fmt")
text := import("text")
maps := import(":maps")
enum := import("enum")
smart := import(":smart")

//
// Tools for implementing your own checks:
//

/**
 * Validation success result.
 */
success := { result: true }

/**
 * Validation failure result with a message.
 *
 * @param stack: any - the current stack state.
 * @param msg: string - the failure message.
 * @param args: ...any - additional arguments for the message.
 */
fail := func(stack, msg, ...args) {
	if is_undefined(args) || len(args) == 0 {
		args = []
	}
	args = append(args, stack)

	return {
		result: false,
		message: fmt.sprintf(msg + ", previous elements: %#v", args...)
	}
}

/**
 * Returns true if the validation failed.
 *
 * @param r: either fail or success.
 */
isFail := func(r) {
	return r.result == false
}

/**
 * Checks a condition and returns success or failure.
 *
 * @param condition: bool - the condition to check.
 * @param stack: any - the current stack state.
 * @param msg: string - the failure message if the condition is false.
 * @param args: variadic any - additional arguments for the message.
 */
check := func(condition, stack, msg, ...args) {
	if condition {
		return success
	}

	return fail(stack, msg, args...)
}

//
// Validation:
//

/**
 * Validates JSON types based on tags when the scheme is a string.
 *
 * @param js: any - the JSON to validate.
 * @param tags: { key: string, tags: []tag } - the tags to validate against.
 * @param stack: ...any - the current stack state.
 */
_validateTypes := func(js, tags, ...stack) {
	if tags.key == "any" {
		return
	}

	// split keys "or"
	keys := sets.fromSlice(text.split(tags.key, "|"))
	for k, _ in keys {
		if k == "alphanumeric" && ((is_string(js) && text.re_match("^[[:alnum:]]*$", js)) || is_int(js)) {
			return success
		}

		if k == "string" && is_string(js) {
			regex := tags.tags["regex"]
			if !is_undefined(regex) && !text.re_match(regex, js) {
				return fail(stack, stack, "value %q does not conform regex %q", js, regex)
			}

			return success
		}

		if k == "char" && is_char(js) {
			return success
		}

		if k == "bytes" && is_bytes(js) {
			return success
		}

		if k == "null" && is_undefined(js) {
			return success
		}

		if k == "number" && (is_int(js) || is_float(js)) {
			return success
		}

		if k == "bool" && is_bool(js) {
			return success
		}
	}

	return fail("js %q is not one of a type: %s", js, keys)
}

/**
 * Parses JSON tags from a string rule.
 *
 * @param rule: string - a key with tags, e.g. "any,type=string,regex=abc.*"
 * @return parsedRule: { key: string, tags: map } - the key and tags parsed from the rule.
 */
_parseTags := func(rule) {
	tagsKV := text.split(rule, ",")
	key := tagsKV[0]
	tagsKV = tagsKV[1:]

	tags := {}
	for _, kv in tagsKV {
		kAndV := text.split(kv, "=")
		k := kAndV[0]
		if len(kAndV) == 1 {
			tags[k] = true
		} else {
			tags[k] = kAndV[1]
		}
	}

	return ll.toStrict({
		key: key,
		tags: tags
	})
}

/**
 * Validates JSON against a scheme.
 *
 * @param js: any - the JSON to validate.
 * @param scheme: any - the scheme to validate against.
 * @param stack: ...any - the current stack state.
 * @return either fail or success
 */
_validateJson := func(js, scheme, ...stack) {
	// ll.print("validateJSON debug: json: ", js, "_______________ scheme: ", scheme)

	if is_undefined(scheme) {
		return fail(stack, "scheme is somehow undefined: %#v, previous elements: %#v", js, stack)
	}

	// if the scheme is a string, then
	// we check the predefined type. The type of the json
	// can be any of the union, e.g. "string|number|null".
	// We can add custom types here, e.g. "email|ipv6|number"
	if is_string(scheme) {
		if scheme == "any" {
			return success
		}
		tags := _parseTags(scheme)

		return _validateTypes(js, tags, stack...)
	}

	// if the scheme is a function, call it
	// with the element and the path of how we
	// got this element, i.e. recursion history.
	if is_callable(scheme) {
		return scheme(js, stack)
	}

	// if the scheme is an array, then check that every
	// element of the json has the scheme that is the first element
	// of the scheme.
	if is_array(scheme) {
		if !is_array(js) {
			return fail(stack, "js %q must be array", js)
		}

		scheme = scheme[0]
		for _, elem in js {
			r := _validateJson(elem, scheme, js, stack...)
			if isFail(r) {
				return r
			}
		}

		return success
	}

	// only map left, since scheme can't be undefined
	// if the scheme is a map, check that every key
	// in json-object is in the scheme and vice-versa,
	// unless there are tags "any" or "omitempty".
	if !ll.isMap(js) {
		return fail(stack, "js %#v must be map", js)
	}

	// scheme.key -> tags
	schemeTags := {}
	// scheme.key -> rule
	schemeRules := {}

	for k, v in scheme {
		p := _parseTags(k)
		schemeTags[p.key] = p
		schemeRules[p.key] = v
	}

	// tags that should be applied to all elements
	any := schemeTags["any"]

	options := schemeTags["__options__"]
	if is_undefined(options) {
		options = {}
	}

	for _key, elem in js {
		if any {
			r := _validateJson(elem, schemeRules["any"], stack...)
			if isFail(r) {
				return r
			}

			if !is_undefined(any.tags["type"]) {
				r := _validateJson(_key, any.tags["type"], stack...)
				if isFail(r) {
					return r
				}
			}

			continue
		}

		// tags for the key
		key := schemeTags[_key]

		if is_undefined(key) && options.tags["closed"] == true {
			return fail(stack, "only keys %v from the scheme must be set, found %q", maps.getKeys(scheme), _key)
		}

		if key.tags["type"] {
			r := _validateJson(_key, key.tags["type"], js, stack...)
			if isFail(r) {
				return r
			}
		}

		if key.tags["omitempty"] && is_undefined(elem) {
			continue
		}

		r := _validateJson(elem, schemeRules[_key], js, stack...)
		if isFail(r) {
			return r
		}
	}

	return success
}

/**
 * Checks if the given JSON conforms to the given scheme.
 *
 * @param js: any - the JSON to check.
 * @param scheme: any - the scheme to check against.
 * @return either fail or success
 */
checkJson := func(js, scheme) {
	return _validateJson(js, scheme)
}

/**
 * Checks if the given JSON is valid according to the given scheme.
 *
 * @param js: any - the JSON to check.
 * @param scheme: any - the scheme to check against.
 * @return result: bool - the result of the validation (true/false).
 */
isValid := func(js, scheme) {
	return _validateJson(js, scheme).result
}

/**
 * Asserts that a given JSON conforms to a given scheme.
 *
 * @param js: any - the JSON to assert.
 * @param scheme: any - the scheme to assert against.
 */
assertJsonSchema := func(js, scheme) {
	r := _validateJson(js, scheme)
	if isFail(r) {
		ll.panic("not a valid json: %s", r.message)
	}
}

//
// Domain-specific schemes and checks:
//

/**
 * Checks if the given element is a resource.
 *
 * @param elem: any - the element to check.
 * @param stack: any - the current stack state.
 */
resource := func(elem, stack) {
	return check(smart.isResource(elem), stack, "the element " + elem + " must be a resource")
}

/**
 * Checks if the given element is a reference.
 *
 * @param elem: any - the element to check.
 * @param stack: any - the current stack state.
 */
reference := func(elem, stack) {
	return check(smart.isReference(elem), stack, "the element " + elem + " must be a resource or a field")
}

export ll.toStrict({
	success: success,
	fail: fail,
	checkJson: checkJson,
	isValid: isValid,
	assertJsonSchema: assertJsonSchema,
	resource: resource,
	reference: reference
})
