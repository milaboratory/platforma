// helper template to save files in a working dir by regex

self := import(":tpl")
text := import("text")
json := import("json")
ll := import(":ll")
smart := import(":smart")
constants := import(":constants")



/**
 * Generates a file save rule for a given file name.
 *
 * @param fileName: string - the name of the file.
 * @return rule: map - the file save rule.
 */
_getFileSaveRule := func(fileName) {
	return {
		blobKey: fileName,
		type: "file",
		filePath: fileName
	}
}

/**
 * Generates a value save rule for a given file name.
 *
 * @param fileName: string - the name of the file.
 * @return rule: map - the value save rule.
 */
_getContentSaveRule := func(fileName) {
	return {
		blobKey: fileName,
		type: "content",
		contentPath: fileName
	}
}

self.body(func(inputs) {

	workdir := inputs.workdir
	
	// simple 'save' rules
	files := inputs.files
	filesContent := inputs.filesContent
	
	// regex 'save' rules
	fileSets := inputs.fileSets
	fileSetsContent := inputs.fileSetsContent

	// file & content save rules; using maps to avoid duplicated rules
	fRules := {}
	cRules := {}

	for file, _ in files {
		fRules[file] = _getFileSaveRule(file)
	}
	for content, _ in filesContent {
		cRules[content] = _getContentSaveRule(content)
	}
	
	// calculate actual file sets:
	// 
	//    name -> list of files
	//
	fileSetsMatch := {}
	fileSetsContentMatch := {}

	if len(fileSets) > 0 || len(fileSetsContent) > 0 {
		for k, _ in fileSets {
			fileSetsMatch[k] = []
		}

		for k, _ in fileSetsContent {
			fileSetsContentMatch[k] = []
		}

		files := workdir.getDataAsJson()["files"]

		for name in files {	
			for fSetName, regex in fileSets {
				if text.re_match(regex, name) {
					fileSetsMatch[fSetName] = append(fileSetsMatch[fSetName], name)
				}
			}

			for fSetName, regex in fileSetsContent {
				if text.re_match(regex, name) {
					fileSetsContentMatch[fSetName] = append(fileSetsContentMatch[fSetName], name)
				}
			}
		}

		for _, list in fileSetsMatch {
			for file in list {
				fRules[file] = _getFileSaveRule(file)
			}
		}

		for _, list in fileSetsContentMatch {
			for file in list {
				cRules[file] = _getContentSaveRule(file)
			}
		}
	}

	rules := []
	for _, r in fRules {
		rules = append(rules, r)
	}
	for _, r in cRules {
		rules = append(rules, r)
	}
	
	rulesRes := smart.createValueResource(
		constants.RTYPE_WORKDIR_SAVE_RULES,
		json.encode(rules)
	)

	wd := smart.ephemeralBuilder(constants.RTYPE_WORKDIR_SAVE)
	wd.getField("workdirIn").set(workdir)
	wd.getField("rules").set(rulesRes)
	wd = wd.lockAndBuild()

	filesResult := wd.getField("blobsOut")
	filesContentResult := wd.getField("dataOut")

	fileSetsResult := {}
	for fSetName, list in fileSetsMatch {
		r := {}
		for f in list {
			r[f] = filesResult.getFutureInputField(f)
		}
		fileSetsResult[fSetName] = r
	}
	fileSetsContentResult := {}
	for fSetName, list in fileSetsContentMatch {
		r := {}
		for f in list {
			r[f] = filesContentResult.getFutureInputField(f)
		}
		fileSetsContentResult[fSetName] = r
	}

	return {
		files           : filesResult,
		filesContent    : filesContentResult,
		fileSets        : fileSetsResult,
		fileSetsContent : fileSetsContentResult,
		workdir         : wd.getField("workdirOut"),
		progress        : wd.getField("progress")
	}
})