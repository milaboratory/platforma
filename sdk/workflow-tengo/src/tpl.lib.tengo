/*
 * Library provides development kit for pure templates
 */

tx := import("tx")
ll := import(":ll")

constants := import(":constants")
tplutil := import(":tpl-util")
smart := import(":smart")
sets := import(":sets")
maps := import(":maps")

//
// Initialization
//

// Checking we were imported in compatible render template context
renderer := smart.resourceBuilder(ll.getCurrentTemplateRenderer())
if renderer.info().Type.Name != constants.RTYPE_RENDER_TEMPLATE.Name {
	ll.panic("pure template can't be executed as ephemeral")
}

//
// Definitions and exports
//

// This map accumulated output definitions
_definedOutputs := []

/**
 * Defines current template output(s) names.
 *
 * All outputs must be defined before the template body, and only registered outputs can be used
 * inside.
 */
defineOutputs := func(...name) {
	if len(name) == 1 && is_array(name[0]) {
		for v in name[0] {
			_definedOutputs = append(_definedOutputs, v)
		}
	} else {
		_definedOutputs = append(_definedOutputs, name...)
	}
}

_inputs := undefined

inputs := func() {
	if _inputs == undefined {
		_inputs = ll.toStrict(renderer.get("inputs").inputs())
	}
	return _inputs
}

/**
 * Defines main entry point for current template
 */
body := func(bodyFn) {
	// Checks
	if len(_definedOutputs) == 0 {
		ll.panic("please define outputs before template body")
	}

	//
	// Rules of pl guarantees that pure template code will be executed twice:
	//
	//   (1) once for initialization, at this point it must initialize all outputs, for the
	//       deduplication and recovery mechanisms to pick them up and, if possible, populate them
	//       with results from equvalent previous invocations
	//
	//   (2) after initialization is done and all deduplication and recovery algorithms did their
	//       magic, if some (or all) of the outputs, our consumers demand are still absent, main
	//       body of the template is executed, to calculate them
	//

	if ll.isInitializing() {
		// Initialization
		for _, name in _definedOutputs {
			renderer.createOutputField(tplutil.TEMPLATE_OUTPUT_PREFIX + name)
		}
		renderer.lockOutputs()
	} else {
		// run body func
		result := bodyFn(inputs())

		ll.assert(ll.isMap(result),
			"expected map from tpl.body() callback. Did you forget 'return' statement?")

		ll.assert(sets.fromSlice(_definedOutputs) == sets.fromMapKeys(result),
			"not all defined outputs were returned from tpl.body() callback. Want ", _definedOutputs, ", got ", maps.getKeys(result))

		// set result to renderer outputs
		tplutil.setOutputs(renderer, result)
	}
}

export ll.toStrict({
	renderer: renderer,
	defineOutputs: defineOutputs,
	body: body,
	inputs: inputs
})
