/* A library exposing template functional components */

tx := import("tx")
ll := import(":ll")
render := import(":render")
smart := import(":smart")
sets := import(":sets")
maps := import(":maps")
tplutil := import(":tpl-util")
constants := import(":constants")

/**
 * Unmarshal resource according by:
 *  - converting all json resources (potentially nested) into a tengo objects (maps)
 *  - converting all pl.maps (resource maps) into tengo maps
 *
 * @param resource: smart resource to unmarshal
 * @param preprocessors: input preprocessors
 * @return object: unmarshaled resource
 */
_unmarshal := func(resource, preprocessors) {
	ll.assert(smart.isResource(resource), "expected resource, found ", resource)

	// instance of this
	self := func(resource) { return _unmarshal(resource, preprocessors) }

	// try preprocessors first
	for preproc in preprocessors {
		if preproc.canParse(resource) {
			return preproc.parse(resource, self)
		}
	}

	if smart.isJsonResource(resource) {

		// parse json data of the resource
		return resource.getDataAsJson()
	} else if smart.isMapResource(resource) {

		// unmarshal map
		result := {}
		for field, value in resource.inputs() {
			result[field] = _unmarshal(value.getValue(), preprocessors)
		}
		return result
	} else {
		// nothing todo
		return resource
	}
}

/**
 * A wrapper object around template functionality
 */
tpl := func() {
	self := undefined

	_renderer := smart.resourceBuilder(ll.getCurrentTemplateRenderer())

	_rendererType :=  _renderer.info().Type

	_isEphemeral := _rendererType.Name == constants.RTYPE_RENDER_EPH_TEMPLATE.Name

	_hasPrepared := _renderer.get(tplutil.INPUTS_MAP_FIELD).hasField(tplutil.PREPARE_MAP_FIELD_NAME)

	_preparedMap := _hasPrepared ? _renderer.get(tplutil.INPUTS_MAP_FIELD).get(tplutil.PREPARE_MAP_FIELD_NAME) : undefined

	_templateId := _renderer.get(tplutil.TEMPLATE_FIELD).id

	self = {

		/**
		 * Current renderer smart resource
		 */
		renderer: func() {
			return _renderer
		},

		/**
		 * Whether this template is ephemeral (rendered by ephemeral template router)
		 */
		isEphemeral: func() {
			return _isEphemeral
		},

		/**
		 * The template id of this template
		 */
		templateId: func() {
			return _templateId
		},

		_unmarshallers: [],

		/**
		 * Register a preprocessor of input resource. The preprocessor must have two
		 * methods: `canParse(resource)` (bool) and `parse(resource)` (object). Registered
		 * preprocessors will be used when unmarshaling resources.
		 */
		registerUnmarshaller: func(preproc) {
			ll.assert(is_undefined(self._inputs), "input preprocessors must be registered before getting inputs")
			self._unmarshallers = append(self._unmarshallers, preproc)
		},

		/**
		 * @return map[string]field: - a map of inputs to the fields of the input map.
		 */
		rawInputs: func() {
			return self.renderer().get(tplutil.INPUTS_MAP_FIELD).inputs()
		},

		_inputs: undefined,

		/**
		 * @return map: a map of the template inputs
		 */
		inputs: func() {
			if self._inputs == undefined {
				inputs := _unmarshal(self.renderer().get(tplutil.INPUTS_MAP_FIELD), self._unmarshallers)

				// if we have prepared inputs, flatten them
				pp := inputs[tplutil.PREPARE_MAP_FIELD_NAME]
				if !is_undefined(pp) {
					delete(inputs, tplutil.PREPARE_MAP_FIELD_NAME)
					for k, v in pp {
						ll.assert(is_undefined(inputs[k]), k, " key already exists in inputs map")
						inputs[k] = v
					}
				}

				self._inputs = inputs
			}
			return self._inputs
		},

		/**
		 * @return bool: whether there is input with a given name
		 */
		hasInput: func(name) {
			return self.renderer().get(tplutil.INPUTS_MAP_FIELD).hasField(name)
		},

		// accumulated output definitions
		definedOutputs : [],

		/**
		 * Defines current template output(s) names.
		 *
		 * For pure templates, all outputs must be defined before the template body, and only registered outputs can be used
		 * inside. Optional for ephemeral templates.
		 */
		defineOutputs : func(...name) {
			if len(name) == 1 && is_array(name[0]) {
				for v in name[0] {
					self.definedOutputs = append(self.definedOutputs, v)
				}
			} else {
				self.definedOutputs = append(self.definedOutputs, name...)
			}
		},

		/**
		 * True means we are in the inner render cycle, when all "to be prepared" fields are passed
		 * already to inputs and no need to call prepare callbacks again.
		 */
		ignorePrepare: _hasPrepared,

		/**
		 * Resource map with the resources passed
		 */
		preparedMapResource: func() {
			return _preparedMap
		},

		/**
		 * A queue of 'prepare' callbacks
		 */
		prepareQueue : [],

		/**
		 * Prepare additional resources for the template body. The body function of the workflow will be executed only when the references will be
		 * returned by the prepare method will be resolved into a ready resources. The resulting resources will be passed as an input to the body function.
		 *
		 * @param cb: a callback function returning a map of references to be resolved
		 */
		prepare : func(codeFn) {
			if self.ignorePrepare {
				return
			}

			ll.assert(len(self.prepareQueue) == 0, "multiple prepare statements are not supported yet")

			self.prepareQueue = append(self.prepareQueue, codeFn)
		},

		/**
		 * Creates renderer which is re-rendering the current template additionally passing
		 * resolve references as extra inputs.
		 */
		renderPrepare: func() {
			ll.assert(!self.ignorePrepare, "expected !ignorePrepare")

			inputs := self.inputs()

			// create new inputs map
			newInputs := copy(inputs)

			// build a prepare map
			builder := undefined
			if self.isEphemeral() {
				builder = smart.ephemeralMapBuilder()
			} else {
				builder = smart.mapBuilder()
			}
			
			for cb in self.prepareQueue {
				// run callback
				r := cb(inputs)

				ll.assert(is_map(r), "expected map, got ", r)

				for name, ref in r {
					ll.assert(smart.isReference(ref), "expected reference, got ", ref)
					ll.assert(is_undefined(newInputs[name]), "prepare name is already in use: ", name)

					builder.add(name, ref)
				}
			}
			newInputs[tplutil.PREPARE_MAP_FIELD_NAME] = builder.build()

			// re-render self
			renderer := undefined
			if self.isEphemeral() {
				renderer = render.createEphemeral(self.templateId(), newInputs)
			} else {
				renderer = render.create(self.templateId(), newInputs)
			}
			// set outputs
			for output in self.definedOutputs {
				self.getOutputField(output).set(renderer.output(output))
			}
		},

		/**
		 * Sets results map to resource output fields. Non-resource objects in the result values
		 * will be automatically converted into Json resources.
		 */
		setOutputs : func(resultMap) {
			ll.assert(ll.isMap(resultMap), "expected map, got ", resultMap)

			// set outputs
			for name, value in resultMap {
				f := self.getOutputField(name)
				if !f.isSet() {
					f.setRefOrJson(value)
				}
			}
		},

		/**
		 * Returns renderer's output field with a given name
		 */
		getOutputField: func(name) {
			return self.renderer().getField(tplutil.TEMPLATE_OUTPUT_PREFIX + name)
		},

		/**
		 * Creates relevant output fields and locks renderer's outputs
		 */
		createOutputsAndLock: func(outputs) {
			for name in outputs {
				self.renderer().createOutputField(tplutil.TEMPLATE_OUTPUT_PREFIX + name)
			}
			self.renderer().lockOutputs()
		},

		/**
		 * Routes template.
		 */
		body: func(bodyFn){
			if self.isEphemeral() {

				self.routeEph(bodyFn)
			} else {

				self.routePure(bodyFn)
			}
		},

		/**
		 * Routes pure template.
		 */
		routePure: func(bodyFn){
			// Checks
			if len(self.definedOutputs) == 0 {
				ll.panic("please define outputs before template body")
			}

			//
			// Rules of pl guarantees that pure template code will be executed twice:
			//
			//   (1) once for initialization, at this point it must initialize all outputs, for the
			//       deduplication and recovery mechanisms to pick them up and, if possible, populate them
			//       with results from equivalent previous invocations
			//
			//   (2) after initialization is done and all deduplication and recovery algorithms did their
			//       magic, if some (or all) of the outputs, our consumers demand are still absent, main
			//       body of the template is executed, to calculate them
			//

			if ll.isInitializing() {

				// Initialization
				self.createOutputsAndLock(self.definedOutputs)
			} else {

				// processing resolves
				if len(self.prepareQueue) != 0 {

					// re-render self to
					self.renderPrepare()
				} else {
					// run body func
					result := bodyFn(self.inputs())

					ll.assert(ll.isMap(result),
						"expected map from tpl.body() callback. Did you forget 'return' statement?")

					ll.assert(sets.fromSlice(self.definedOutputs) == sets.fromMapKeys(result),
						"not all defined outputs were returned from tpl.body() callback. Want ", self.definedOutputs, ", got ", maps.getKeys(result))

					// set result to self outputs
					self.setOutputs(result)
				}
			}
		},

		/**
		 * Routes ephemeral template.
		 */
		routeEph: func(bodyFn){
			if self.renderer().info().AllInputsSet {

				// get map resource storing template inputs
				inputMap := self.renderer().get(tplutil.INPUTS_MAP_FIELD)

				if inputMap.info().AllInputsSet {

					if len(self.prepareQueue) > 0 {
						ll.assert(len(self.definedOutputs) > 0, "outputs should be defined prior to prepare")

						self.createOutputsAndLock(self.definedOutputs)

						self.renderPrepare()
					} else {

						// if we have prepared map resource, we need to await for its readiness
						pp := self.preparedMapResource()
						if !is_undefined(pp) {
							if !pp.isReady() {
								tx.subscribeTo(pp.id, "PrepareIsReady", { "ResourceReady": true })
								return
							}
						}

						// run body func
						result := bodyFn(self.inputs())
						ll.assert(ll.isMap(result),
							"expected map from tpl-eph.body() callback. Did you forget 'return' statement?")

						self.createOutputsAndLock(maps.getKeys(result))

						// set result to self outputs
						self.setOutputs(result)
					}
				} else {
					// wait until inputs map is ready
					tx.subscribeTo(inputMap.id, "InputMapAllInputsSet", { "AllInputsSet": true })
				}
			} else if ll.isInitializing() {
				// wait until inputs map is ready
				tx.subscribeTo(self.renderer().id, "MainAllInputsSet", { "AllInputsSet": true })
			}
		},

		/**
		 * Delegates itself to the specified template, i.e. runs specified template and
		 * saves its outputs to this.
		 *
		 * @param tpl: template - specified template
		 * @param extraInputs: map - additional inputs to pass to the template
		 * @param outputs: array - array of expected outputs to save
		 */
		routeDelegate: func(tpl, extraInputs, outputs) {
			inputs := self.rawInputs()
			for k, v in extraInputs {
				inputs[k] = v
			}

			renderer := undefined
			if self.isEphemeral() {
				renderer = render.createEphemeral(tpl, inputs)
			} else {
				renderer = render.create(tpl, inputs)
			}

			tplOutputs := {}
			for o in outputs {
				tplOutputs[o] = renderer.output(o)
			}

			self.createOutputsAndLock(outputs)
			self.setOutputs(tplOutputs)
		}
	}
	return ll.toStrict(self)
}

/**
 * Singleton instance of this resource
 */
instance := tpl()

export ll.toStrict({
	renderer                : instance.renderer,
	registerUnmarshaller    : instance.registerUnmarshaller,
	rawInputs               : instance.rawInputs,
	hasInput                : instance.hasInput,
	inputs                  : instance.inputs,
	defineOutputs           : instance.defineOutputs,
	prepare                 : instance.prepare,
	delegate                : instance.routeDelegate,
	body                    : instance.body
})
