ll := import(":ll")
constants := import(":pframes.constants")
spec := import(":pframes.spec")
validation := import(":validation")
slices := import(":slices")
canonical := import(":canonical")

_AXIS_SCHEMA := {
	// Column reference in DataFrame
	`column`: `string`,
	// Specification of the axis
	`spec`: spec.P_AXIS_SPEC_SCHEMA
}

_COLUMN_SCHEMA := {
	// Column reference in DataFrame
	`column`: `string`,
	// Specification of the column
	`spec`: spec.P_COLUMN_OWN_SPEC_SCHEMA
}

_SAVE_FRAME_DIRECT_PARAMS_SCHEMA := {
	// DataFrame columns to use as PColumn axes, order of axes in resulting columns
	// would match the order of spec entries provided here
	`axes`: [_AXIS_SCHEMA],
	// DataFrame columns to use as PColumn values, each exported individually
	`columns`: [_COLUMN_SCHEMA],
	// Partitioning key length
	// default: 0
	`partitionKeyLength,?` : `number`,
    // Whether to fail if there is a NULL value in axis
    // default: false (do not fail, silently filter-out NULLs)
    `strict,?` : `bool`
}

validateParamsForSaveFrameDirect := func(params) {
	validation.assertType(params, _SAVE_FRAME_DIRECT_PARAMS_SCHEMA, "Invalid params structure")

    columns := {}
    ll.assert(len(params.axes) > 0, "At least one axis is required")
    for entry in params.axes {
        if !is_undefined(columns[entry.column]) {
            ll.assert(false, "Column (%s) used more then once which is prohibited", entry.column)
        }
        columns[entry.column] = 1
        if !is_undefined(entry.spec.parentAxes) && len(entry.spec.parentAxes) > 0 {
            for index in entry.spec.parentAxes {
                ll.assert(
                    index < len(params.axes),
                    "Axis parent (%d) must be strictly less than the number of axes (%d)",
                    index,
                    len(params.axes)
                )
            }
        }
    }
    ll.assert(len(params.columns) > 0, "At least one column is required")
    for entry in params.columns {
        if !is_undefined(columns[entry.column]) {
            ll.assert(false, "Column (%s) used more then once which is prohibited", entry.column)
        }
        columns[entry.column] = 1
        if !is_undefined(entry.spec.parentAxes) && len(entry.spec.parentAxes) > 0 {
            for index in entry.spec.parentAxes {
                ll.assert(
                    index < len(params.axes),
                    "Column parent (%d) must be strictly less than the number of axes (%d)",
                    index,
                    len(params.axes)
                )
            }
        }
    }

    // Check that partitionKeyLength is strictly less than the number of axes
    ll.assert(
        params.partitionKeyLength == undefined ||
            (params.partitionKeyLength >= 0 && params.partitionKeyLength < len(params.axes)),
        "partitionKeyLength (%d) must be strictly less than the number of axes (%d)",
        params.partitionKeyLength,
        len(params.axes)
    )
}

_FRAME_FROM_COLUMN_BUNDLE_PARAMS_SCHEMA := {
	// DataFrame axes definitions
	`axes,?`: [_AXIS_SCHEMA],
    // ColumnBundle column names to include in the resulting DataFrame
	`columns,?`: [`string`]
}

validateParamsForFrameFromColumnBundle := func(params) {
	validation.assertType(params, _FRAME_FROM_COLUMN_BUNDLE_PARAMS_SCHEMA, "Invalid params structure")
}

makeFrameSpecs := func(params) {
	axes := []
    for entry in params.axes {
        spec := {
            type: entry.spec.type,
            name: entry.spec.name
        }
        if !is_undefined(entry.spec.domain) && len(entry.spec.domain) > 0 {
            spec.domain = entry.spec.domain
        }
        if !is_undefined(entry.spec.annotations) && len(entry.spec.annotations) > 0 {
            spec.annotations = entry.spec.annotations
        }
        if !is_undefined(entry.spec.parentAxes) && len(entry.spec.parentAxes) > 0 {
            spec.parentAxes = slices.sortUnique(entry.spec.parentAxes)
        }
        axes = append(axes, spec)
    }
    columns := {}
    for entry in params.columns {
        spec := {
            kind: constants.KIND_P_COLUMN,
            axesSpec: axes,
            valueType: entry.spec.valueType,
            name: entry.spec.name
        }
        if !is_undefined(entry.spec.domain) && len(entry.spec.domain) > 0 {
            spec.domain = entry.spec.domain
        }
        if !is_undefined(entry.spec.annotations) && len(entry.spec.annotations) > 0 {
            spec.annotations = entry.spec.annotations
        }
        if !is_undefined(entry.spec.parentAxes) && len(entry.spec.parentAxes) > 0 {
            spec.parentAxes = slices.sortUnique(entry.spec.parentAxes)
        }
        columns[entry.column] = spec
    }
    return columns
}

makeWriteFrameStep := func(frameName, dfName, params) {
	step := {
        type: "write_frame",
        inputTable: dfName,
        frameName: frameName,
        axes: slices.map(params.axes, func(entry) {
            return {
                column: entry.column,
                type: entry.spec.type
            }
        }),
        columns: slices.map(params.columns, func(entry) {
            return {
                column: entry.column,
                type: entry.spec.valueType
            }
        }),
        partitionKeyLength: 0,
        strict: false
    }
    if !is_undefined(params.partitionKeyLength) {
        step.partitionKeyLength = params.partitionKeyLength
    }
    if !is_undefined(params.strict) {
        step.strict = params.strict
    }
    return step
}

makeFrameColumnRef := func(frameName, columnId) {
	return canonical.encode({
		frame: frameName,
		columnId: columnId
	})
}

_AXIS_FILTER_SCHEMA := {
	// Axis index
	`axisIndex`: `number`,
	// Filter value
	`constant`: [`or`, `number`, `string`]
}

validateAxisFilters := func(axisFilter) {
	validation.assertType(axisFilter, [_AXIS_FILTER_SCHEMA])
}

// Validation of recursive schema requires forward declaration
_JOIN_ENTRY_SCHEMA := undefined
// Validation of recursive schema requires lazy evaluation
_JOIN_LEAF_SCHEMA := func(js, _, _) {
	return validation.checkJson(js, _JOIN_ENTRY_SCHEMA)
}
_JOIN_SUBTREE_SCHEMA := func(js, _, _) {
	return validation.checkJson(js, [_JOIN_ENTRY_SCHEMA])
}
// Validation of recursive schema instantiation
_JOIN_ENTRY_SCHEMA = [`or`,
    {
		// Node type discriminator
		`type`: `string,regex=column`,
		// Column id
		`columnId`: `string`
	},
    {
        // Node type discriminator
        `type`: `string,regex=slicedColumn`,
        // Column id
		`columnId`: `string`,
        // New column id
        `newId`: `string`,
        // Non-empty list of axis filters
        `axisFilters`: [_AXIS_FILTER_SCHEMA]
    },
    {
        // Node type discriminator
        `type`: `string,regex=artificialColumn`,
        // Column id
		`columnId`: `string`,
        // New column id
        `newId`: `string`,
        // Non-empty list of axis indices
        `axesIndices`: [`number`]
    },
    {
        // Node type discriminator
        `type`: `string,regex=inlineColumn`,
        // New column id
        `newId`: `string`,
        // Column spec
        `spec`: spec.P_COLUMN_STRICT_SPEC_SCHEMA,
        // Data info
        `dataInfo`: {
            // Type discriminator
            `type`: `string,regex=Json`,
            // Key length
            `keyLength`: `number`,
            // Data
            `data`: {
                any: [`or`, `null`, `number`, `string`]
            }
        }
    },
	{
		// Node type discriminator
		`type`: `string,regex=inner`,
		// Child nodes to be inner joined
		`entries`: _JOIN_SUBTREE_SCHEMA
	},
	{
		// Node type discriminator
		`type`: `string,regex=full`,
		// Child nodes to be full joined
		`entries`: _JOIN_SUBTREE_SCHEMA
	},
	{
		// Node type discriminator
		`type`: `string,regex=outer`,
		// Primes the join operation (left part of LEFT OUTER JOIN chain)
		`primary`: _JOIN_LEAF_SCHEMA,
		// Driven nodes, giving their values only if primary node have corresponding
		// nodes (right parts of LEFT OUTER JOIN chain)
		`secondary`: _JOIN_SUBTREE_SCHEMA
	}]

// Validation of recursive schema requires forward declaration
_PREDICATE_SCHEMA := undefined
// Validation of recursive schema requires lazy evaluation
_PREDICATE_LEAF_SCHEMA := func(js, _, _) {
	return validation.checkJson(js, _PREDICATE_SCHEMA)
}
_PREDICATE_SUBTREE_SCHEMA := func(js, _, _) {
	return validation.checkJson(js, [_PREDICATE_SCHEMA])
}
_PREDICATE_SCHEMA = [`or`,
    {
		// Node type discriminator
		`operator`: `string,regex=IsNA`
	},
    {
		// Node type discriminator
		`operator`: `string,regex=Equal|Less|LessOrEqual|Greater|GreaterOrEqual`,
        // Reference value
        `reference`: [`or`, `number`, `string`]
	},
    {
        // Node type discriminator
		`operator`: `string,regex=InSet`,
        // Set values
        `values`: [`or`, [`number`], [`string`]]
    },
    {
		// Node type discriminator
		`operator`: `string,regex=IEqual`,
        // Reference value
        `reference`: `string`
	},
    {
		// Node type discriminator
		`operator`: `string,regex=StringContains|StringIContains`,
        // Substring value
        `substring`: `string`
	},
    {
		// Node type discriminator
		`operator`: `string,regex=Matches`,
        // Regular expression
        `regex`: `string`
	},
    {
		// Node type discriminator
		`operator`: `string,regex=StringContainsFuzzy|StringIContainsFuzzy`,
        // Reference value
        `reference`: `string`,
        // Maximum number of edits allowed to be considered a match
        `maxEdits`: `number`,
        // Wildcard character to use
        `wildcard,?`: `string`,
        // If true, only substitutions are allowed (deletions and insertions are also allowed by default)
        `substitutionsOnly,?`: `bool`
	},
    {
        // Node type discriminator
		`operator`: `string,regex=Not`,
        // Operand
        `operand`: _PREDICATE_LEAF_SCHEMA
    },
    {
        // Node type discriminator
		`operator`: `string,regex=And|Or`,
        // Operands
        `operands`: [_PREDICATE_SUBTREE_SCHEMA]
    }]

_P_TABLE_COLUMN_ID_SCHEMA := [`or`,
    {
        // Node type discriminator
        `type`: `string,regex=column`,
        // Column id
        `id`: `string`
    },
    {
        // Node type discriminator
        `type`: `string,regex=axis`,
        // Axis id
        `axisId`: {
            `name`: `string`,
            `type`: `string,regex=Int|Long|String`,
            `domain,?`: { any: `string` }
        }
    }]

_FILTER_SCHEMA := {
    // Column id or axis id
    `column`: _P_TABLE_COLUMN_ID_SCHEMA,
    // Filter predicate
    `predicate`: _PREDICATE_SCHEMA
}

// Validation of recursive schema instantiation
_JOIN_REQUEST_SCHEMA := {
    `__options__,closed`: true,
    // Source
    `src`: _JOIN_ENTRY_SCHEMA,
    // Filters
    `filters`: [_FILTER_SCHEMA]
}

_renameJoinEntry := func(entry, rename) {
    if entry.type == "column" || entry.type == "slicedColumn" || entry.type == "artificialColumn" {
        entry.columnId = rename[entry.columnId]
    } else if entry.type == "inner" || entry.type == "full" {
        entry.entries = slices.map(entry.entries, func(entry) {
            return _renameJoinEntry(entry, rename)
        })
    } else if entry.type == "outer" {
        entry.primary = _renameJoinEntry(entry.primary, rename)
        entry.secondary = slices.map(entry.secondary, func(entry) {
            return _renameJoinEntry(entry, rename)
        })
    }
    return entry
}

_renameJoinFilter := func(filter, rename) {
    if filter.column.type == "column" {
        filter.column.id = rename[filter.column.id]
    }
    return filter
}

renameJoinColumns := func(request, rename) {
    validation.assertType(request, _JOIN_REQUEST_SCHEMA)
    validation.assertType(rename, {any: `string`})
    return {
        src: _renameJoinEntry(request.src, rename),
        filters: slices.map(request.filters, func(filter) {
            return _renameJoinFilter(filter, rename)
        })
    }
}

export ll.toStrict({
    validateParamsForSaveFrameDirect: validateParamsForSaveFrameDirect,
	validateParamsForFrameFromColumnBundle: validateParamsForFrameFromColumnBundle,
    makeFrameSpecs: makeFrameSpecs,
    makeWriteFrameStep: makeWriteFrameStep,
    makeFrameColumnRef: makeFrameColumnRef,
    renameJoinColumns: renameJoinColumns,
    validateAxisFilters: validateAxisFilters
})
