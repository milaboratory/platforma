test := import(":test")
pt := import(":pt")

// Helper to get the raw expression for easier comparison
getExpr := func(exprObj) {
	return exprObj._getExpression({})
}

TestBasicExpressions := func() {
	c1 := pt.col("age")
	test.isEqual(getExpr(c1), {type: "col", name: "age"})

	l_num := pt.lit(10)
	test.isEqual(getExpr(l_num), {type: "const", value: 10})

	l_str := pt.lit("hello")
	test.isEqual(getExpr(l_str), {type: "const", value: "hello"})

	l_bool := pt.lit(true)
	test.isEqual(getExpr(l_bool), {type: "const", value: true})

	l_null := pt.lit(undefined)
	test.isEqual(getExpr(l_null), {type: "const", value: undefined})
}

TestArithmeticExpressions := func() {
	age := pt.col("age")
	salary := pt.col("salary")
	bonus := pt.lit(100)

	expr1 := age.plus(pt.lit(10))
	test.isEqual(getExpr(expr1), {type: "plus", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 10}})

	expr2 := salary.multiply(pt.lit(1.1))
	test.isEqual(getExpr(expr2), {type: "multiply", lhs: {type: "col", name: "salary"}, rhs: {type: "const", value: 1.1}})

	expr3 := age.minus(pt.lit(5)).truediv(pt.lit(2))
	test.isEqual(getExpr(expr3), {
		type: "truediv",
		lhs: {type: "minus", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 5}},
		rhs: {type: "const", value: 2}
	})

	expr4 := bonus.negate()
	test.isEqual(getExpr(expr4), {type:"negate", value: {type: "const", value: 100}})
}

TestComparisonExpressions := func() {
	age := pt.col("age")
	height := pt.col("height")

	expr1 := age.gt(pt.lit(18))
	test.isEqual(getExpr(expr1), {type: "gt", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 18}})

	expr2 := height.le(pt.lit(180))
	test.isEqual(getExpr(expr2), {type: "le", lhs: {type: "col", name: "height"}, rhs: {type: "const", value: 180}})

	expr3 := age.eq(height)
	test.isEqual(getExpr(expr3), {type: "eq", lhs: {type: "col", name: "age"}, rhs: {type: "col", name: "height"}})

    expr4 := age.inSet(18, 20, 22, 20)
    test.isEqual(getExpr(expr4), {type: "in_set", value: {type: "col", name: "age"}, set: [18, 20, 22]})
}

TestLogicalExpressions := func() {
	isAdult := pt.col("isAdult")
	isStudent := pt.col("isStudent")
	hasDiscount := pt.col("hasDiscount")

	expr1 := isAdult.and(isStudent)
	test.isEqual(getExpr(expr1), {
		type: "and",
		operands: [
			{type: "col", name: "isAdult"},
			{type: "col", name: "isStudent"}
		]
	})

	expr2 := isAdult.or(hasDiscount)
	test.isEqual(getExpr(expr2), {
		type: "or",
		operands: [
			{type: "col", name: "isAdult"},
			{type: "col", name: "hasDiscount"}
		]
	})

	expr3 := isStudent.not()
	test.isEqual(getExpr(expr3), {type: "not", value: {type: "col", name: "isStudent"}})

	expr4 := pt.allHorizontal(isAdult, isStudent, hasDiscount.not())
	test.isEqual(getExpr(expr4), {
		type: "and",
		operands: [
			{type: "col", name: "isAdult"},
			{type: "col", name: "isStudent"},
			{type: "not", value: {type: "col", name: "hasDiscount"}}
		]
	})
    expr4_alias := pt.and(isAdult, isStudent, hasDiscount.not())
    test.isEqual(getExpr(expr4_alias), getExpr(expr4))

	expr5 := pt.anyHorizontal(isAdult, isStudent, hasDiscount)
	test.isEqual(getExpr(expr5), {
		type: "or",
		operands: [
			{type: "col", name: "isAdult"},
			{type: "col", name: "isStudent"},
			{type: "col", name: "hasDiscount"}
		]
	})
    expr5_alias := pt.or(isAdult, isStudent, hasDiscount)
    test.isEqual(getExpr(expr5_alias), getExpr(expr5))
}

TestStringExpressions := func() {
	name := pt.col("name")
	firstName := pt.col("firstName")
	lastName := pt.col("lastName")

	expr1 := name.strToUpper()
	test.isEqual(getExpr(expr1), {type: "to_upper", value: {type: "col", name: "name"}})

	expr2 := pt.concatStr([firstName, " ", lastName], {delimiter: " "})
	test.isEqual(getExpr(expr2), {
		type: "str_join",
		operands: [
			{type: "col", name: "firstName"},
			{type: "const", value: " "},
			{type: "col", name: "lastName"}
		],
		delimiter: " "
	})

    expr3 := name.strLenChars()
    test.isEqual(getExpr(expr3), {type: "str_len", value: {type: "col", name: "name"}})

    expr4 := name.strSlice(0, 5)
    test.isEqual(getExpr(expr4), {type: "substring", value: {type: "col", name: "name"}, start: {type: "const", value: 0}, length: {type: "const", value: 5}})

    // New string functions tests
    expr5 := name.strContains("hello")
    test.isEqual(getExpr(expr5), {type: "str_contains", value: {type: "col", name: "name"}, pattern: {type: "const", value: "hello"}, literal: false, strict: true})

    expr6 := name.strContains("hello", {literal: true, strict: false})
    test.isEqual(getExpr(expr6), {type: "str_contains", value: {type: "col", name: "name"}, pattern: {type: "const", value: "hello"}, literal: true, strict: false})

    expr7 := name.strContainsAny(["apple", "banana"])
    test.isEqual(getExpr(expr7), {type: "str_contains_any", value: {type: "col", name: "name"}, patterns: ["apple", "banana"], asciiCaseInsensitive: false})

    expr8 := name.strContainsAny(["apple", "banana"], {asciiCaseInsensitive: true})
    test.isEqual(getExpr(expr8), {type: "str_contains_any", value: {type: "col", name: "name"}, patterns: ["apple", "banana"], asciiCaseInsensitive: true})

    expr9 := name.strCountMatches("a")
    test.isEqual(getExpr(expr9), {type: "str_count_matches", value: {type: "col", name: "name"}, pattern: {type: "const", value: "a"}, literal: false})

    expr10 := name.strCountMatches("a", {literal: true})
    test.isEqual(getExpr(expr10), {type: "str_count_matches", value: {type: "col", name: "name"}, pattern: {type: "const", value: "a"}, literal: true})

    expr11 := name.strExtract("(\\w+)")
    test.isEqual(getExpr(expr11), {type: "str_extract", value: {type: "col", name: "name"}, pattern: {type: "const", value: "(\\w+)"}, groupIndex: 0})

    expr12 := name.strExtract("(\\w+)@(\\w+)", {groupIndex: 2})
    test.isEqual(getExpr(expr12), {type: "str_extract", value: {type: "col", name: "name"}, pattern: {type: "const", value: "(\\w+)@(\\w+)"}, groupIndex: 2})

    expr13 := name.strStartsWith("Mr.")
    test.isEqual(getExpr(expr13), {type: "str_starts_with", value: {type: "col", name: "name"}, prefix: {type: "const", value: "Mr."}})

    expr14 := name.strEndsWith(".com")
    test.isEqual(getExpr(expr14), {type: "str_ends_with", value: {type: "col", name: "name"}, suffix: {type: "const", value: ".com"}})

    expr15 := name.matchesEcmaRegex("^[0-9]+$")
    test.isEqual(getExpr(expr15), {type: "matches_ecma_regex", value: {type: "col", name: "name"}, ecmaRegex: "^[0-9]+$"})

    expr16 := name.containsFuzzyMatch("hello", 1, {wildcard: "*", substitutionsOnly: true})
    test.isEqual(getExpr(expr16), {
        type: "contains_fuzzy_match",
        value: {type: "col", name: "name"},
        reference: "hello",
        maxEdits: 1,
        wildcard: "*",
        substitutionsOnly: true
    })

    expr17 := name.replaceEcmaRegex("^.*(P\\d+)_(W\\d+).*$", "$2-$1")
    test.isEqual(getExpr(expr17), {
        type: "replace_ecma_regex",
        value: {type: "col", name: "name"},
        ecmaRegex: "^.*(P\\d+)_(W\\d+).*$",
        replacement: "$2-$1"
    })

    expr18 := name.extractEcmaRegex("\\d+___([a-z]+).xlsx")
    test.isEqual(getExpr(expr18), {
        type: "extract_ecma_regex",
        value: {type: "col", name: "name"},
        ecmaRegex: "\\d+___([a-z]+).xlsx"
    })
}

TestWindowExpressions := func() {
	salary := pt.col("salary")
	department := pt.col("department")
	employeeId := pt.col("employeeId")

	expr1 := salary.sum().over("department").alias("total_salary_by_department")
	test.isEqual(getExpr(expr1), {
        type: "alias",
        value: {
            type: "aggregate",
            aggregation: "sum",
            value: {type: "col", name: "salary"},
            partitionBy: [{type: "col", name: "department"}]
        },
        name: "total_salary_by_department"
	})

	expr2 := pt.rank(salary, {descending: true}).over(department).alias("rank_salary_by_department")
	test.isEqual(getExpr(expr2), {
		type: "alias",
		value: {
			type: "rank",
			orderBy: [{type: "col", name: "salary"}],
			partitionBy: [{type: "col", name: "department"}],
			descending: true
		},
		name: "rank_salary_by_department"
	})

    expr3 := salary.cumsum({orderBy: employeeId}).over(department).alias("cumsum_salary_by_department")
    test.isEqual(getExpr(expr3), {
        type: "alias",
        value: {
            type: "cumsum",
            value: {type:"col", name:"salary"},
            additionalOrderBy: [{type:"col", name:"employeeId"}],
            partitionBy: [{type:"col", name:"department"}],
            descending: false
        },
        name: "cumsum_salary_by_department"
    })

    expr4 := salary.cumsum({orderBy: [employeeId], descending: true}).over(department).alias("cumsum_salary_by_department")
    test.isEqual(getExpr(expr4), {
        type: "alias",
        value: {
            type: "cumsum",
            value: {type:"col", name:"salary"},
            additionalOrderBy: [{type:"col", name:"employeeId"}],
            partitionBy: [{type:"col", name:"department"}],
            descending: true
        },
        name: "cumsum_salary_by_department"
    })
}

TestConditionalExpressions := func() {
	age := pt.col("age")
	score := pt.col("score")

	expr1 := pt.when(age.gt(pt.lit(60))).
		then(pt.lit("senior")).
		when(age.gt(pt.lit(18))).
		then(pt.lit("adult")).
		otherwise(pt.lit("minor"))

	expected1 := {
		type: "when_then_otherwise",
		conditions: [
			{when: {type: "gt", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 60}}, then: {type: "const", value: "senior"}},
			{when: {type: "gt", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 18}}, then: {type: "const", value: "adult"}}
		],
		otherwise: {type: "const", value: "minor"}
	}
	test.isEqual(getExpr(expr1), expected1)

    // Test immutability of when/then
    whenBuilder1 := pt.when(score.gt(pt.lit(90)))
    thenBuilder1 := whenBuilder1.then(pt.lit("A"))

    finalExprA := thenBuilder1.otherwise(pt.lit("B_OR_C"))

    // This should not affect finalExprA
    finalExprB := thenBuilder1.when(score.gt(pt.lit(80))).then(pt.lit("B")).otherwise(pt.lit("C"))

    expectedA := {
        type: "when_then_otherwise",
        conditions: [
            {when: {type:"gt", lhs:{type:"col", name:"score"}, rhs:{type:"const", value:90}}, then:{type:"const", value:"A"}}
        ],
        otherwise: {type:"const", value:"B_OR_C"}
    }
    test.isEqual(getExpr(finalExprA), expectedA, "Immutable WhenThen A")

    expectedB := {
        type: "when_then_otherwise",
        conditions: [
            {when: {type:"gt", lhs:{type:"col", name:"score"}, rhs:{type:"const", value:90}}, then:{type:"const", value:"A"}},
            {when: {type:"gt", lhs:{type:"col", name:"score"}, rhs:{type:"const", value:80}}, then:{type:"const", value:"B"}}
        ],
        otherwise: {type:"const", value:"C"}
    }
     test.isEqual(getExpr(finalExprB), expectedB, "Immutable WhenThen B")
}

TestAliasing := func() {
	age := pt.col("age")

	aliasedAge := age.alias("yearsOld")
	test.isEqual(getExpr(aliasedAge), {type: "alias", value: {type: "col", name: "age"}, name: "yearsOld"})

	calculated := age.plus(pt.lit(5)).alias("ageInFiveYears")
	test.isEqual(getExpr(calculated), {type: "alias", value: {type: "plus", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 5}}, name: "ageInFiveYears"})

    litVal := pt.lit(100).alias("hundred")
    test.isEqual(getExpr(litVal), {type:"alias", value: {type:"const", value:100}, name: "hundred"})
}

TestChainingAndComplex := func() {
    name := pt.col("name")
    age := pt.col("age")
    country := pt.col("country")

    complexStr := name.strToUpper().plus(pt.lit("_processed")).alias("processedName")

    condition := age.gt(pt.lit(18)).and(country.eq(pt.lit("USA")))
    condition = condition.or(age.lt(pt.lit(10)))

    finalExpr := pt.when(condition).then(complexStr).otherwise(pt.lit("N/A")).alias("finalExpr")

    expectedFinal := {
        type: "alias",
        value: {
            type: "when_then_otherwise",
            conditions: [{
                when: {
                    type: "or",
                    operands: [
                        {
                            type: "and",
                            operands: [
                                {type: "gt", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 18}},
                                {type: "eq", lhs: {type: "col", name: "country"}, rhs: {type: "const", value: "USA"}}
                            ]
                        },
                        {type: "lt", lhs: {type: "col", name: "age"}, rhs: {type: "const", value: 10}}
                    ]
                },
                then: {
                    type: "alias",
                    value: {
                    type: "plus",
                        lhs: {type: "to_upper", value: {type: "col", name: "name"}},
                        rhs: {type: "const", value: "_processed"}
                    },
                    name: "processedName"
                }
            }],
            otherwise: {type: "const", value: "N/A"}
        },
        name: "finalExpr"
    }
    test.isEqual(getExpr(finalExpr), expectedFinal)
}

TestRankWithOptions := func() {
    score1 := pt.col("score1")
    score2 := pt.col("score2")
    group := pt.col("group")

    rank1 := pt.rank(score1).over(group).alias("rank_by_group")
    test.isEqual(getExpr(rank1), {
        type: "alias",
        value: {
            type: "rank",
            orderBy: [{type: "col", name: "score1"}],
            partitionBy: [{type:"col", name:"group"}],
            descending: false
        },
        name: "rank_by_group"
    })

    rank2 := pt.rank(score1, {descending: true}).over(group).alias("rank_by_group")
    test.isEqual(getExpr(rank2), {
        type: "alias",
        value: {
            type: "rank",
            orderBy: [{type: "col", name: "score1"}],
            partitionBy: [{type:"col", name:"group"}],
            descending: true
        },
        name: "rank_by_group"
    })

    rank3 := pt.rank([score1, score2], { descending: false }).alias("rank_by_group")
    test.isEqual(getExpr(rank3), {
        type: "alias",
        value: {
            type: "rank",
            orderBy: [
                {type: "col", name: "score1"},
                {type: "col", name: "score2"}
            ],
            partitionBy: [],
            descending: false
        },
        name: "rank_by_group"
    })

    rank4 := pt.rank([score1, score2], {descending: true}).over(group).alias("rank_by_group")
    test.isEqual(getExpr(rank4), {
        type: "alias",
        value: {
            type: "rank",
            orderBy: [
                {type: "col", name: "score1"},
                {type: "col", name: "score2"}
            ],
            partitionBy: [{type:"col", name:"group"}],
            descending: true
        },
        name: "rank_by_group"
    })
}

TestSelectWithStrings := func() {
    wf := pt.workflow()

    df := wf.frame("col1,col2,col3\n1,2,3", {xsvType: "csv", id: "testData"})

    selectedDf1 := df.select("col1", "col2")

    selectedDf2 := df.select(
        "col1",
        pt.col("col2").plus(pt.lit(10)).alias("col2_plus_10")
    )

    selectedDf3 := df.select(
        pt.col("col1"),
        pt.col("col3").alias("renamed_col3")
    )

    // Test 4: Verify internal column mapping for mixed case
    testExprs := ["col1", pt.col("col2").plus(pt.lit(10)).alias("col2_plus_10")]

    expectedCols := [
        {name: "col1", expression: {type: "col", name: "col1"}},
        {name: "col2_plus_10", expression: {type: "plus", lhs: {type: "col", name: "col2"}, rhs: {type: "const", value: 10}}}
    ]

    // If we could access the internal mapping function, we would test it directly
    // For now, we ensure that the select operations can be constructed without errors
}

TestNdjsonReading := func() {
    wf := pt.workflow()

    // Test NDJSON string content
    ndjsonContent := `{"id": 1, "name": "Alice"}
{"id": 2, "name": "Bob"}`
    df := wf.frame(ndjsonContent, {format: "ndjson", id: "testNdjson"})

    // Test with nRows limit
    dfLimited := wf.frame(ndjsonContent, {format: "ndjson", nRows: 1, id: "testNdjsonLimited"})

    // Test with ignoreErrors
    dfIgnoreErrors := wf.frame(ndjsonContent, {format: "ndjson", ignoreErrors: true, id: "testNdjsonIgnoreErrors"})

    // Test with schema override
    dfWithSchema := wf.frame(ndjsonContent, {
        format: "ndjson",
        schema: [{column: "id", type: "Int64"}],
        id: "testNdjsonWithSchema"
    })
}

TestNdjsonAutoDetection := func() {
    wf := pt.workflow()

    // Test auto-detection from fileName with content
    ndjsonContent := `{"id": 1, "name": "Alice"}`

    // Test auto-detection from .ndjson extension
    dfNdjson := wf.frame(ndjsonContent, {fileName: "test.ndjson", id: "autoDetectNdjson"})

    // Test auto-detection from .jsonl extension
    dfJsonl := wf.frame(ndjsonContent, {fileName: "test.jsonl", id: "autoDetectJsonl"})

    // Test CSV auto-detection still works
    csvContent := "col1,col2\n1,2"
    dfCsv := wf.frame(csvContent, {fileName: "data.csv", id: "autoDetectCsv"})
}

TestFormatBackwardCompatibility := func() {
    wf := pt.workflow()

    // Old xsvType should still work
    df1 := wf.frame("data.csv", {xsvType: "csv", id: "backwardCsv"})

    // New format should work
    df2 := wf.frame("data.csv", {format: "csv", id: "newFormatCsv"})

    // format overrides xsvType
    df3 := wf.frame("data.json", {xsvType: "csv", format: "ndjson", id: "formatOverrides"})

    // Test that both parameters work together correctly
    df4 := wf.frame("test_content", {xsvType: "tsv", fileName: "test.tsv", id: "bothParams"})
}

TestNdjsonWriting := func() {
    wf := pt.workflow()
    df := wf.frame("col1,col2\n1,2", {format: "csv", id: "testData"})

    // Test auto-detection for NDJSON writing
    df.save("output.ndjson")
    df.save("output.jsonl")

    // Test explicit format parameter
    df.save("data.txt", {format: "ndjson"})

    // Test format overriding extension
    df.save("data.csv", {format: "ndjson"})

    // Test backward compatibility for writing
    df.save("legacy.csv", {xsvType: "csv"})

    // Test column selection with NDJSON
    df.save("subset.ndjson", {columns: ["col1"]})

    // Test saveContent with NDJSON
    df.saveContent("content.ndjson")
}

TestNdjsonParameterValidation := func() {
    wf := pt.workflow()

    // These should work without error
    df1 := wf.frame("test", {format: "ndjson", id: "valid1"})
    df2 := wf.frame("test", {format: "csv", nRows: 100, id: "valid2"})
    df3 := wf.frame("test", {format: "tsv", ignoreErrors: false, id: "valid3"})

    // Test that the new parameters are properly validated
    // Note: In a real test environment, we would test that invalid parameters cause panics
    // For now, we just ensure valid parameters don't cause issues
}

TestSelectorExpressions := func() {
    // Basic selectors
    expr1 := pt.sc.all()
    test.isEqual(getExpr(expr1), {type: "selector_all"})

    expr2 := pt.sc.string()
    test.isEqual(getExpr(expr2), {type: "selector_string"})

    expr3 := pt.sc.numeric()
    test.isEqual(getExpr(expr3), {type: "selector_numeric"})

    expr4 := pt.sc.integer()
    test.isEqual(getExpr(expr4), {type: "selector_integer"})

    expr5 := pt.sc.float()
    test.isEqual(getExpr(expr5), {type: "selector_float"})

    expr6 := pt.sc.nested()
    test.isEqual(getExpr(expr6), {type: "selector_nested"})

    // Name-based selectors
    expr7 := pt.sc.startsWith("test_")
    test.isEqual(getExpr(expr7), {type: "selector_starts_with", prefix: "test_"})

    expr8 := pt.sc.endsWith("_id")
    test.isEqual(getExpr(expr8), {type: "selector_ends_with", suffix: "_id"})

    expr9 := pt.sc.contains("age")
    test.isEqual(getExpr(expr9), {type: "selector_contains", substring: "age"})

    expr10 := pt.sc.matches("^col_[0-9]+$")
    test.isEqual(getExpr(expr10), {type: "selector_matches", pattern: "^col_[0-9]+$"})

    expr11 := pt.sc.exclude("id", "timestamp")
    test.isEqual(getExpr(expr11), {type: "selector_exclude", columns: ["id", "timestamp"]})

    expr12 := pt.sc.byName("name", "age", "email")
    test.isEqual(getExpr(expr12), {type: "selector_by_name", names: ["name", "age", "email"]})

    // Complement
    expr13 := pt.sc.string().complement()
    test.isEqual(getExpr(expr13), {
        type: "selector_complement",
        selector: {type: "selector_string"}
    })

    // Union
    expr14 := pt.sc.string().union(pt.sc.numeric())
    test.isEqual(getExpr(expr14), {
        type: "selector_union",
        selectors: [
            {type: "selector_string"},
            {type: "selector_numeric"}
        ]
    })

    // Union with multiple selectors
    expr15 := pt.sc.string().union(pt.sc.numeric(), pt.sc.nested())
    test.isEqual(getExpr(expr15), {
        type: "selector_union",
        selectors: [
            {type: "selector_string"},
            {type: "selector_numeric"},
            {type: "selector_nested"}
        ]
    })

    // Intersection
    expr16 := pt.sc.numeric().intersection(pt.sc.startsWith("test_"))
    test.isEqual(getExpr(expr16), {
        type: "selector_intersection",
        selectors: [
            {type: "selector_numeric"},
            {type: "selector_starts_with", prefix: "test_"}
        ]
    })

    // Difference
    expr17 := pt.sc.all().difference(pt.sc.string())
    test.isEqual(getExpr(expr17), {
        type: "selector_difference",
        selectors: [
            {type: "selector_all"},
            {type: "selector_string"}
        ]
    })

    // Symmetric difference
    expr18 := pt.sc.string().symmetricDifference(pt.sc.startsWith("temp_"))
    test.isEqual(getExpr(expr18), {
        type: "selector_symmetric_difference",
        selectors: [
            {type: "selector_string"},
            {type: "selector_starts_with", prefix: "temp_"}
        ]
    })

    // Complex chaining
    expr19 := pt.sc.numeric().intersection(pt.sc.startsWith("test_")).complement()
    test.isEqual(getExpr(expr19), {
        type: "selector_complement",
        selector: {
            type: "selector_intersection",
            selectors: [
                {type: "selector_numeric"},
                {type: "selector_starts_with", prefix: "test_"}
            ]
        }
    })

    // Complex union with difference
    expr20 := pt.sc.all().difference(pt.sc.string(), pt.sc.nested())
    test.isEqual(getExpr(expr20), {
        type: "selector_difference",
        selectors: [
            {type: "selector_all"},
            {type: "selector_string"},
            {type: "selector_nested"}
        ]
    })
}
