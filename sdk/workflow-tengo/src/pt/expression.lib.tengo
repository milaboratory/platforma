ll := import(":ll")
maps := import(":maps")
slices := import(":slices")


// Forward declarations
_newExpression := undefined
_newWindowExpression := undefined
col := undefined
lit := undefined
allHorizontal := undefined
anyHorizontal := undefined
and := undefined
or := undefined
when := undefined
rank := undefined

// Helper function to check if an item is a valid expression object
_isExpression := func(item) {
	return ll.isMap(item) && ll.methodExists(item, "getExpression")
}

// Helper function to check if an item is a valid aggregation object
_isAggregation := func(item) {
	return ll.isMap(item) && ll.methodExists(item, "getAggregation")
}

// Helper function to map string column names or expression objects to their JSON structure
_mapToExpressionStructList := func(itemsList, stringInterpretation) {
	if !is_array(itemsList) {
		itemsList = [itemsList] // Allow single item to be passed
	}
	if stringInterpretation != "col" && stringInterpretation != "lit" {
		ll.panic("Invalid stringInterpretation ('%v') for _mapToExpressionStructList. Must be 'col' or 'lit'.", stringInterpretation)
		return undefined // Unreachable
	}
	return slices.map(itemsList, func(item) {
		if is_string(item) {
			if stringInterpretation == "col" {
				return col(item).getExpression()
			} else { // Must be "lit" due to the check above
				return lit(item).getExpression()
			}
		} else if _isExpression(item) {
			return item.getExpression()
		} else {
			ll.panic("Invalid item type in list: %T. Must be a string (interpreted as '%s') or an expression object.", item, stringInterpretation)
			return undefined // Unreachable
		}
	})
}

_mapToSingleExpressionStruct := func(item, stringInterpretation) {
	if _isExpression(item) {
		return item.getExpression()
	} else if is_int(item) || is_float(item) || is_bool(item) { // These are always literals
		return lit(item).getExpression()
	} else if is_string(item) {
		if stringInterpretation == "col" {
			return col(item).getExpression()
		} else if stringInterpretation == "lit" {
			return lit(item).getExpression()
		} else { // stringInterpretation is undefined or an invalid value
			ll.panic("String item '%v' provided, but its interpretation as 'col' or 'lit' was not specified or is not applicable in this context. (stringInterpretation: '%v')", item, stringInterpretation)
			return undefined
		}
	} else {
		ll.panic("Invalid item type: %T. Expected an expression, literal (number, bool, null), or string (with 'col'/'lit' interpretation).", item)
		return undefined
	}
}


/**
 * @param expression - WindowExpression - ptabler window expression structure
 * @param currentAlias - string - The alias to use for the expression if passed to steps like withColumns
 * @returns {object} - The expression object.
 */
_newWindowExpression = func(expression, aggregation, currentAlias) {
	self := undefined
	self = ll.toStrict({
		/** Returns the underlying PTabler expression structure. */
		getExpression: func() {
			if expression == undefined {
				ll.panic("Using this operation as a window expression is not allowed. Use it as a group by expression instead. %v", aggregation)
			}
			return expression
		},
		/** Returns the aggregation for group by operations. */
		getAggregation: func() {
			if aggregation == undefined {
				ll.panic("Using this operation as a group by expression is not allowed, most probably because you applied .over() to it. %v", expression)
			}
			return maps.deepMerge(aggregation, {name: self.getAlias()})
		},
		/** Returns the current alias of the expression, if defined. Panics if no alias is set. */
		getAlias: func() {
			if currentAlias == undefined {
				ll.panic("Alias is not defined for this window expression.")
			}
			return currentAlias
		},

		/**
		 * Sets an alias for this window expression.
		 * The alias is used as the column name when this expression defines a new column in operations like `select` or `withColumns` (often after an `.over()` call).
		 * @param newAlias - string - The new alias, which will be the column name.
		 * @returns {object} - A new window expression object with the updated alias.
		 */
		alias: func(newAlias) {
			return _newWindowExpression(expression, aggregation, newAlias)
		},

		/**
		 * Defines the partitioning for the window expression.
		 * @param partitionBy - string|object|array - A column name, an expression object, or an array of column names/expression objects to partition by.
		 * @returns {object} - A new window expression object with the partitioning defined.
		 */
		over: func(partitionBy) {
			ll.assert(is_array(partitionBy) || is_string(partitionBy) || _isExpression(partitionBy), "partitionBy must be an array of strings/expressions or a single string/expression")

			if len(expression.partitionBy) > 0 {
				ll.warn("partitionBy already set on this window expression, overriding.")
			}

			newExpression := maps.deepMerge(expression, {
				partitionBy: _mapToExpressionStructList(partitionBy, "col")
			})

			return _newWindowExpression(newExpression, undefined, currentAlias)
		}
	})
	return self
}

/**
 * @param expression - Expression - ptabler expression structure
 * @param currentAlias - string - The alias to use for the expression if passed to steps like withColumns
 * @returns {object} - The expression object.
 */
_newExpression = func(expression, currentAlias) {
	self := undefined // forward declaration

	// Helper for binary operations
	binaryOp := func(opType, other) {
		rhsExprStruct := undefined
		if _isExpression(other) {
			rhsExprStruct = other.getExpression()
		} else if is_int(other) || is_float(other) || is_bool(other) || is_string(other) {
			rhsExprStruct = lit(other).getExpression()
		} else {
			ll.panic(opType + " expects an expression object or a literal (number, boolean, null) as argument. Got type: %T", other)
		}

		return _newExpression(
			{type: opType, lhs: expression, rhs: rhsExprStruct},
			undefined // Result of operation typically doesn't carry forward alias
		)
	}

	// Helper for unary operations
	unaryOp := func(opType) {
		return _newExpression(
			{type: opType, value: expression},
			undefined
		)
	}

	// Helper for string unary operations (operates on `value.str`)
	unaryStrOp := func(opType) {
		return _newExpression(
			{type: opType, value: expression},
			undefined
		)
	}

	// Helper for aggregation functions that return a WindowExpression
	aggOp := func(aggType) {
		return _newWindowExpression(
			{type: "aggregate", aggregation: aggType, value: expression, partitionBy: []},
			{aggregation: aggType, expression: expression},
			undefined // Alias of underlying col, window expression itself is typically aliased later
		)
	}

	aggOpBy := func(aggType, by) {
		return _newWindowExpression(
			undefined,
			{aggregation: aggType, expression: expression, by: _mapToExpressionStructList(by, "col")},
			undefined // Alias of underlying col, window expression itself is typically aliased later
		)
	}

	self = ll.toStrict({
		/** Returns the underlying PTabler expression structure. */
		getExpression: func() { return expression },
		/** Returns the current alias of the expression, if defined. Panics if no alias is set. */
		getAlias: func() {
			if currentAlias == undefined {
				ll.panic("Alias is not defined for this expression.")
			}
			return currentAlias
		},
		/**
		 * Sets an alias for this expression.
		 * The alias is used as the column name when this expression is used to define a new column in operations like `select` or `withColumns`.
		 * @param newAlias - string - The new alias, which will be the column name.
		 * @returns {object} - A new expression object with the updated alias.
		 */
		alias: func(newAlias) {
			return _newExpression(expression, newAlias)
		},

		// Comparison
		/** Checks if this expression is greater than another. Raw literal values can be used directly, e.g., `expr.gt(2)`. */
		gt: func(other) { return binaryOp("gt", other) },
		/** Checks if this expression is greater than or equal to another. Raw literal values can be used directly, e.g., `expr.ge(2)`. */
		ge: func(other) { return binaryOp("ge", other) },
		/** Checks if this expression is equal to another. Raw literal values can be used directly, e.g., `expr.eq(2)`. */
		eq: func(other) { return binaryOp("eq", other) },
		/** Checks if this expression is less than another. Raw literal values can be used directly, e.g., `expr.lt(2)`. */
		lt: func(other) { return binaryOp("lt", other) },
		/** Checks if this expression is less than or equal to another. Raw literal values can be used directly, e.g., `expr.le(2)`. */
		le: func(other) { return binaryOp("le", other) },
		/** Checks if this expression is not equal to another. Raw literal values can be used directly, e.g., `expr.neq(2)`. */
		neq: func(other) { return binaryOp("neq", other) },

		// Arithmetic
		/** Adds another expression to this expression. Raw literal values can be used directly, e.g., `expr.plus(2)`. */
		plus: func(other) { return binaryOp("plus", other) },
		/** Subtracts another expression from this expression. Raw literal values can be used directly, e.g., `expr.minus(2)`. */
		minus: func(other) { return binaryOp("minus", other) },
		/** Multiplies this expression by another. Raw literal values can be used directly, e.g., `expr.multiply(2)`. */
		multiply: func(other) { return binaryOp("multiply", other) },
		/** Performs true division of this expression by another. Raw literal values can be used directly, e.g., `expr.truediv(2)`. */
		truediv: func(other) { return binaryOp("truediv", other) },
		/** Performs floor division of this expression by another. Raw literal values can be used directly, e.g., `expr.floordiv(2)`. */
		floordiv: func(other) { return binaryOp("floordiv", other) },

		/** Computes the base-10 logarithm of this expression. */
		log10: func() { return unaryOp("log10") },
		/** Computes the natural logarithm of this expression. */
		log: func() { return unaryOp("log") },
		/** Computes the base-2 logarithm of this expression. */
		log2: func() { return unaryOp("log2") },
		/** Computes the absolute value of this expression. */
		abs: func() { return unaryOp("abs") },
		/** Computes the square root of this expression. */
		sqrt: func() { return unaryOp("sqrt") },
		/** Negates this expression. */
		negate: func() { return unaryOp("negate") },
		/** Computes the floor of this expression. */
		floor: func() { return unaryOp("floor") },
		/** Rounds this expression to the nearest integer. */
		round: func() { return unaryOp("round") },
		/** Computes the ceiling of this expression. */
		ceil: func() { return unaryOp("ceil") },

		// Cast

		/**
		 * Casts this expression to a different data type.
		 * @param dtype - string - The target data type. Supported types: 'Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'Boolean', 'String', 'Date', 'Datetime', 'Time', 'Int', 'Long', 'Float', 'Double'.
		 * @param options - map (optional) - An optional map with options:
		 *   - strict (boolean, optional): If true, casting errors will panic. Defaults to false (errors result in null).
		 * @returns {object} - A new expression object representing the cast operation.
		 */
		cast: func(dtype, ...options) {
			strictVal := false
			if len(options) > 0 {
				ll.assert(len(options) == 1, "cast accepts at most one options map argument.")
				opsMap := options[0]
				ll.assert(is_map(opsMap), "Second argument to cast(), if provided, must be an options map.")
				if !is_undefined(opsMap.strict) {
					ll.assert(is_bool(opsMap.strict), "strict in options map must be a boolean")
					strictVal = opsMap.strict
				}
			}
			return _newExpression(
				{type: "cast", value: expression, dtype: dtype, strict: strictVal},
				undefined
			)
		},

		// Boolean
		/** Performs a logical AND with another expression. Alias for top-level `allHorizontal`. */
		and: func(other) {
			ll.assert(_isExpression(other), "and method expects an expression object as argument")
			return allHorizontal(self, other) // Refer to top-level function
		},
		/** Performs a logical OR with another expression. Alias for top-level `anyHorizontal`. */
		or: func(other) {
			ll.assert(_isExpression(other), "or method expects an expression object as argument")
			return anyHorizontal(self, other) // Refer to top-level function
		},
		/** Performs a logical NOT on this expression. */
		not: func() {
			return unaryOp("not")
		},

		// Null checks
		/** Checks if this expression is null. */
		isNull: func() { return unaryOp("is_na") }, // Polars: is_null(), TS: is_na
		/** Checks if this expression is not null. */
		isNotNull: func() { return unaryOp("is_not_na") }, // Polars: is_not_null(), TS: is_not_na

		// String operations
		/** Converts this string expression to uppercase. */
		strToUpper: func() { return unaryStrOp("to_upper") },
		/** Converts this string expression to lowercase. */
		strToLower: func() { return unaryStrOp("to_lower") },
		/** Computes the length of this string expression in characters. */
		strLenChars: func() { return unaryStrOp("str_len")},

		/**
		 * Extracts a substring from this string expression.
		 * @param start - int - The starting index (0-based).
		 * @param lengthArgs - int (optional) - The length of the substring. If not provided, slices to the end.
		 * @returns {object} - A new expression object representing the substring.
		 */
		strSlice: func(start, ...lengthArgs) { // Primary method with optional length via varargs
			ll.assert(is_int(start), "start must be an integer")
			ll.assert(len(lengthArgs) <= 1, "strSlice expects at most one optional length argument.")

			exprDetails := {type: "substring", value: expression, start: start}
			if len(lengthArgs) == 1 {
				lengthVal := lengthArgs[0]
				ll.assert(is_int(lengthVal), "length, if provided, must be an integer")
				exprDetails.length = lengthVal
			}
			// If lengthArgs is empty, the PTabler backend should interpret this as slicing to the end.
			return _newExpression(exprDetails, undefined)
		},

		/**
		 * Extracts a substring from this string expression using start and end indices.
		 * @param start - int - The starting index (0-based).
		 * @param endIdx - int - The ending index (exclusive).
		 * @returns {object} - A new expression object representing the substring.
		 */
		strSliceEnd: func(start, endIdx) { // Method with end index
			ll.assert(is_int(start), "start must be an integer")
			ll.assert(is_int(endIdx), "endIdx must be an integer")

			exprDetails := {type: "substring", value: expression, start: start, end: endIdx}
			return _newExpression(exprDetails, undefined)
		},

		/**
		 * Replaces occurrences of a pattern in this string expression with a replacement string.
		 * @param pattern - string|object - The pattern (string literal, regex, or an expression object evaluating to a string) to search for.
		 * @param replacement - string|object - The replacement string (string literal or an expression object evaluating to a string). Can use $n or ${name} for regex capture groups.
		 * @param options - map (optional) - An optional map with options:
		 *   - replaceAll (boolean, optional): If true, replace all occurrences. Defaults to false (replace first).
		 *   - literal (boolean, optional): If true, treat pattern as a literal string. Defaults to false (pattern is regex).
		 * @returns {object} - A new expression object representing the replacement.
		 */
		strReplace: func(pattern, replacement, ...options) {
			replaceAllVal := false
			literalVal := false

			if len(options) > 0 {
				ll.assert(len(options) == 1, "strReplace accepts at most one options map argument.")
				opsMap := options[0]
				ll.assert(is_map(opsMap), "Third argument to strReplace(), if provided, must be an options map.")
				if !is_undefined(opsMap.replaceAll) {
					ll.assert(is_bool(opsMap.replaceAll), "replaceAll in options map must be a boolean")
					replaceAllVal = opsMap.replaceAll
				}
				if !is_undefined(opsMap.literal) {
					ll.assert(is_bool(opsMap.literal), "literal in options map must be a boolean")
					literalVal = opsMap.literal
				}
			}

			return _newExpression({
				type: "str_replace",
				value: expression,
				pattern: _mapToSingleExpressionStruct(pattern, "lit"),
				replacement: _mapToSingleExpressionStruct(replacement, "lit"),
				replaceAll: replaceAllVal,
				literal: literalVal
			}, undefined)
		},

		// Fuzzy string
		/**
		 * Computes the distance or similarity between this string expression and another.
		 * @param string2 - object - An expression object representing the second string.
		 * @param metric - string - The distance metric. Supported: 'levenshtein', 'optimal_string_alignment', 'jaro_winkler'.
		 * @param returnSimilarity - boolean (optional) - If true, returns similarity (0-1). Defaults to false (returns distance). Jaro-Winkler always returns similarity.
		 * @returns {object} - A new expression object.
		 */
		strDistance: func(string2, metric, returnSimilarity) {
			ll.assert(_isExpression(string2), "string2 must be an expression object")
			ll.assert(is_string(metric), "metric must be a string")

			returnSimilarityVal := false
			if returnSimilarity != undefined {
				ll.assert(is_bool(returnSimilarity), "returnSimilarity must be a boolean")
				returnSimilarityVal = returnSimilarity
			}

			return _newExpression({
				type: "string_distance",
				string1: expression,
				string2: string2.getExpression(),
				metric: metric,
				returnSimilarity: returnSimilarityVal
			}, undefined)
		},

		/**
		 * Filters strings based on fuzzy matching against a pattern.
		 * Returns true if the distance between this string expression and the pattern is within the bound.
		 * @param patternExpr - object - An expression object representing the pattern string.
		 * @param metric - string - The distance metric. Supported: 'levenshtein', 'hamming'.
		 * @param bound - number - The maximum allowed distance for a match (inclusive).
		 * @returns {object} - A boolean expression object.
		 */
		fuzzyFilter: func(patternExpr, metric, bound) {
			ll.assert(_isExpression(patternExpr), "patternExpr must be an expression object")
			ll.assert(is_string(metric), "metric must be a string")
			ll.assert(is_int(bound) || is_float(bound), "bound must be a number")

			return _newExpression({
				type: "fuzzy_string_filter",
				value: expression,
				pattern: patternExpr.getExpression(),
				metric: metric,
				bound: bound
			}, undefined)
		},

		// Hash
		/**
		 * Computes a hash of this expression.
		 * @param hashType - string - The hash algorithm. Supported: 'sha256', 'sha512', 'md5', 'blake3', 'wyhash', 'xxh3'.
		 * @param encoding - string - The output encoding. Supported: 'hex', 'base64', 'base64_alphanumeric', 'base64_alphanumeric_upper'.
		 * @param bits - int (optional) - Minimum entropy bits for the output, affecting encoded string length.
		 * @returns {object} - A new expression object representing the hash.
		 */
		hash: func(hashType, encoding, bits) {
			ll.assert(is_string(hashType), "hashType must be a string")
			ll.assert(is_string(encoding), "encoding must be a string")
			if bits != undefined {
				ll.assert(is_int(bits), "bits must be a number")
			}

			hashExpr := {
				type: "hash",
				value: expression,
				hashType: hashType,
				encoding: encoding
			}
			if bits != undefined {
				hashExpr.bits = bits
			}
			return _newExpression(hashExpr, undefined)
		},

		// Conditional
		/**
		 * Fills null values in this expression with a specified value.
		 * @param fillValueExpr - object - An expression object whose value is used if this expression is null.
		 * @returns {object} - A new expression object.
		 */
		fillNull: func(fillValueExpr) {
			ll.assert(_isExpression(fillValueExpr), "fillValueExpr must be an expression object")
			return _newExpression(
				{type: "fill_na", input: expression, fillValue: fillValueExpr.getExpression()},
				undefined
			)
		},

		// Window/Aggregations
		/** Computes the sum of this expression over a window. Requires .over() to define the window. */
		sum: func() { return aggOp("sum") },
		/** Computes the mean of this expression over a window. Requires .over() to define the window. */
		mean: func() { return aggOp("mean") },
		/** Computes the median of this expression over a window. Requires .over() to define the window. */
		median: func() { return aggOp("median") },
		/** Computes the minimum of this expression over a window. Requires .over() to define the window. */
		min: func() { return aggOp("min") },
		/** Computes the maximum of this expression over a window. Requires .over() to define the window. */
		max: func() { return aggOp("max") },
		/** Computes the standard deviation of this expression over a window. Requires .over() to define the window. */
		std: func() { return aggOp("std") },
		/** Computes the variance of this expression over a window. Requires .over() to define the window. */
		var: func() { return aggOp("var") },
		/** Counts the non-null values of this expression over a window. Requires .over() to define the window. */
		count: func() { return aggOp("count") },
		/** Gets the first value of this expression over a window. Requires .over() to define the window. */
		first: func() { return aggOp("first") },
		/** Gets the last value of this expression over a window. Requires .over() to define the window. */
		last: func() { return aggOp("last") },
		/** Counts the number of unique values of this expression over a window. Requires .over() to define the window. */
		nUnique: func() { return aggOp("n_unique") },

		/** Computes the value of this expression, when by expression is maximized. Can only be used as a group by context. */
		maxBy: func(...by) { return aggOpBy("max_by", by) },
		/** Computes the value of this expression, when by expression is minimized. Can only be used as a group by context. */
		minBy: func(...by) { return aggOpBy("min_by", by) },

		/**
		 * Computes the rank of this expression within a window. Requires .over() to define the window partition.
		 * The ordering for the rank is based on this expression itself.
		 * @param descendingArgs - boolean (optional) - If true, ranks in descending order. Defaults to false.
		 * @returns {object} - A window expression object, which needs .over() to be called.
		 */
		rank: func(...descendingArgs) {
			ll.assert(len(descendingArgs) <= 1, "rank method expects at most one optional boolean argument for descending.")
			descendingVal := false
			if len(descendingArgs) == 1 {
				ll.assert(is_bool(descendingArgs[0]), "descending argument for rank must be a boolean")
				descendingVal = descendingArgs[0]
			}
			return _newWindowExpression({
				type: "rank",
				orderBy: [expression],
				partitionBy: [], // To be set by .over()
				descending: descendingVal
			}, undefined)
		},

		/**
		 * Computes the cumulative sum of this expression within a window. Requires .over() to define the window partition.
		 * Values are sorted by this expression's value, then by 'orderBy' expressions before summing.
		 * @param args - varargs - Can be:
		 *   - (orderBy: string|object|array, descending: boolean (optional))
		 *   - (descending: boolean (optional))
		 *   - (options: map {orderBy?: string|object|array, descending?: boolean})
		 *   orderBy: Additional expressions to sort by within the window before cumsum.
		 *   descending: If true, sorts in descending order. Applies to both this expression and 'orderBy' expressions.
		 * @returns {object} - A window expression object, which needs .over() to be called.
		 */
		cumsum: func(...args) {
			additionalOrderByVal := []
			descendingVal := false
			actualArgs := args

			if len(args) > 0 && is_map(args[len(args)-1]) && !(_isExpression(args[len(args)-1])) {
				ops := args[len(args)-1]
				actualArgs = args[0:len(args)-1]
				if maps.containsKey(ops, "orderBy") {
					additionalOrderByVal = _mapToExpressionStructList(ops.orderBy, "col")
				}
				if maps.containsKey(ops, "descending") {
					ll.assert(is_bool(ops.descending), "descending in options map must be a boolean")
					descendingVal = ops.descending
				}
			}

			// Process remaining actualArgs if not handled by options map
			if len(additionalOrderByVal) == 0 && len(actualArgs) > 0 {
				if is_array(actualArgs[0]) || is_string(actualArgs[0]) || _isExpression(actualArgs[0]) {
					additionalOrderByVal = _mapToExpressionStructList(actualArgs[0], "col")
					if len(actualArgs) > 1 && is_bool(actualArgs[1]) {
						descendingVal = actualArgs[1]
					}
				} else if is_bool(actualArgs[0]) && len(additionalOrderByVal) == 0 { // only if not set by ops.orderBy
					descendingVal = actualArgs[0]
				} else if len(actualArgs) > 0 {
					ll.panic("Invalid arguments to cumsum. Expected order expressions or options map.")
				}
			}

			return _newWindowExpression({
				type: "cumsum",
				value: expression,
				additionalOrderBy: additionalOrderByVal,
				partitionBy: [],
				descending: descendingVal
			}, undefined, undefined)
		}
	})
	return self
}

//
// Top-level functions
//

/**
 * Creates an expression that references a column by its name.
 * @param name - string - The name of the column.
 * @returns {object} - An expression object.
 */
col = func(name) {
	ll.assert(is_string(name), "col name must be a string")
	return _newExpression({
		type: "col",
		name: name
	}, name)
}

/**
 * Creates an expression from a literal (constant) value.
 * @param value - any - The literal value (string, number, boolean, or null).
 * @returns {object} - An expression object.
 */
lit = func(value) {
	return _newExpression({
		type: "const",
		value: value
	}, undefined)
}

/**
 * Concatenates string representations of multiple expressions, optionally separated by a delimiter.
 * @param expressions - array - An array of expression objects or string literals whose string representations will be joined.
 * @param options - map (optional) - An optional map with options:
 *   - delimiter (string, optional): The delimiter string to insert between joined elements. Defaults to "".
 * @returns {object} - An expression object.
 */
concatStr := func(expressions, ...options) {
	ll.assert(is_array(expressions), "First argument to concatStr must be an array of expressions")
	ll.assert(len(expressions) > 0, "Expression array for concatStr cannot be empty")

	delimiterVal := "" // Default to empty string
	if len(options) > 0 {
		ll.assert(len(options) == 1, "concatStr accepts at most one options map argument.")
		opsMap := options[0]
		ll.assert(is_map(opsMap), "Second argument to concatStr(), if provided, must be an options map.")
		if !is_undefined(opsMap.delimiter) {
			ll.assert(is_string(opsMap.delimiter), "delimiter in options map must be a string")
			delimiterVal = opsMap.delimiter
		}
	}

	return _newExpression({
		type: "str_join",
		operands: _mapToExpressionStructList(expressions, "lit"),
		delimiter: delimiterVal
	}, undefined)
}

/**
 * Computes the element-wise minimum across an array of expressions.
 * @param expressions - array - An array of expression objects or column names.
 * @returns {object} - An expression object representing the minimum.
 */
minHorizontal := func(expressions) {
	ll.assert(is_array(expressions), "Argument to minHorizontal must be an array of expressions")
	ll.assert(len(expressions) > 0, "Expression array for minHorizontal cannot be empty")
	return _newExpression({
		type: "min",
		operands: _mapToExpressionStructList(expressions, "col")
	}, undefined)
}

/**
 * Computes the element-wise maximum across an array of expressions.
 * @param expressions - array - An array of expression objects or column names.
 * @returns {object} - An expression object representing the maximum.
 */
maxHorizontal := func(expressions) {
	ll.assert(is_array(expressions), "Argument to maxHorizontal must be an array of expressions")
	ll.assert(len(expressions) > 0, "Expression array for maxHorizontal cannot be empty")
	return _newExpression({
		type: "max",
		operands: _mapToExpressionStructList(expressions, "col")
	}, undefined)
}

/**
 * Computes the element-wise logical AND across multiple boolean expressions.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical AND.
 */
allHorizontal = func(...args){
    processedOperands := []
    for arg in args {
        exprStruct := undefined
        if _isExpression(arg) {
            exprStruct = arg.getExpression()
        } else if is_string(arg) {
            exprStruct = col(arg).getExpression()
        } else {
            ll.panic("Invalid argument type for allHorizontal: %T. Must be an expression object or string.", arg)
        }

        if exprStruct.type == "and" && is_array(exprStruct.operands) {
            processedOperands = append(processedOperands, exprStruct.operands...)
        } else {
            processedOperands = append(processedOperands, exprStruct)
        }
    }
    if len(processedOperands) == 0 {
        ll.panic("allHorizontal requires at least one expression.")
    }
    return _newExpression({
        type: "and",
        operands: processedOperands
    }, undefined)
}

/**
 * Computes the element-wise logical OR across multiple boolean expressions.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical OR.
 */
anyHorizontal = func(...args){
    processedOperands := []
    for arg in args {
        exprStruct := undefined
        if _isExpression(arg) {
            exprStruct = arg.getExpression()
        } else if is_string(arg) {
            exprStruct = col(arg).getExpression()
        } else {
            ll.panic("Invalid argument type for anyHorizontal: %T. Must be an expression object or string.", arg)
        }

        if exprStruct.type == "or" && is_array(exprStruct.operands) {
            processedOperands = append(processedOperands, exprStruct.operands...)
        } else {
            processedOperands = append(processedOperands, exprStruct)
        }
    }
    if len(processedOperands) == 0 {
        ll.panic("anyHorizontal requires at least one expression.")
    }
    return _newExpression({
        type: "or",
        operands: processedOperands
    }, undefined)
}

/**
 * Computes the element-wise logical AND across multiple boolean expressions. Alias for allHorizontal.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical AND.
 */
and = func(...args) {
	return allHorizontal(args...)
}

/**
 * Computes the element-wise logical OR across multiple boolean expressions. Alias for anyHorizontal.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical OR.
 */
or = func(...args) {
	return anyHorizontal(args...)
}


/**
 * Creates a window rank expression. Computes the rank of each row within its partition based on specified ordering.
 * The partition is defined by calling .over() on the resulting expression.
 * @param orderByExpressions - string|object|array - A single column name, an expression object, or an array of column names/expression objects to order by for ranking.
 * @param options - map (optional) - An optional map with options:
 *   - descending (boolean, optional): If true, ranks in descending order. Defaults to false.
 * @returns {object} - A window expression object for rank, which should be followed by .over() and then typically .alias().
 * @example
 *   // Rank scores descendingly within each category, naming the output column 'score_rank_in_category'
 *   pt.rank(pt.col("score"), {descending: true}).over(pt.col("category")).alias("score_rank_in_category")
 *
 *   // Rank using multiple columns for ordering (e.g. total_sales then product_id)
 *   // within each region, naming the output 'sales_rank_in_region'.
 *   // The 'descending: true' applies to both 'total_sales' and 'product_id'.
 *   pt.rank([pt.col("total_sales"), pt.col("product_id")], {descending: true})
 *     .over(pt.col("region"))
 *     .alias("sales_rank_in_region")
 */
rank = func(orderByExpressions, ...options) {
	orderByVal := []
	descendingVal := false

	ll.assert(orderByExpressions != undefined, "rank() requires orderByExpressions (single expression/string or array of them).")
	orderByVal = _mapToExpressionStructList(orderByExpressions, "col")
	ll.assert(len(orderByVal) > 0, "rank() 'orderBy' list cannot be empty after processing arguments.")

	if len(options) > 0 {
		ll.assert(len(options) == 1, "rank() accepts at most one options map argument.")
		opsMap := options[0]
		ll.assert(is_map(opsMap), "Second argument to rank(), if provided, must be an options map.")
		if maps.containsKey(opsMap, "descending") {
			ll.assert(is_bool(opsMap.descending), "descending in options map must be a boolean")
			descendingVal = opsMap.descending
		}
	}

	return _newWindowExpression({
		type: "rank",
		orderBy: orderByVal,
		partitionBy: [],
		descending: descendingVal
	}, undefined, undefined)
}


_newWhenThenBuilder := func(currentClauses, currentWhenExprOrUndefined) {
	builderSelf := undefined
	builderSelf = ll.toStrict({
		/**
		 * Specifies the result expression if the preceding .when() condition is true.
		 * @param thenExpr - object - An expression object for the result.
		 * @returns {object} - A builder object with .when() and .otherwise() methods.
		 */
		then: func(thenExpr) {
			ll.assert(currentWhenExprOrUndefined != undefined, ".then() must follow a .when() or initial when() call.")
			ll.assert(_isExpression(thenExpr), ".then() expects an expression object argument.")

			// Create new list of clauses for the new builder state
			newClauses := maps.clone(currentClauses) // Deep copy existing clauses
			newClauses = append(newClauses, {
				when: currentWhenExprOrUndefined.getExpression(),
				then: thenExpr.getExpression()
			})

			// Return a new builder instance: clauses updated, currentWhenExpr is now undefined (ready for next .when or .otherwise)
			return _newWhenThenBuilder(newClauses, undefined)
		},
		/**
		 * Adds another condition to the chain.
		 * Must follow a .then() call.
		 * @param conditionExpr - object - An expression object that evaluates to a boolean.
		 * @returns {object} - A builder object with a .then() method.
		 */
		when: func(conditionExpr) {
			ll.assert(currentWhenExprOrUndefined == undefined, ".when() must follow a .then() call.")
			ll.assert(_isExpression(conditionExpr), ".when() expects an expression object argument.")

			// Return a new builder instance: clauses remain the same (copied in next call), new currentWhenExpr
			// Pass currentClauses directly as it will be deepCopied by the next .then() or by .otherwise()
			return _newWhenThenBuilder(currentClauses, conditionExpr)
		},
		/**
		 * Specifies the default result expression if none of the preceding .when() conditions are true.
		 * Must follow a .then() call and at least one .when().then() clause.
		 * @param otherwiseExpr - object - An expression object for the default result.
		 * @returns {object} - The final expression object representing the when-then-otherwise logic.
		 */
		otherwise: func(otherwiseExpr) {
			ll.assert(currentWhenExprOrUndefined == undefined, ".otherwise() must follow a .then() call.")
			ll.assert(len(currentClauses) > 0, "At least one .when().then() clause is required before .otherwise().")
			ll.assert(_isExpression(otherwiseExpr), ".otherwise() expects an expression object argument.")

			// Final expression construction, ensure to use a deep copy of clauses for safety
			finalClauses := maps.clone(currentClauses)
			return _newExpression({
				type: "when_then_otherwise",
				conditions: finalClauses,
				otherwise: otherwiseExpr.getExpression()
			}, undefined)
		}
	})
	return builderSelf
}

/**
 * Starts a conditional expression, similar to a case-when statement.
 * Use .then(), .when(), and .otherwise() to build the full conditional logic.
 * @param conditionExpr - object - An expression object that evaluates to a boolean.
 * @returns {object} - A builder object with .then() method.
 * @example
 *   when(col("score").gt(90)).then(lit("A"))
 *     .when(col("score").gt(80)).then(lit("B"))
 *     .otherwise(lit("C"))
 */
when = func(conditionExpr) {
	ll.assert(_isExpression(conditionExpr), "Initial when() expects an expression object argument.")
	return _newWhenThenBuilder([], conditionExpr)
}

/**
 * Creates an expression object from a raw PTabler expression structure.
 * Useful for advanced use cases or for expression types not yet covered by dedicated helper functions.
 * The structure should conform to the PTabler expression schema.
 * @param expression - map - The raw PTabler expression definition map.
 * @param alias - string (optional) - An optional alias for this expression.
 * @returns {object} - An expression object.
 * @example
 *   rawExp({type: "col", name: "my_column"}, "optional_alias")
 *   rawExp({type: "plus", lhs: col("a").getExpression(), rhs: lit(1).getExpression()})
 */
rawExp := func(expression, ...alias) {
	ll.assert(len(alias) <= 1, "rawExpression expects at most one alias argument")
	aliasVal := undefined
	if len(alias) > 0 {
		aliasVal = alias[0]
	}
	ll.assert(is_map(expression), "rawExpression expects a map as argument")
	return _newExpression(expression, aliasVal)
}

export ll.toStrict({
	col: col,
	lit: lit,
	concatStr: concatStr,
	minHorizontal: minHorizontal,
	maxHorizontal: maxHorizontal,
	allHorizontal: allHorizontal,
	anyHorizontal: anyHorizontal,
	and: and, // Top-level alias for allHorizontal
	or: or,   // Top-level alias for anyHorizontal
	rank: rank,
	when: when,
	rawExp: rawExp,
	_isExpression: _isExpression,
	_isAggregation: _isAggregation,
	_mapToExpressionStructList: _mapToExpressionStructList,
	_mapToSingleExpressionStruct: _mapToSingleExpressionStruct
})
