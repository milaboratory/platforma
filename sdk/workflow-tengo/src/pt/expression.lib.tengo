ll := import(":ll")
maps := import(":maps")
slices := import(":slices")
validation := import(":validation")
fmt := import("fmt")
objects := import(":objects")
pframesSpec := import(":pframes.spec")


// Forward declarations
_newExpression := undefined
_newWindowExpression := undefined
axis := undefined
col := undefined
lit := undefined
allHorizontal := undefined
anyHorizontal := undefined
and := undefined
or := undefined
when := undefined
rank := undefined



// Helper function to validate options using validation library
_validateOptions := func(options, schema, functionName) {
	if len(options) > 1 {
		ll.panic("%s accepts at most one options map argument.", functionName)
	}
	if len(options) == 0 {
		return {}
	}

	opsMap := options[0]
	ll.assert(is_map(opsMap), "Options argument to %s(), if provided, must be an options map.", functionName)

	validation.assertType(opsMap, schema, fmt.sprintf("%s options validation error", functionName))
	return opsMap
}

// Helper function to check if an item is a valid expression object
_isExpression := func(item) {
	return ll.isMap(item) && ll.methodExists(item, "_getExpression")
}

// Helper function to check if an item is a valid aggregation object
_isAggregation := func(item) {
	return ll.isMap(item) && ll.methodExists(item, "_getAggregation")
}

// Helper function to map string column names or expression objects to their JSON structure
_mapToExpressionStructList := func(itemsList, stringInterpretation, ctx) {
	if !is_array(itemsList) {
		itemsList = [itemsList] // Allow single item to be passed
	}
	if stringInterpretation != "col" && stringInterpretation != "lit" {
		ll.panic("Invalid stringInterpretation ('%v') for _mapToExpressionStructList. Must be 'col' or 'lit'.", stringInterpretation)
		return undefined // Unreachable
	}
	return slices.map(itemsList, func(item) {
		if is_string(item) {
			if stringInterpretation == "col" {
				return col(item)._getExpression(ctx)
			} else { // Must be "lit" due to the check above
				return lit(item)._getExpression(ctx)
			}
		} else if _isExpression(item) {
			return item._getExpression(ctx)
		} else {
			ll.panic("Invalid item type in list: %T. Must be a string (interpreted as '%s') or an expression object.", item, stringInterpretation)
			return undefined // Unreachable
		}
	})
}

_mapToSingleExpressionStruct := func(item, stringInterpretation, ctx) {
	if _isExpression(item) {
		return item._getExpression(ctx)
	} else if is_int(item) || is_float(item) || is_bool(item) { // These are always literals
		return lit(item)._getExpression(ctx)
	} else if is_string(item) {
		if stringInterpretation == "col" {
			return col(item)._getExpression(ctx)
		} else if stringInterpretation == "lit" {
			return lit(item)._getExpression(ctx)
		} else { // stringInterpretation is undefined or an invalid value
			ll.panic("String item '%v' provided, but its interpretation as 'col' or 'lit' was not specified or is not applicable in this context. (stringInterpretation: '%v')", item, stringInterpretation)
			return undefined
		}
	} else {
		ll.panic("Invalid item type: %T. Expected an expression, literal (number, bool, null), or string (with 'col'/'lit' interpretation).", item)
		return undefined
	}
}

/**
 * @param expression - WindowExpression - ptabler window expression
 * @param aggregation - Aggregation - ptabler aggregation
 * @param currentAlias - string - The alias to use for the expression if passed to steps like withColumns
 * @returns {object} - The expression object.
 */
_newWindowExpression = func(expression, aggregation, currentAlias) {
	self := undefined
	self = ll.toStrict({
		/**
		 * Returns the underlying PTabler expression structure.
		 * @param ctx - map - Expression evaluation context
		 */
		_getExpression: func(ctx) {
			ll.assert(is_map(ctx), "ctx must be a map")
			ll.assert(!is_undefined(expression), "Using this operation as a window expression is not allowed. Use it as a group by expression instead. %v", aggregation)
			ll.assert(!is_undefined(currentAlias), "Alias is not defined for this window expression.")

			valueExpr := expression(ctx)
			return {type: "alias", value: valueExpr, name: currentAlias}
		},
		/** Returns the aggregation for group by operations. */
		_getAggregation: func(ctx) {
			if aggregation == undefined {
				ll.panic("Using this operation as a group by expression is not allowed, most probably because you applied .over() to it. %v", expression)
			}
			if currentAlias == undefined {
				ll.panic("Alias is not defined for this window expression.")
			}
			aggStruct := aggregation(ctx)
			return maps.deepMerge(aggStruct, {name: currentAlias})
		},

		/**
		 * Sets an alias for this window expression.
		 * The alias is used as the column name when this expression defines a new column in operations like `select` or `withColumns` (often after an `.over()` call).
		 * @param newAlias - string - The new alias, which will be the column name.
		 * @returns {object} - A new window expression object with the updated alias.
		 */
		alias: func(newAlias) {
			ll.assert(is_string(newAlias), "alias must be a string")
			return _newWindowExpression(expression, aggregation, newAlias)
		},

		/**
		 * Defines the partitioning for the window expression.
		 * @param partitionBy - string|object|array - A column name, an expression object, or an array of column names/expression objects to partition by.
		 * @returns {object} - A new window expression object with the partitioning defined.
		 */
		over: func(partitionBy) {
			ll.assert(is_array(partitionBy) || is_string(partitionBy) || _isExpression(partitionBy), "partitionBy must be an array of strings/expressions or a single string/expression")

			// Create a materialization lambda for the new expression
			newExpr := func(ctx) {
				baseExpr := expression(ctx)

				if len(baseExpr.partitionBy) > 0 {
					ll.warn("partitionBy already set on this window expression, overriding.")
				}

				return maps.deepMerge(baseExpr, {
					partitionBy: _mapToExpressionStructList(partitionBy, "col", ctx)
				})
			}

			return _newWindowExpression(newExpr, undefined, currentAlias)
		}
	})
	return self
}

/**
 * @param expression - Expression - ptabler expression
 * @returns {object} - The expression object.
 */
_newExpression = func(expression) {
	self := undefined // forward declaration

	// Helper for binary operations
	binaryOp := func(opType, other) {
		return _newExpression(
			func(ctx) {
				lhsExpr := self._getExpression(ctx)
				rhsExpr := undefined
				if _isExpression(other) {
					rhsExpr = other._getExpression(ctx)
				} else if is_int(other) || is_float(other) || is_bool(other) || is_string(other) {
					rhsExpr = lit(other)._getExpression(ctx)
				} else {
					ll.panic(opType + " expects an expression object or a literal (number, boolean, null) as argument. Got type: %T", other)
				}
				return {type: opType, lhs: lhsExpr, rhs: rhsExpr}
			}
		)
	}

	// Helper for unary operations
	unaryOp := func(opType) {
		return _newExpression(
			func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {type: opType, value: valueExpr}
			}
		)
	}

	// Helper for string unary operations (operates on `value.str`)
	unaryStrOp := func(opType) {
		return _newExpression(
			func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {type: opType, value: valueExpr}
			}
		)
	}

	// Helper for aggregation functions that return a WindowExpression
	aggOp := func(aggType) {
		return _newWindowExpression(
			func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {type: "aggregate", aggregation: aggType, value: valueExpr, partitionBy: []}
			},
			func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {aggregation: aggType, expression: valueExpr}
			},
			undefined // Alias of underlying col, window expression itself is typically aliased later
		)
	}

	aggOpBy := func(aggType, by) {
		return _newWindowExpression(
			undefined,
			func(ctx) {
				baseExpr := self._getExpression(ctx)
				return {aggregation: aggType, expression: baseExpr, by: _mapToExpressionStructList(by, "col", {})}
			},
			undefined // Alias of underlying col, window expression itself is typically aliased later
		)
	}

	self = ll.toStrict({
		/** Returns the underlying PTabler expression structure. */
		_getExpression: func(ctx) {
			ll.assert(is_map(ctx), "ctx must be a map")
			return expression(ctx)
		},
		/**
		 * Sets an alias for this expression.
		 * The alias is used as the column name when this expression is used to define a new column in operations like `select` or `withColumns`.
		 * @param newAlias - string - The new alias, which will be the column name.
		 * @returns {object} - A new expression object with the updated alias.
		 */
		alias: func(newAlias) {
			return _newExpression(func (ctx) {
				valueExpr := self._getExpression(ctx)
				return {type: "alias", value: valueExpr, name: newAlias}
			})
		},

		// Comparison
		/** Checks if this expression is greater than another. Raw literal values can be used directly, e.g., `expr.gt(2)`. */
		gt: func(other) { return binaryOp("gt", other) },
		/** Checks if this expression is greater than or equal to another. Raw literal values can be used directly, e.g., `expr.ge(2)`. */
		ge: func(other) { return binaryOp("ge", other) },
		/** Checks if this expression is equal to another. Raw literal values can be used directly, e.g., `expr.eq(2)`. */
		eq: func(other) { return binaryOp("eq", other) },
		/** Checks if this expression is less than another. Raw literal values can be used directly, e.g., `expr.lt(2)`. */
		lt: func(other) { return binaryOp("lt", other) },
		/** Checks if this expression is less than or equal to another. Raw literal values can be used directly, e.g., `expr.le(2)`. */
		le: func(other) { return binaryOp("le", other) },
		/** Checks if this expression is not equal to another. Raw literal values can be used directly, e.g., `expr.neq(2)`. */
		neq: func(other) { return binaryOp("neq", other) },

		// Arithmetic
		/** Adds another expression to this expression. Raw literal values can be used directly, e.g., `expr.plus(2)`. */
		plus: func(other) { return binaryOp("plus", other) },
		/** Subtracts another expression from this expression. Raw literal values can be used directly, e.g., `expr.minus(2)`. */
		minus: func(other) { return binaryOp("minus", other) },
		/** Multiplies this expression by another. Raw literal values can be used directly, e.g., `expr.multiply(2)`. */
		multiply: func(other) { return binaryOp("multiply", other) },
		/** Performs true division of this expression by another. Raw literal values can be used directly, e.g., `expr.truediv(2)`. */
		truediv: func(other) { return binaryOp("truediv", other) },
		/** Performs floor division of this expression by another. Raw literal values can be used directly, e.g., `expr.floordiv(2)`. */
		floordiv: func(other) { return binaryOp("floordiv", other) },

		/** Computes the base-10 logarithm of this expression. */
		log10: func() { return unaryOp("log10") },
		/** Computes the natural logarithm of this expression. */
		log: func() { return unaryOp("log") },
		/** Computes the base-2 logarithm of this expression. */
		log2: func() { return unaryOp("log2") },
		/** Computes the absolute value of this expression. */
		abs: func() { return unaryOp("abs") },
		/** Computes the square root of this expression. */
		sqrt: func() { return unaryOp("sqrt") },
		/** Negates this expression. */
		negate: func() { return unaryOp("negate") },
		/** Computes the floor of this expression. */
		floor: func() { return unaryOp("floor") },
		/** Rounds this expression to the nearest integer. */
		round: func() { return unaryOp("round") },
		/** Computes the ceiling of this expression. */
		ceil: func() { return unaryOp("ceil") },

		// Cast

		/**
		 * Casts this expression to a different data type.
		 * @param dtype - string - The target data type. Supported types: 'Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'Boolean', 'String', 'Date', 'Datetime', 'Time', 'Int', 'Long', 'Float', 'Double'.
		 * @param options - map (optional) - An optional map with options:
		 *   - strict (boolean, optional): If true, casting errors will panic. Defaults to false (errors result in null).
		 * @returns {object} - A new expression object representing the cast operation.
		 */
		cast: func(dtype, ...options) {
			ops := _validateOptions(options, {
				"__options__,closed": "",
				"strict,?": "bool"
			}, "cast")
			strictVal := false
			if !is_undefined(ops.strict) {
				strictVal = ops.strict
			}
			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {type: "cast", value: valueExpr, dtype: dtype, strict: strictVal}
			})
		},

		// Boolean
		/** Performs a logical AND with another expression. Alias for top-level `allHorizontal`. */
		and: func(other) {
			ll.assert(_isExpression(other), "and method expects an expression object as argument")
			return allHorizontal(self, other) // Refer to top-level function
		},
		/** Performs a logical OR with another expression. Alias for top-level `anyHorizontal`. */
		or: func(other) {
			ll.assert(_isExpression(other), "or method expects an expression object as argument")
			return anyHorizontal(self, other) // Refer to top-level function
		},
		/** Performs a logical NOT on this expression. */
		not: func() {
			return unaryOp("not")
		},

		// Null checks
		/** Checks if this expression is null. */
		isNull: func() { return unaryOp("is_na") }, // Polars: is_null(), TS: is_na
		/** Checks if this expression is not null. */
		isNotNull: func() { return unaryOp("is_not_na") }, // Polars: is_not_null(), TS: is_not_na

		// Struct operations
		/**
		 * Extracts field(s) from this struct expression, supporting nested path access.
		 * Used for accessing nested data structures like JSON objects.
		 *
		 * Performance characteristics:
		 * - Uses native Polars struct.field() when both dtype and default are omitted for optimal performance
		 * - Falls back to Python UDF (map_elements) when dtype casting or default values are specified,
		 *   providing robust handling of inconsistent schemas and missing fields at the cost of performance
		 *
		 * @param fieldPath - string|array - A single field name (string) or an array of field names for nested path access.
		 * @param options - map (optional) - An optional map with options:
		 *   - default (string|number|boolean|null, optional): Default value to return if field is missing/null. Triggers slower UDF mode.
		 *   - dtype (string, optional): Target data type for type casting. Triggers slower UDF mode. Supported: 'Boolean', 'String', 'Int', 'Long', 'Float', 'Double'.
		 * @returns {object} - A new expression object representing the extracted field(s).
		 * @example
		 *   // Extract 'country' field from location struct (fast, native Polars)
		 *   col("location").structField("country")
		 *
		 *   // Access deeply nested field using array path: location.coordinates.lat (fast, native Polars)
		 *   col("location").structField(["coordinates", "lat"])
		 *
		 *   // With default value for missing fields (slower, Python UDF)
		 *   col("location").structField("elevation", {default: 0})
		 *
		 *   // With type casting and default (slower, Python UDF)
		 *   col("metadata").structField("timestamp", {default: "2023-01-01T00:00:00Z", dtype: "String"})
		 *
		 *   // Nested path with default and type casting (slower, Python UDF)
		 *   col("location").structField(["coordinates", "altitude"], {default: 100.0, dtype: "Float64"})
		 */
		structField: func(fieldPath, ...options) {
			// Validate fieldPath
			ll.assert(!is_undefined(fieldPath), "structField expects a field path (string or array of strings)")

			fields := undefined
			if is_string(fieldPath) {
				fields = fieldPath
			} else if is_array(fieldPath) {
				ll.assert(len(fieldPath) > 0, "structField field path array cannot be empty")
				for fieldName in fieldPath {
					ll.assert(is_string(fieldName), "All field names in path must be strings, got: %T", fieldName)
				}
				if len(fieldPath) == 1 {
					fields = fieldPath[0]
				} else {
					fields = fieldPath
				}
			} else {
				ll.panic("structField fieldPath must be a string or array of strings, got: %T", fieldPath)
			}

			// Validate and process options
			ops := _validateOptions(options, {
				"__options__,closed": "",
				"default,?": "any",
				"dtype,?": "string"
			}, "structField")

			// Build the struct field expression with new features
			return _newExpression(func(ctx) {
				structExpr := {
					type: "struct_field",
					struct: self._getExpression(ctx),
					fields: fields
				}

				// Add optional parameters if provided
				if !is_undefined(ops.default) {
					structExpr.default = ops.default
				}
				if !is_undefined(ops.dtype) {
					structExpr.dtype = ops.dtype
				}

				return structExpr
			})
		},

		// String operations
		/** Converts this string expression to uppercase. */
		strToUpper: func() { return unaryStrOp("to_upper") },
		/** Converts this string expression to lowercase. */
		strToLower: func() { return unaryStrOp("to_lower") },
		/** Computes the length of this string expression in characters. */
		strLenChars: func() { return unaryStrOp("str_len")},

		/**
		 * Extracts a substring from this string expression.
		 * @param start - int|string|Expr - The starting index (0-based). Can be a literal integer, column name (string), or expression object.
		 * @param args - int|string|Expr|map (optional) - Either:
		 *   - A length value (integer, column name, or expression object) for the substring length
		 *   - A map with either 'length' or 'end' key:
		 *     - length: int|string|Expr - The length of the substring
		 *     - end: int|string|Expr - The index before which to end the substring (exclusive)
		 * @returns {object} - A new expression object representing the substring.
		 */
		strSlice: func(start, ...args) {
			ll.assert(len(args) <= 1, "strSlice expects at most one additional argument.")

			length := undefined
			end := undefined
			if len(args) > 0 {
				arg := args[0]
				if is_map(arg) {
					ops := _validateOptions([arg], {
						"__options__,closed": "",
						"length,?": "any",
						"end,?": "any"
					}, "strSlice")
					if ops.length != undefined && ops.end != undefined {
						ll.panic("strSlice cannot have both 'length' and 'end' options.")
					}
					if !is_undefined(ops.length) {
						length = ops.length
					}
					if !is_undefined(ops.end) {
						end = ops.end
					}
				} else {
					length = arg
				}
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				expr := {
					type: "substring",
					value: valueExpr,
					start: _mapToSingleExpressionStruct(start, "col", ctx)
				}

				if !is_undefined(length) {
					expr.length = _mapToSingleExpressionStruct(length, "col", ctx)
				}
				if !is_undefined(end) {
					expr.end = _mapToSingleExpressionStruct(end, "col", ctx)
				}

				return expr
			})
		},

		/**
		 * Replaces occurrences of a pattern in this string expression with a replacement string.
		 * @param pattern - string|object - The pattern (string literal, regex, or an expression object evaluating to a string) to search for.
		 * @param replacement - string|object - The replacement string (string literal or an expression object evaluating to a string). Can use $n or ${name} for regex capture groups.
		 * @param options - map (optional) - An optional map with options:
		 *   - replaceAll (boolean, optional): If true, replace all occurrences. Defaults to false (replace first).
		 *   - literal (boolean, optional): If true, treat pattern as a literal string. Defaults to false (pattern is regex).
		 * @returns {object} - A new expression object representing the replacement.
		 */
		strReplace: func(pattern, replacement, ...options) {
			ops := _validateOptions(options, {
				"__options__,closed": "",
				"replaceAll,?": "bool",
				"literal,?": "bool"
			}, "strReplace")
			replaceAllVal := false
			literalVal := false

			if !is_undefined(ops.replaceAll) {
				replaceAllVal = ops.replaceAll
			}
			if !is_undefined(ops.literal) {
				literalVal = ops.literal
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_replace",
					value: valueExpr,
					pattern: _mapToSingleExpressionStruct(pattern, "lit", ctx),
					replacement: _mapToSingleExpressionStruct(replacement, "lit", ctx),
					replaceAll: replaceAllVal,
					literal: literalVal
				}
			})
		},

		/**
		 * Replaces all occurrences of a pattern in this string expression with a replacement string.
		 * @param pattern - string|object - The pattern (string literal, regex, or an expression object evaluating to a string) to search for.
		 * @param replacement - string|object - The replacement string (string literal or an expression object evaluating to a string). Can use $n or ${name} for regex capture groups.
		 * @param options - map (optional) - An optional map with options:
		 *   - literal (boolean, optional): If true, treat pattern as a literal string. Defaults to false (pattern is regex).
		 * @returns {object} - A new expression object representing the replacement.
		 */
		strReplaceAll: func(pattern, replacement, ...options) {
			opts := {}
			if len(options) > 0 {
				opts = options[0]
			}
			opts.replaceAll = true
			return self.strReplace(pattern, replacement, opts)
		},

		/**
		 * Checks if this string expression contains the specified pattern.
		 * @param pattern - string|object - The pattern (string literal, regex, or an expression object evaluating to a string) to search for.
		 * @param options - map (optional) - An optional map with options:
		 *   - literal (boolean, optional): If true, treat pattern as a literal string. Defaults to false (pattern is regex).
		 *   - strict (boolean, optional): If true, raise error for invalid regex. Defaults to true.
		 * @returns {object} - A boolean expression object.
		 */
		strContains: func(pattern, ...options) {
			ops := _validateOptions(options, {
				"__options__,closed": "",
				"literal,?": "bool",
				"strict,?": "bool"
			}, "strContains")
			literalVal := false
			strictVal := true

			if !is_undefined(ops.literal) {
				literalVal = ops.literal
			}
			if !is_undefined(ops.strict) {
				strictVal = ops.strict
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_contains",
					value: valueExpr,
					pattern: _mapToSingleExpressionStruct(pattern, "lit", ctx),
					literal: literalVal,
					strict: strictVal
				}
			})
		},

		/**
		 * Checks if this string expression contains any of the provided patterns using the Aho-Corasick algorithm.
		 * @param patterns - array - An array of literal string patterns to search for.
		 * @param options - map (optional) - An optional map with options:
		 *   - asciiCaseInsensitive (boolean, optional): Enable ASCII case insensitive matching. Defaults to false.
		 * @returns {object} - A boolean expression object.
		 */
		strContainsAny: func(patterns, ...options) {
			ll.assert(is_array(patterns), "patterns must be an array of strings")
			for pattern in patterns {
				ll.assert(is_string(pattern), "all patterns must be strings")
			}

			ops := _validateOptions(options, {
				"__options__,closed": "",
				"asciiCaseInsensitive,?": "bool"
			}, "strContainsAny")
			asciiCaseInsensitiveVal := false
			if !is_undefined(ops.asciiCaseInsensitive) {
				asciiCaseInsensitiveVal = ops.asciiCaseInsensitive
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_contains_any",
					value: valueExpr,
					patterns: patterns,
					asciiCaseInsensitive: asciiCaseInsensitiveVal
				}
			})
		},

		/**
		 * Counts the number of times a pattern occurs in this string expression.
		 * @param pattern - string|object - The pattern (string literal, regex, or an expression object evaluating to a string) to count.
		 * @param options - map (optional) - An optional map with options:
		 *   - literal (boolean, optional): If true, treat pattern as a literal string. Defaults to false (pattern is regex).
		 * @returns {object} - A numeric expression object.
		 */
		strCountMatches: func(pattern, ...options) {
			ops := _validateOptions(options, {
				"__options__,closed": "",
				"literal,?": "bool"
			}, "strCountMatches")
			literalVal := false

			if !is_undefined(ops.literal) {
				literalVal = ops.literal
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_count_matches",
					value: valueExpr,
					pattern: _mapToSingleExpressionStruct(pattern, "lit", ctx),
					literal: literalVal
				}
			})
		},

		/**
		 * Extracts parts of this string expression using regex patterns and capture groups.
		 * @param pattern - string|object - The regex pattern (string literal or an expression object evaluating to a string) to extract with.
		 * @param options - map (optional) - An optional map with options:
		 *   - groupIndex (int, optional): The capture group index to extract. Group 0 is the entire match. Defaults to 0.
		 * @returns {object} - A string expression object.
		 */
		strExtract: func(pattern, ...options) {
			ops := _validateOptions(options, {
				"__options__,closed": "",
				"groupIndex,?": "number"
			}, "strExtract")
			groupIndexVal := 0

			if !is_undefined(ops.groupIndex) {
				groupIndexVal = ops.groupIndex
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_extract",
					value: valueExpr,
					pattern: _mapToSingleExpressionStruct(pattern, "lit", ctx),
					groupIndex: groupIndexVal
				}
			})
		},

		/**
		 * Checks if this string expression starts with the specified prefix.
		 * @param prefix - string|object - The literal prefix (string literal or an expression object evaluating to a string) to check for.
		 * @returns {object} - A boolean expression object.
		 */
		strStartsWith: func(prefix) {
			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_starts_with",
					value: valueExpr,
					prefix: _mapToSingleExpressionStruct(prefix, "lit", ctx)
				}
			})
		},

		/**
		 * Checks if this string expression ends with the specified suffix.
		 * @param suffix - string|object - The literal suffix (string literal or an expression object evaluating to a string) to check for.
		 * @returns {object} - A boolean expression object.
		 */
		strEndsWith: func(suffix) {
			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "str_ends_with",
					value: valueExpr,
					suffix: _mapToSingleExpressionStruct(suffix, "lit", ctx)
				}
			})
		},

		// Fuzzy string
		/**
		 * Computes the distance or similarity between this string expression and another.
		 * @param string2 - object - An expression object representing the second string.
		 * @param metric - string - The distance metric. Supported: 'levenshtein', 'optimal_string_alignment', 'jaro_winkler'.
		 * @param returnSimilarity - boolean (optional) - If true, returns similarity (0-1). Defaults to false (returns distance). Jaro-Winkler always returns similarity.
		 * @returns {object} - A new expression object.
		 */
		strDistance: func(string2, metric, returnSimilarity) {
			ll.assert(_isExpression(string2), "string2 must be an expression object")
			ll.assert(is_string(metric), "metric must be a string")

			returnSimilarityVal := false
			if returnSimilarity != undefined {
				ll.assert(is_bool(returnSimilarity), "returnSimilarity must be a boolean")
				returnSimilarityVal = returnSimilarity
			}

			return _newExpression(func(ctx) {
				lhsExpr := self._getExpression(ctx)
				rhsExpr := string2._getExpression(ctx)
				return {
					type: "string_distance",
					string1: lhsExpr,
					string2: rhsExpr,
					metric: metric,
					returnSimilarity: returnSimilarityVal
				}
			})
		},

		/**
		 * Filters strings based on fuzzy matching against a pattern.
		 * Returns true if the distance between this string expression and the pattern is within the bound.
		 * @param patternExpr - object - An expression object representing the pattern string.
		 * @param metric - string - The distance metric. Supported: 'levenshtein', 'hamming'.
		 * @param bound - number - The maximum allowed distance for a match (inclusive).
		 * @returns {object} - A boolean expression object.
		 */
		fuzzyFilter: func(patternExpr, metric, bound) {
			ll.assert(_isExpression(patternExpr), "patternExpr must be an expression object")
			ll.assert(is_string(metric), "metric must be a string")
			ll.assert(is_int(bound) || is_float(bound), "bound must be a number")

			return _newExpression(func(ctx) {
				lhsExpr := self._getExpression(ctx)
				rhsExpr := patternExpr._getExpression(ctx)
				return {
					type: "fuzzy_string_filter",
					value: lhsExpr,
					pattern: rhsExpr,
					metric: metric,
					bound: bound
				}
			})
		},

		// Hash
		/**
		 * Computes a hash of this expression.
		 * @param hashType - string - The hash algorithm. Supported: 'sha256', 'sha512', 'md5', 'blake3', 'wyhash', 'xxh3'.
		 * @param encoding - string - The output encoding. Supported: 'hex', 'base64', 'base64_alphanumeric', 'base64_alphanumeric_upper'.
		 * @param bits - int (optional) - Minimum entropy bits for the output, affecting encoded string length.
		 * @returns {object} - A new expression object representing the hash.
		 */
		hash: func(hashType, encoding, bits) {
			ll.assert(is_string(hashType), "hashType must be a string")
			ll.assert(is_string(encoding), "encoding must be a string")
			if bits != undefined {
				ll.assert(is_int(bits), "bits must be a number")
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				hashExpr := {
					type: "hash",
					value: valueExpr,
					hashType: hashType,
					encoding: encoding
				}
				if bits != undefined {
					hashExpr.bits = bits
				}
				return hashExpr
			})
		},

		// Conditional
		/**
		 * Fills null values in this expression with a specified value.
		 * @param fillValueExpr - object - An expression object whose value is used if this expression is null.
		 * @returns {object} - A new expression object.
		 */
		fillNull: func(fillValueExpr) {
			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "fill_null",
					input: valueExpr,
					fillValue: _mapToSingleExpressionStruct(fillValueExpr, "lit", ctx)
				}
			})
		},

		/**
		 * Fills NaN values in this expression with a specified value.
		 * @param fillValueExpr - object - An expression object whose value is used if this expression is NaN.
		 * @returns {object} - A new expression object.
		 */
		fillNaN: func(fillValueExpr) {
			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "fill_nan",
					input: valueExpr,
					fillValue: _mapToSingleExpressionStruct(fillValueExpr, "lit", ctx)
				}
			})
		},

		// Window/Aggregations
		/** Computes the sum of this expression over a window. Requires .over() to define the window. */
		sum: func() { return aggOp("sum") },
		/** Computes the mean of this expression over a window. Requires .over() to define the window. */
		mean: func() { return aggOp("mean") },
		/** Computes the median of this expression over a window. Requires .over() to define the window. */
		median: func() { return aggOp("median") },
		/** Computes the minimum of this expression over a window. Requires .over() to define the window. */
		min: func() { return aggOp("min") },
		/** Computes the maximum of this expression over a window. Requires .over() to define the window. */
		max: func() { return aggOp("max") },
		/** Computes the standard deviation of this expression over a window. Requires .over() to define the window. */
		std: func() { return aggOp("std") },
		/** Computes the variance of this expression over a window. Requires .over() to define the window. */
		var: func() { return aggOp("var") },
		/** Counts the non-null values of this expression over a window. Requires .over() to define the window. */
		count: func() { return aggOp("count") },
		/** Gets the first value of this expression over a window. Requires .over() to define the window. */
		first: func() { return aggOp("first") },
		/** Gets the last value of this expression over a window. Requires .over() to define the window. */
		last: func() { return aggOp("last") },
		/** Counts the number of unique values of this expression over a window. Requires .over() to define the window. */
		nUnique: func() { return aggOp("n_unique") },

		/** Computes the value of this expression, when by expression is maximized. Can only be used as a group by context. */
		maxBy: func(...by) { return aggOpBy("max_by", by) },
		/** Computes the value of this expression, when by expression is minimized. Can only be used as a group by context. */
		minBy: func(...by) { return aggOpBy("min_by", by) },

		/**
		 * Computes the rank of this expression within a window. Requires .over() to define the window partition.
		 * The ordering for the rank is based on this expression itself.
		 * @param descendingArgs - boolean (optional) - If true, ranks in descending order. Defaults to false.
		 * @returns {object} - A window expression object, which needs .over() to be called.
		 */
		rank: func(...descendingArgs) {
			ll.assert(len(descendingArgs) <= 1, "rank method expects at most one optional boolean argument for descending.")
			descendingVal := false
			if len(descendingArgs) == 1 {
				ll.assert(is_bool(descendingArgs[0]), "descending argument for rank must be a boolean")
				descendingVal = descendingArgs[0]
			}
			return _newWindowExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "rank",
					orderBy: [valueExpr],
					partitionBy: [], // To be set by .over()
					descending: descendingVal
				}
			}, undefined)
		},

		/**
		 * Computes the cumulative sum of this expression within a window. Requires .over() to define the window partition.
		 * Values are sorted by this expression's value, then by 'orderBy' expressions before summing.
		 * @param args - varargs - Can be:
		 *   - (orderBy: string|object|array, descending: boolean (optional))
		 *   - (descending: boolean (optional))
		 *   - (options: map {orderBy?: string|object|array, descending?: boolean})
		 *   orderBy: Additional expressions to sort by within the window before cumsum.
		 *   descending: If true, sorts in descending order. Applies to both this expression and 'orderBy' expressions.
		 * @returns {object} - A window expression object, which needs .over() to be called.
		 */
		cumsum: func(...args) {
			additionalOrderByVal := []
			descendingVal := false
			actualArgs := args

			if len(args) > 0 && is_map(args[len(args)-1]) && !(_isExpression(args[len(args)-1])) {
				ops := _validateOptions([args[len(args)-1]], {
					"__options__,closed": "",
					"orderBy,?": "any",
					"descending,?": "bool"
				}, "cumsum")
				actualArgs = args[0:len(args)-1]
				if !is_undefined(ops.orderBy) {
					if is_array(ops.orderBy) {
						additionalOrderByVal = ops.orderBy
					} else {
						additionalOrderByVal = [ops.orderBy]
					}
				}
				if !is_undefined(ops.descending) {
					descendingVal = ops.descending
				}
			}

			// Process remaining actualArgs if not handled by options map
			if len(additionalOrderByVal) == 0 && len(actualArgs) > 0 {
				if is_array(actualArgs[0]) || is_string(actualArgs[0]) || _isExpression(actualArgs[0]) {
					if is_array(actualArgs[0]) {
						additionalOrderByVal = actualArgs[0]
					} else {
						additionalOrderByVal = [actualArgs[0]]
					}
					if len(actualArgs) > 1 && is_bool(actualArgs[1]) {
						descendingVal = actualArgs[1]
					}
				} else if is_bool(actualArgs[0]) && len(additionalOrderByVal) == 0 { // only if not set by ops.orderBy
					descendingVal = actualArgs[0]
				} else if len(actualArgs) > 0 {
					ll.panic("Invalid arguments to cumsum. Expected order expressions or options map.")
				}
			}

			return _newWindowExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "cumsum",
					value: valueExpr,
					additionalOrderBy: _mapToExpressionStructList(additionalOrderByVal, "col", ctx),
					partitionBy: [],
					descending: descendingVal
				}
			}, undefined, undefined)
		},

		/** Converts the expression to a string. */
		toString: func() {
			return self.cast("string")
		},

		/**
		 * Boolean expression indicating if the parent expression row values are in a given set of values.
		 * @param ...values - varargs - The values to match against.
		 * @returns {object} - A boolean expression object.
		 */
		inSet: func(...values) {
			ll.assert(len(values) > 0, "inSet method requires at least one value.")

			set := []
			for v in values {
				ll.assert(
					is_undefined(v) || is_bool(v) || is_int(v) || is_float(v) || is_string(v),
					"Invalid argument in inSet: Expected primitive value, got %T", v)
				set = append(set, v)
			}
			uniqueSet := slices.sortUnique(set)

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "in_set",
					value: valueExpr,
					set: uniqueSet
				}
			})
		},

		/**
		 * Boolean expression indicating if the parent expression row values match a given ECMAScript regular expression.
		 * @param ecma_regex - string - The ECMAScript regular expression to match against.
		 * @returns {object} - A boolean expression object.
		 */
		matchesEcmaRegex: func(ecmaRegex) {
			ll.assert(is_string(ecmaRegex) && len(ecmaRegex) > 0, "ecma_regex must be a non-empty string.")

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return {
					type: "matches_ecma_regex",
					value: valueExpr,
					ecmaRegex: ecmaRegex
				}
			})
		},

		/**
		 * Boolean expression indicating if the parent expression row values contain a close match to a given reference string.
		 * @param reference - string - The reference string to compare against.
		 * @param maxEdits - number - The maximum number of edits allowed to be considered a match.
		 * @param ...args - varargs - Optional arguments map {wildcard?: string, substitutionsOnly?: boolean}:
		 *   - wildcard: string - The wildcard character to use.
		 *   - substitutionsOnly: boolean - If true, only substitutions are allowed (deletions and insertions are also allowed by default).
		 * @returns {object} - A boolean expression object.
		 */
		containsFuzzyMatch: func(reference, maxEdits, ...args) {
			ll.assert(is_string(reference) && len(reference) > 0, "pattern must be a non-empty string.")
			ll.assert(is_int(maxEdits) && maxEdits > 0, "maxEdits must be a positive integer.")

			wildcard := undefined
			substitutionsOnly := undefined
			if len(args) > 0 {
				ops := _validateOptions(args, {
					"__options__,closed": "",
					"wildcard,?": "string",
					"substitutionsOnly,?": "bool"
				}, "containsFuzzyMatch")
				if !is_undefined(ops.wildcard) {
					ll.assert(len(ops.wildcard) == 1, "wildcard must be a single character.")
				}
				wildcard = ops.wildcard
				substitutionsOnly = ops.substitutionsOnly
			}

			return _newExpression(func(ctx) {
				valueExpr := self._getExpression(ctx)
				return objects.deleteUndefined({
					type: "contains_fuzzy_match",
					value: valueExpr,
					reference: reference,
					maxEdits: maxEdits,
					wildcard: wildcard,
					substitutionsOnly: substitutionsOnly
				})
			})
		}
	})
	return self
}

//
// Top-level functions
//

/**
 * Creates an expression that references an axis by its spec.
 * @param matcher (string|map) - Identifies the axis.
 *   - If string: Interpreted as the axis `name`.
 *   - If map: It must be an AxisSpec-like object (minimally containing string fields 'name' and 'type').
 *             It will be processed by `pframesSpec.axisSpecToMatcher` to extract `name`, `type`, and `domain` for matching.
 *     The `domain` map allows matching axes with specific domain key-value pairs.
 *     Only discriminative domains (those that vary among columns added to the builder) are considered for matching.
 * @returns {object} - An expression object.
 */
axis = func(matcher) {
	processedMatcher := undefined
	if is_string(matcher) {
		processedMatcher = { name: matcher, domain: {} }
	} else if is_map(matcher) {
		processedMatcher = pframesSpec.axisSpecToMatcher(matcher)
	} else {
		ll.panic("Matcher for axis must be a string (axis name) or an AxisSpec-like map (with at least 'name' and 'type' fields).")
	}
	return _newExpression(func(ctx) {
		ll.assert(!is_undefined(ctx.specDistiller), "specDistiller must be defined")
		ll.assert(is_map(ctx.distilledAxesSpecs), "distilledAxesSpecs must be a map")

		distilledMatcher := ctx.specDistiller.distill(processedMatcher)
		discriminativeDomains := ctx.specDistiller.getDiscriminativeDomainsSet(distilledMatcher.name)
        if ((!is_undefined(distilledMatcher.domain) && len(distilledMatcher.domain) > 0) != (!is_undefined(discriminativeDomains) && len(discriminativeDomains) > 0)) ||
			(!is_undefined(distilledMatcher.domain) && !is_undefined(discriminativeDomains) && len(distilledMatcher.domain) != len(discriminativeDomains)) {
            ll.panic("Axis matcher %v is not specific enough. Expected discriminative domains %v, got %v", distilledMatcher.name, discriminativeDomains, distilledMatcher.domain)
        }
		
		axisSpec := undefined
		for spec in ctx.distilledAxesSpecs[distilledMatcher.name] {
			if !is_undefined(distilledMatcher.type) {
				if distilledMatcher.type != spec.type {
					continue
				}
			}
			if !is_undefined(distilledMatcher.domain) {
				if is_undefined(spec.domain) || len(spec.domain) < len(distilledMatcher.domain) {
					continue
				}
				for domainKey, domainValue in distilledMatcher.domain {
					if spec.domain[domainKey] != domainValue {
						continue
					}
				}
			}
			axisSpec = spec
			break
		}
		return {
			type: "axis",
			spec: axisSpec
		}
	}).alias(processedMatcher.name)
}

/**
 * Creates an expression that references a column by its name.
 * @param name - string - The name of the column.
 * @returns {object} - An expression object.
 */
col = func(name) {
	ll.assert(is_string(name), "col name must be a string")
	return _newExpression(func(ctx) {
		return {
			type: "col",
			name: name
		}
	})
}

/**
 * Creates an expression from a literal (constant) value.
 * @param value - any - The literal value (string, number, boolean, or null).
 * @returns {object} - An expression object.
 */
lit = func(value) {
	return _newExpression(func(ctx) {
		return {
			type: "const",
			value: value
		}
	})
}

/**
 * Concatenates string representations of multiple expressions, optionally separated by a delimiter.
 * @param expressions - array - An array of expression objects or string literals whose string representations will be joined.
 * @param options - map (optional) - An optional map with options:
 *   - delimiter (string, optional): The delimiter string to insert between joined elements. Defaults to "".
 * @returns {object} - An expression object.
 */
concatStr := func(expressions, ...options) {
	ll.assert(is_array(expressions), "First argument to concatStr must be an array of expressions")
	ll.assert(len(expressions) > 0, "Expression array for concatStr cannot be empty")

	ops := _validateOptions(options, {
		"__options__,closed": "",
		"delimiter,?": "string"
	}, "concatStr")
	delimiterVal := "" // Default to empty string
	if !is_undefined(ops.delimiter) {
		delimiterVal = ops.delimiter
	}

	return _newExpression(func(ctx) {
		return {
			type: "str_join",
			operands: _mapToExpressionStructList(expressions, "lit", ctx),
			delimiter: delimiterVal
		}
	})
}

/**
 * Computes the element-wise minimum across an array of expressions.
 * @param expressions - array - An array of expression objects or column names.
 * @returns {object} - An expression object representing the minimum.
 */
minHorizontal := func(expressions) {
	ll.assert(is_array(expressions), "Argument to minHorizontal must be an array of expressions")
	ll.assert(len(expressions) > 0, "Expression array for minHorizontal cannot be empty")
	return _newExpression(func(ctx) {
		return {
			type: "min",
			operands: _mapToExpressionStructList(expressions, "col", ctx)
		}
	})
}

/**
 * Computes the element-wise maximum across an array of expressions.
 * @param expressions - array - An array of expression objects or column names.
 * @returns {object} - An expression object representing the maximum.
 */
maxHorizontal := func(expressions) {
	ll.assert(is_array(expressions), "Argument to maxHorizontal must be an array of expressions")
	ll.assert(len(expressions) > 0, "Expression array for maxHorizontal cannot be empty")
	return _newExpression(func(ctx) {
		return {
			type: "max",
			operands: _mapToExpressionStructList(expressions, "col", ctx)
		}
	})
}

/**
 * Computes the element-wise logical AND across multiple boolean expressions.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical AND.
 */
allHorizontal = func(...args){
    return _newExpression(func(ctx) {
        processedOperands := []
        for arg in args {
            exprStruct := undefined
            if _isExpression(arg) {
                exprStruct = arg._getExpression(ctx)
            } else if is_string(arg) {
                exprStruct = col(arg)._getExpression(ctx)
            } else {
                ll.panic("Invalid argument type for allHorizontal: %T. Must be an expression object or string.", arg)
            }

            if exprStruct.type == "and" && is_array(exprStruct.operands) {
                processedOperands = append(processedOperands, exprStruct.operands...)
            } else {
                processedOperands = append(processedOperands, exprStruct)
            }
        }
        if len(processedOperands) == 0 {
            ll.panic("allHorizontal requires at least one expression.")
        }
        return {
            type: "and",
            operands: processedOperands
        }
    })
}

/**
 * Computes the element-wise logical OR across multiple boolean expressions.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical OR.
 */
anyHorizontal = func(...args){
    return _newExpression(func(ctx) {
        processedOperands := []
        for arg in args {
            exprStruct := undefined
            if _isExpression(arg) {
                exprStruct = arg._getExpression(ctx)
            } else if is_string(arg) {
                exprStruct = col(arg)._getExpression(ctx)
            } else {
                ll.panic("Invalid argument type for anyHorizontal: %T. Must be an expression object or string.", arg)
            }

            if exprStruct.type == "or" && is_array(exprStruct.operands) {
                processedOperands = append(processedOperands, exprStruct.operands...)
            } else {
                processedOperands = append(processedOperands, exprStruct)
            }
        }
        if len(processedOperands) == 0 {
            ll.panic("anyHorizontal requires at least one expression.")
        }
        return {
            type: "or",
            operands: processedOperands
        }
    })
}

/**
 * Computes the element-wise logical AND across multiple boolean expressions. Alias for allHorizontal.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical AND.
 */
and = func(...args) {
	return allHorizontal(args...)
}

/**
 * Computes the element-wise logical OR across multiple boolean expressions. Alias for anyHorizontal.
 * @param ...args - varargs - Expression objects or column names that resolve to booleans.
 * @returns {object} - An expression object representing the logical OR.
 */
or = func(...args) {
	return anyHorizontal(args...)
}


/**
 * Creates a window rank expression. Computes the rank of each row within its partition based on specified ordering.
 * The partition is defined by calling .over() on the resulting expression.
 * @param orderByExpressions - string|object|array - A single column name, an expression object, or an array of column names/expression objects to order by for ranking.
 * @param options - map (optional) - An optional map with options:
 *   - descending (boolean, optional): If true, ranks in descending order. Defaults to false.
 * @returns {object} - A window expression object for rank, which should be followed by .over() and then typically .alias().
 * @example
 *   // Rank scores descendingly within each category, naming the output column 'score_rank_in_category'
 *   pt.rank(pt.col("score"), {descending: true}).over(pt.col("category")).alias("score_rank_in_category")
 *
 *   // Rank using multiple columns for ordering (e.g. total_sales then product_id)
 *   // within each region, naming the output 'sales_rank_in_region'.
 *   // The 'descending: true' applies to both 'total_sales' and 'product_id'.
 *   pt.rank([pt.col("total_sales"), pt.col("product_id")], {descending: true})
 *     .over(pt.col("region"))
 *     .alias("sales_rank_in_region")
 */
rank = func(orderByExpressions, ...options) {
	orderByVal := []
	descendingVal := false

	ll.assert(orderByExpressions != undefined, "rank() requires orderByExpressions (single expression/string or array of them).")

	ops := _validateOptions(options, {
		"__options__,closed": "",
		"descending,?": "bool"
	}, "rank")
	if !is_undefined(ops.descending) {
		descendingVal = ops.descending
	}

	return _newWindowExpression(func(ctx) {
		orderByVal := _mapToExpressionStructList(orderByExpressions, "col", ctx)
		ll.assert(len(orderByVal) > 0, "rank() 'orderBy' list cannot be empty after processing arguments.")
		return {
			type: "rank",
			orderBy: orderByVal,
			partitionBy: [],
			descending: descendingVal
		}
	}, undefined, undefined)
}


_newWhenThenBuilder := func(currentClauses, currentWhenExprOrUndefined) {
	builderSelf := undefined
	builderSelf = ll.toStrict({
		/**
		 * Specifies the result expression if the preceding .when() condition is true.
		 * @param thenExpr - object - An expression object for the result.
		 * @returns {object} - A builder object with .when() and .otherwise() methods.
		 */
		then: func(thenExpr) {
			ll.assert(currentWhenExprOrUndefined != undefined, ".then() must follow a .when() or initial when() call.")
			ll.assert(_isExpression(thenExpr), ".then() expects an expression object argument.")

			// Create new list of clauses for the new builder state
			newClausesExpr := func(ctx) {
				existingClauses := currentClauses(ctx)
				newClauses := maps.clone(existingClauses) // Deep copy existing clauses
				return append(newClauses, {
					when: currentWhenExprOrUndefined._getExpression(ctx),
					then: thenExpr._getExpression(ctx)
				})
			}

			// Return a new builder instance: clauses updated, currentWhenExpr is now undefined (ready for next .when or .otherwise)
			return _newWhenThenBuilder(newClausesExpr, undefined)
		},
		/**
		 * Adds another condition to the chain.
		 * Must follow a .then() call.
		 * @param conditionExpr - object - An expression object that evaluates to a boolean.
		 * @returns {object} - A builder object with a .then() method.
		 */
		when: func(conditionExpr) {
			ll.assert(currentWhenExprOrUndefined == undefined, ".when() must follow a .then() call.")
			ll.assert(_isExpression(conditionExpr), ".when() expects an expression object argument.")

			// Return a new builder instance: clauses remain the same (copied in next call), new currentWhenExpr
			// Pass currentClauses directly as it will be deepCopied by the next .then() or by .otherwise()
			return _newWhenThenBuilder(currentClauses, conditionExpr)
		},
		/**
		 * Specifies the default result expression if none of the preceding .when() conditions are true.
		 * Must follow a .then() call and at least one .when().then() clause.
		 * @param otherwiseExpr - object - An expression object for the default result.
		 * @returns {object} - The final expression object representing the when-then-otherwise logic.
		 */
		otherwise: func(otherwiseExpr) {
			ll.assert(currentWhenExprOrUndefined == undefined, ".otherwise() must follow a .then() call.")
			ll.assert(_isExpression(otherwiseExpr), ".otherwise() expects an expression object argument.")

			// Final expression construction, ensure to use a deep copy of clauses for safety
			return _newExpression(func(ctx) {
				finalClauses := maps.clone(currentClauses(ctx))
				ll.assert(len(finalClauses) > 0, "At least one .when().then() clause is required before .otherwise().")
				return {
					type: "when_then_otherwise",
					conditions: finalClauses,
					otherwise: otherwiseExpr._getExpression(ctx)
				}
			})
		}
	})
	return builderSelf
}

/**
 * Starts a conditional expression, similar to a case-when statement.
 * Use .then(), .when(), and .otherwise() to build the full conditional logic.
 * @param conditionExpr - object - An expression object that evaluates to a boolean.
 * @returns {object} - A builder object with .then() method.
 * @example
 *   when(col("score").gt(90)).then(lit("A"))
 *     .when(col("score").gt(80)).then(lit("B"))
 *     .otherwise(lit("C"))
 */
when = func(conditionExpr) {
	ll.assert(_isExpression(conditionExpr), "Initial when() expects an expression object argument.")
	return _newWhenThenBuilder(func(ctx) { return [] }, conditionExpr)
}

/**
 * Creates an expression object from a raw PTabler expression structure.
 * Useful for advanced use cases or for expression types not yet covered by dedicated helper functions.
 * The structure should conform to the PTabler expression schema.
 * @param expression - map - The raw PTabler expression definition map.
 * @returns {object} - An expression object.
 * @example
 *   rawExp({type: "col", name: "my_column"})
 *   rawExp({type: "plus", lhs: {type: "col", name: "a"}, rhs: {type: "const", value: 1}})
 */
rawExp := func(expression) {
	ll.assert(is_map(expression), "rawExpression expects a map as argument")
	return _newExpression(func(ctx) { return expression })
}

export ll.toStrict({
	axis: axis,
	col: col,
	lit: lit,
	concatStr: concatStr,
	minHorizontal: minHorizontal,
	maxHorizontal: maxHorizontal,
	allHorizontal: allHorizontal,
	anyHorizontal: anyHorizontal,
	and: and, // Top-level alias for allHorizontal
	or: or,   // Top-level alias for anyHorizontal
	rank: rank,
	when: when,
	rawExp: rawExp,
	_newExpression: _newExpression,
	_isExpression: _isExpression,
	_isAggregation: _isAggregation,
	_mapToExpressionStructList: _mapToExpressionStructList,
	_mapToSingleExpressionStruct: _mapToSingleExpressionStruct
})
