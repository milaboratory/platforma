/**
 * A library that helps to create For Loop resources
 */
ll := import(":ll")
smart := import(":smart")
times := import("times")
maps := import(":maps")
sets := import(":sets")
slices := import(":slices")
path := import(":path")
render := import(":render")
enum := import("enum")
oop := import(":oop")
validation := import(":validation")
constants := import(":constants")
tplutil := import(":tpl.util")
json := import("json")

_MODE_NESTED := "nested"
_MODE_USUAL := "usual"
_RTYPE_FOR_LOOP := { Name: "ForLoop", Version: "1" }
_OUTPUTS_PREFIX := "outputs/"

_forLoopSettingsSchema := {
	outputNames: ["string"],
	bodyEphemeral: "bool",
	bodyResourceType: { "name": "string", "version": "string" },
	bodyData: ["or", "bytes", "null"],
	dynamicArgFieldName: "string",
	mode: `string,regex=nested|usual`,

	"nestedFieldName,omitempty": "string"
}

/**
 * Clients can create `ForLoop` resources with specific settings and input fields.
 * The controller then creates resources based on the given "schema" from these settings
 * and, for each output, generates a map with results corresponding to each dynamic argument.
 *
 * The `ForLoop` retrieves or creates a map for each output defined in the settings.
 * For example, if the body resource generates three outputs — `a`, `b`, and `c` —
 * the `ForLoop` resource will also have three outputs: `a`, `b`, and `c`.
 * However, each output will be a map containing results from different bodies,
 * such as `a/dynamicArg1`, `b/dynamicArg1`, `c/dynamicArg1`, etc.
 *
 * The `mode` specifies whether the `ForLoop` operates in a usual or nested mode:
 *
 *    - In the usual mode, all static arguments, along with the dynamic argument,
 *      are passed to the body as inputs.
 *
 *    - In the nested mode, all static arguments are passed to the body as inputs,
 *      except for the nested argument, which is a map. The dynamic arguments
 *      are set as inputs within this nested map, and then the nested map is passed to the body.
 *        - Think about `RenderTemplates` that use `inputMap` as arguments,
 *          where we need to set a dynamic argument within the `inputMap`.
 */
builder := func() {
	outputNames := []
	bodyEphemeral := false
	bodyResourceType := undefined
	bodyData := undefined
	dynamicArgFieldName := ""
	mode := _MODE_USUAL
	nestedFieldName := undefined

	dynamicArgs := {}
	staticArgs := {}
	outputs := []

	self := undefined
	self = ll.toStrict({
		/**
		 * Adds an output name to the list of output names.
		 *
		 * @param name: string - the name to be added.
		 */
		addOutputName: func(name) {
			ll.assert(is_string(name), "the name %q should be a string", name)
			outputNames = append(outputNames, name)
			return self
		},

		/**
		 * Adds multiple output names to the list of output names.
		 *
		 * @param names: []string - the names to be added.
		 */
		addOutputNames: func(names) {
			for _, name in names {
				self.addOutputName(name)
			}
			return self
		},

		/**
		 * Sets whether the body of the forloop must be ephemeral.
		 *
		 * @param isEphemeral: bool - indicates if the body is ephemeral.
		 */
		setEphemeral: func(isEphemeral) {
			ll.assert(is_bool(isEphemeral), "the flag isEphemeral should be bool")
			bodyEphemeral = isEphemeral
			return self
		},

		/**
		 * Sets the body resource type.
		 *
		 * @param resourceType: resourceType - the resource type to be set.
		 */
		setBodyResourceType: func(resourceType) {
			ll.assert(is_string(resourceType.Name) && is_string(resourceType.Version), "resourceType must be a resource type")
			bodyResourceType = resourceType
			return self
		},

		/**
		 * Sets the body data as bytes (they should be base64 encoded to string by tengo).
		 *
		 * @param data: bytes - the data to be set.
		 */
		setBodyData: func(data) {
			ll.assert(is_bytes(data), "the data should be bytes")
			bodyData = data
			return self
		},

		/**
		 * Sets how the field with the dynamic argument will be named in the body of the forloop.
		 *
		 * @param fieldName: string - the field name of the dynamic argument.
		 */
		setDynamicArgumentFieldName: func(fieldName) {
			ll.assert(is_string(fieldName), "the field name of the dynamic argument must be a string")
			dynamicArgFieldName = fieldName
			return self
		},

		/**
		 * Adds a dynamic argument by which the iteration should run.
		 *
		 * @param name: string - the name of the dynamic argument.
		 * @param value: any - the value of the dynamic argument.
		 */
		addDynamicArgument: func(name, value) {
			dynamicArgs[name] = value
			return self
		},

		/**
		 * Adds multiple dynamic arguments.
		 *
		 * @param nameToValue: map[string]any - a map of dynamic argument names to their values.
		 */
		addDynamicArgumentMap: func(nameToValue) {
			for name, value in nameToValue {
				self.addDynamicArgument(name, value)
			}
			return self
		},

		/**
		 * Adds a static argument that will be passed to the body as-is.
		 *
		 * @param name: string - the name of the static argument.
		 * @param value: any - the value of the static argument.
		 */
		addStaticArgument: func(name, value) {
			staticArgs[name] = value
			return self
		},

		/**
		 * Adds multiple static arguments.
		 *
		 * @param nameToValue: map[string]any - a map of static argument names to their values.
		 */
		addStaticArgumentMap: func(nameToValue) {
			for name, value in nameToValue {
				self.addStaticArgument(name, value)
			}
			return self
		},

		/**
		 * Sets the mode to "usual".
		 *
		 * @return self - The current builder instance.
		 */
		setUsualMode: func() {
			mode = _MODE_USUAL
			return self
		},

		/**
		 * Sets the mode to "nested" and sets the nested field name.
		 *
		 * @param fieldName: string - The name of the nested field.
		 * @return self - The current builder instance.
		 */
		setNestedMode: func(fieldName) {
			mode = _MODE_NESTED
			ll.assert(is_string(fieldName), "the name of the nested field must be a string")
			nestedFieldName = fieldName
			return self
		},

		/**
		 * Builds the For Loop resource.
		 *
		 * @return self - The built For Loop resource.
		 */
		build: func() {
			settings := {
				outputNames: outputNames,
				bodyEphemeral: bodyEphemeral,
				bodyResourceType: {
					name: bodyResourceType.Name,
					version: bodyResourceType.Version
				},
				bodyData: bodyData,
				dynamicArgFieldName: dynamicArgFieldName,
				mode: mode
			}
			if !is_undefined(nestedFieldName) {
				settings.nestedFieldName = nestedFieldName
			}
			validation.assertJsonSchema(settings, _forLoopSettingsSchema)

			res := smart.ephemeralBuilder(_RTYPE_FOR_LOOP, json.encode(settings))
			res.createInputField("staticArgs").setRefOrJson(smart.createMapResource(staticArgs))
			res.createInputField("dynamicArgs").set(smart.createMapResource(dynamicArgs))
			res.createField("subscription", "OTW")
			result := res.lockInputsAndBuild()

			self := undefined
			self = ll.toStrict(oop.inherit(result, {
				/**
				 * Retrieves the output field for a given output name.
				 *
				 * @param name: string - The name of the output.
				 * @return FutureOutputField - The future output field for the specified name.
				 */
				getOutput: func(name) {
					return result.getFutureOutputField(_OUTPUTS_PREFIX + name)
				}
			}))

			return self
		}
	})

	return self
}

/**
 * Runs a For Loop for templates.
 *
 * @param tpl: resource - The template to run with.
 */
runWithTemplate := func(tpl) {
	res := builder().
		setEphemeral(false).
		setBodyResourceType(constants.RTYPE_RENDER_TEMPLATE).
		setNestedMode(tplutil.INPUTS_MAP_FIELD).
		addStaticArgument(tplutil.TEMPLATE_FIELD, tpl)

	inputs := {}

	self := undefined
	self = ll.toStrict(oop.inherit(res, {
		/**
		 * Sets the dynamic input field name.
		 *
		 * @param name: string - the name of the dynamic input field.
		 */
		setDynamicInputName: func(name) {
			self.setDynamicArgumentFieldName(name)
			return self
		},

		/**
		 * Adds a template output name.
		 *
		 * @param name: string - the name of the template output.
		 */
		addTemplateOutput: func(name) {
			self.addOutputName(tplutil.TEMPLATE_OUTPUT_PREFIX + name)
			return self
		},

		/**
		 * Adds a static input.
		 *
		 * @param name: string - the name of the static input.
		 * @param value: any - the value of the static input.
		 */
		addStaticInput: func(name, value) {
			inputs[name] = value
			return self
		},

		/**
		 * Adds multiple static inputs.
		 *
		 * @param nameToValue: map[string]any - a map of static input names to their values.
		 */
		addStaticInputMap: func(nameToValue) {
			for name, value in nameToValue {
				self.addStaticInput(nameToValue)
			}
			return self
		},

		/**
		 * Adds a dynamic input.
		 *
		 * @param name: string - the name of the dynamic input.
		 * @param value: any - the value of the dynamic input.
		 */
		addDynamicInput: func(name, value) {
			self.addDynamicArgument(name, value)
			return self
		},

		/**
		 * Adds multiple dynamic inputs.
		 *
		 * @param nameToValue: map[string]any - a map of dynamic input names to their values.
		 */
		addDynamicInputMap: func(nameToValue) {
			self.addDynamicArgumentMap(nameToValue)
			return self
		},

		/**
		 * Builds the For Loop resource with the configured inputs.
		 */
		build: func() {
			res.addStaticArgument(tplutil.INPUTS_MAP_FIELD, smart.createMapResource(inputs))

			super := res.build()
			self := ll.toStrict(oop.inherit(super, {
				/**
				 * Retrieves the output field for a given template output name.
				 *
				 * @param name: string - the name of the template output.
				 * @return FutureOutputField - the future output field for the specified name.
				 */
				getOutput: func(name) {
					return super.getOutput(tplutil.TEMPLATE_OUTPUT_PREFIX + name)
				}
			}))

			return self
		}
	}))

	return self
}

export ll.toStrict({
	builder: builder,
	runWithTemplate: runWithTemplate
})
