// exec.tpl

/**
 * Creates and fill a workdir, runs a command on it
 * and saves a chosen resulted files from this dir.
 */

ll := import(":ll")
self := import(":tpl")
smart := import(":smart")
render := import(":render")
fmt := import("fmt")
workdir := import(":workdir")
enum := import("enum")
runcmd := import(":runcmd")
stream := import(":stream")
slices := import(":slices")
sets := import(":sets")
validation := import(":validation")
maps := import(":maps")

self.defineOutputs(
	"filesMap", "dataMap", "progressMap", "filesStreams"
)

self.body(func(inputs) {
	// assert we have inputs we expect.
	cmdScheme := {
		isExec: "bool",
		value: "string",
		"pathToBinary,omitempty": "string"
	}

	validation.assertJsonSchema(inputs, {
		files: { any: validation.resource },
		values: { any: "any" },
		dirs: ["string"],
		runOptions: {
			cmd: cmdScheme,
			args: [cmdScheme],
			envs: { any: "string" },
			queue: "string",
			stdout: "string",
			stderr: "string",
			nErrorLines: "number"
		},
		saveFiles: ["string"],
		saveFilesContents: ["string"],
		streams: ["string"]
	})

	// create and fill the workdir with files that were passed from inputs.
	builder := workdir.builder()
	builder.addFiles(inputs.files)
	slices.map(inputs.dirs, builder.mkDir)

	// Pass values as fields for saving the topology in pl-core
	// and avoiding deduplication issues.
	rawInputs := self.rawInputs()
	builder.writeFiles(rawInputs.values.getValue().inputs())

	wd := builder.build()

	// creates a runcmd builder
	opts := inputs.runOptions
	run := runcmd.builder(wd)

	// sets a command to the builder.
	if opts.cmd.isExec {
		run.cmdExecutable(opts.cmd.cmd, opts.cmd.pathToBinary)
	} else {
		run.cmd(opts.cmd.value)
	}

	// sets arguments to the builder.
	for name, arg in opts.args {
		if arg.isExec {
			run.argExecutable(arg.arg, arg.pathToBinary)
		} else {
			run.arg(arg.value)
		}
	}

	// sets all other options.
	enum.each(opts.envs, run.env)
	run.inQueue(opts.queue)
	run.stdout(opts.stdout)
	run.stderr(opts.stderr)
	run.nErrorLines(opts.nErrorLines)
	runRes := run.build()

	// saves all requested files as value resources and blob resources.
	save := workdir.save(runRes.workdirOut)
	slices.map(inputs.saveFiles, save.saveFile)
	slices.map(inputs.saveFilesContents, save.saveFileContent)
	saveRes := save.build()

	// create streams for all requested file streams.
	streams := smart.mapBuilder()
	for file, _ in sets.fromSlice(inputs.streams) {
		s := stream.create(wd, saveRes, file)
		streams.add(file, s)
	}

	return {
		filesMap: saveRes.files,
		dataMap: saveRes.data,
		progressMap: saveRes.progress,
		filesStreams: streams.build()
	}
})
