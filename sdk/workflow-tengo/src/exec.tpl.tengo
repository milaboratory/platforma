// exec.tpl

/**
 * Creates and fill a workdir, runs a command on it
 * and saves a chosen resulted files from this dir.
 */

ll := import(":ll")
self := import(":tpl")
smart := import(":smart")
render := import(":render")
fmt := import("fmt")
workdir := import(":workdir")
enum := import("enum")
runcmd := import(":runcmd")
software := import(":software")
stream := import(":stream")
slices := import(":slices")
sets := import(":sets")
validation := import(":validation")
maps := import(":maps")
execInternal := import(":exec-internal")

self.defineOutputs(
	"filesMap", "dataMap", "progressMap", "filesStreams"
)

_runBinaryCommand := func(inputs) {
	// create and fill the workdir with files that were passed from inputs.
	builder := workdir.builder()
	builder.addFiles(inputs.files)
	slices.map(inputs.dirs, builder.mkDir)

	// Pass values as fields for saving the topology in pl-core
	// and avoiding deduplication issues.
	rawInputs := self.rawInputs()
	builder.writeFiles(rawInputs.values.getValue().inputs())

	wd := builder.build()

	// creates a runcmd builder
	run := runcmd.builder(wd)
	opts := execInternal.binaryRunOptions(inputs.runOptions)

	for pkgInfo in opts.packages {
		run.useSoftware(
			pkgInfo.name,
			execInternal.installSoftware(pkgInfo)
		)
	}

	// sets a command to the builder.
	if opts.cmd.isRef {
		run.cmdExecutable(opts.cmd.key, opts.cmd.value)
	} else {
		run.cmd(opts.cmd.value)
	}

	// sets arguments to the builder.
	for name, arg in opts.args {
		if arg.isRef {
			run.argExecutable(arg.key, arg.value)
		} else {
			run.arg(arg.value)
		}
	}

	// sets all other options.
	enum.each(opts.envs, run.env)
	run.inQueue(opts.queue)
	run.stdout(opts.stdout)
	run.stderr(opts.stderr)
	run.nErrorLines(opts.nErrorLines)
	runRes := run.build()

	// saves all requested files as value resources and blob resources.
	save := workdir.save(runRes.workdirOut)
	slices.map(inputs.saveFiles, save.saveFile)
	slices.map(inputs.saveFilesContents, save.saveFileContent)
	saveRes := save.build()

	// create streams for all requested file streams.
	streams := smart.mapBuilder()
	for file, _ in sets.fromSlice(inputs.streams) {
		s := stream.create(wd, saveRes, file)
		streams.add(file, s)
	}

	return {
		filesMap: saveRes.files,
		dataMap: saveRes.data,
		progressMap: saveRes.progress,
		filesStreams: streams.build()
	}
}

self.body(func(inputs) {
	// assert we have inputs we expect.
	cmdScheme := {
		isRef: "bool",
		value: "string"
	}

	validation.assertJsonSchema(inputs, {
		"softwareInfo,omitempty": validation.resource,
		files: { any: validation.resource },
		values: { any: "any" },
		dirs: ["string"],
		runOptions: {
			"software,omitempty": software.infoScheme,
			"cmd,omitempty": "string",
			"args,omitempty": [cmdScheme],
			envs: { any: "string" },
			queue: "string",
			stdout: "string",
			stderr: "string",
			nErrorLines: "number"
		},
		saveFiles: ["string"],
		saveFilesContents: ["string"],
		streams: ["string"]
	})

	// ll.panic("INPUTS: " + json.encode(inputs))

	return _runBinaryCommand(inputs)
})
