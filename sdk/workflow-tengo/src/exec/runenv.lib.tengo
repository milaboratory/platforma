ll := import(":ll")
smart := import(":smart")
oop := import(":oop")
maps := import(":maps")
validation := import(":validation")

runEnvDescriptorScheme := {
	registry: "string",
	package: "string",
	type: "string",
	binDir: "string"
}

binaryDescriptorScheme := {
	registry: "string",
	package: "string",
	cmd: ["string"],
	runEnv: runEnvDescriptorScheme
}

localDescriptorScheme := {
	hash: "string",
	path: "string",
	cmd: ["string"],
	runEnv: runEnvDescriptorScheme
}

descriptorScheme := {
	"isDev,omitempty": "bool",
	"binary,omitempty": binaryDescriptorScheme,
	"local,omitempty": localDescriptorScheme
}

softwareInfoScheme := {
	"name": "string",
	"version": "string",
	"descriptor": descriptorScheme
}

META_KEY_DESCRIPTOR   := "ctl/runner/software/descriptor"

_RTYPE_SAVE_RUN_ENV   := { Name: "SaveRunEnv/executor", Version: "1" }
_INPUT_SETTINGS       := "settings"
_INPUT_WD_IN          := "workdirIn"
_INPUT_SOFTWARE       := "software"
_OUTPUT_RUN_ENV       := "runEnv"
_OUTPUT_WD_OUT        := "workdirOut"

saveBuilder := func() {
    self := undefined

    pathsToSave := []
    envType := ""
    toolset := ""
    dependencies := {}

    self = {
        addPath: func(p) {
            pathsToSave = append(pathsToSave, p)
        },

        envType: func(eType) {
            envType = eType
        },

        packagingToolset: func(name) {
            toolset = name
        },

        addDependencySpec := func(fileName, fileContent) {
            if !is_bytes(fileContent) {
                fileContent = bytes(fileContent)
            }
            dependencies[fileName] = fileContent
        }

        build: func() {
            settings := smart.createJsonResource({
                paths: pathsToSave,
                type: envType,
                packagingToolset: toolset,
                dependencies: dependencies,
            })

            
        }
    }

	res := smart.structBuilder(_RTYPE_PACKAGE_GET)

	res.inputs()[_INPUT_REGISTRY].setRefOrJson(registryName)
	res.inputs()[_INPUT_PACKAGE_NAME].setRefOrJson(pkgName)

	self := undefined
	self = oop.inherit(res, {
		/**
		 * Reference to the software package archive downloaded by 'get'
		 *
		 * @return archive: field - output field, where info on downloaded archive will appear
		 */
		archive: func() {
			return res.outputs()[_OUTPUT_ARCHIVE]
		}
	})

	return self
}

install := func(pkg) {
	ll.assert(smart.isReference(pkg),
		"package.install: <pkg> must be reference to software package. It is usually obtained from package.get().archive")

	res := smart.structBuilder(_RTYPE_PACKAGE_INSTALL)

	res.inputs()[_INPUT_PACKAGE].set(pkg)

	self := undefined
	self = oop.inherit(res, {
		/**
		 * Reference to installed software
		 *
		 * @return software: field - output field, where info on downloaded archive will appear
		 */
		software: func() {
			return res.outputs()[_OUTPUT_SOFTWARE]
		}
	})

	return self
}

use := func(settings) {
	res := smart.structBuilder(_RTYPE_PACKAGE_USE)

    validation.assertJsonSchema(settings, _useSettingsSchema, "package.use(<settings>): settings have invalid format")
	settingsRes := smart.createJsonResource(settings)

	res.inputs()[_INPUT_PACKAGE_USE_SETTINGS].set(settingsRes)

	self := undefined
	self = oop.inherit(res, {
		/**
		 * Reference to installed software
		 *
		 * @return software: field - output field, where info on downloaded archive will appear
		 */
		software: func() {
			return res.outputs()[_OUTPUT_SOFTWARE]
		}
	})

	return self
}

export ll.toStrict({
	softwareInfoScheme                 : softwareInfoScheme,
	binaryDescriptorScheme             : binaryDescriptorScheme,
	localDescriptorScheme              : localDescriptorScheme,
	runEnvDescriptorScheme             : runEnvDescriptorScheme,

	META_KEY_DESCRIPTOR                : META_KEY_DESCRIPTOR,

	get                                : get,
	install                            : install,
	use                                : use
})
