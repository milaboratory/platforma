json := import("json")
ll := import(":ll")
oop := import(":oop")
maps := import(":maps")
path := import(":path")
pkg := import(":package")

_formatArg := func(isRef, key, value) {
	return {
		isRef: isRef,
		key: key,
		value: value
	}
}

_installSoftware := func(registry, pkgName) {
	archive := pkg.get(registry, pkgName).archive()
	return pkg.install(archive).software()
}

_directCallOptions := func(runOptions) {
	cmd := _formatArg(false, "", runOptions.cmd)
	args := []

	for name, arg in runOptions.args {
		ll.assert(!arg.isRef,
			"'exec-ref' argument is invalid in this command: no software info was given to exec.builder()")
		args = append(args, _formatArg(false, "", arg.value))
	}

	return oop.inherit(runOptions, {
		packages: [],
		cmd: cmd,
		args: args
	})
}

_binPackageCallOptions := func(runOptions, packages, software, descriptor) {
	args := []

	// Real command shoule be:
	//   [<runEnv bin>] [<runEnv options>] [<entrypoint bin>] [<entrypoint options>] <cmd> <args>
	if (maps.containsKey(descriptor, "runEnv")) {
		ll.panic("unable to run software %s v%s: runEnv for 'binary' execution mode is not implemented",
			software.name, software.version
		)

		runEnv := descriptor.runEnv

		packages = append(packages, {
			name: runEnv.name,
			reference: _installSoftware(runEnv.registry, runEnv.package)
		})
	}

	if (len(descriptor.entrypoint) > 0) {
		entrypoint := descriptor.entrypoint

		args = append(args, _formatArg(true, software.name, entrypoint[0]))
		for i := 1; i < len(entrypoint); i++ {
			args = append(args, _formatArg(false, "", entrypoint[i]))
		}
	}

	cmdName := runOptions.cmd
	if (is_undefined(cmdName)) {
		// Use default 'cmd' from descriptor, if caller did not specify custom cmd
		cmdName = descriptor.cmd
	}
	if (is_undefined(cmdName)) {
		ll.panic(
			"unable to run software %s v%s: 'cmd' is required for 'binary' execution mode of this package",
			software.name, software.version
		)
	}

	args = append(args, _formatArg(true, software.name, cmdName))
	for name, arg in runOptions.args {
		args = append(args, _formatArg(arg.isRef, software.name, arg.value))
	}

	cmd := args[0]
	args = splice(args, 1) // cut 1st element from args, so args = [args[1], args[2], ...]

	return oop.inherit(runOptions, {
		packages: packages,
		cmd: cmd,
		args: args
	})
}

_devLocalPackageCallOptions := func(runOptions) {
	software := runOptions.software
	localDescriptor := software.descriptor.local

	packages := [{
		name: software.name,
		reference: pkg.use({
			hash: localDescriptor.hash,
			path: localDescriptor.path,
			descriptor: json.encode(ll.fromStrict(software.descriptor)),
			origin: {
				registry: "devLocal",
				url: "file://" + localDescriptor.path,
				packageName: software.descriptor.name
			}
		}).software()
	}]

	return _binPackageCallOptions(runOptions, packages, software, localDescriptor)
}

_remotePackageCallOptions := func(runOptions) {
	software := runOptions.software
	binaryDescriptor := software.descriptor.binary

	packages := [{
		name: software.name,
		reference: _installSoftware(binaryDescriptor.registry, binaryDescriptor.package)
	}]

	return _binPackageCallOptions(runOptions, packages, software, binaryDescriptor)
}

binaryRunOptions := func(runOptions) {
	// {
	//   cmdName: {isExecRef: bool, value: string},
	//   args: [{isExecRef: bool, value: string}],
	//   softwareName: string
	// }

	if (is_undefined(runOptions.software)) {
		//
		// Simple local command run, no software pacakges involved (backward compatibility)
		//
		return _directCallOptions(runOptions)
	}

	software := runOptions.software
	descriptor := software.descriptor

	if (maps.containsKey(descriptor, "local")) {
		return _devLocalPackageCallOptions(runOptions)
	}

	if (maps.containsKey(descriptor, "binary")) {
		return _remotePackageCallOptions(runOptions)
	}

	ll.panic("Unable to run software %s v%s: 'binary' execution mode is not enabled in software descriptor", software.name, software.version)
}

export {
	binaryRunOptions: binaryRunOptions
}
