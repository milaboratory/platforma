json := import("json")
text := import("text")
ll := import(":ll")
oop := import(":oop")
maps := import(":maps")
path := import(":path")
pkg := import(":package")

// Variables, substituted in command arguments and environment variable values
_ARG_VAR_PKG            := "{pkg}"  // abs path to software package
_ARG_VAR_JAVA           := "{java}" // abs path to 'java' run environment

/**
 * Create new argument marking it as 'with' or 'without' variables inside.
 * The outcome of 'hasVariables' flag value is wether the value will be treated
 * by Platforma Backend on server side before being given to the actual command.
 */
_newArg := func(hasVariables, value) {
	return {
		hasVars: hasVariables,
		value: value
	}
}

_newPackageRef := func(varName, refName, reference) {
	return{
		varName: varName,
		refName: refName,
		reference: reference
	}
}

_installSoftware := func(registry, pkgName) {
	archive := pkg.get(registry, pkgName).archive()
	return pkg.install(archive).software()
}

_directCallOptions := func(runOptions) {
	cmd := _newArg(false, runOptions.cmd)
	args := []
	envs := {}

	for name, arg in runOptions.args {
		args = append(args, _newArg(false, arg))
	}

	for name, val in runOptions.envs {
		envs[name] = _newArg(false, val)
	}

	return oop.inherit(runOptions, {
		packages: [],
		customPaths: [],
		cmd: cmd,
		args: args,
		envs: envs
	})
}

_loadJavaRunEnvironment := func(runEnvDescriptor) {
	return {
		package: _newPackageRef(
			_ARG_VAR_JAVA,
			runEnvDescriptor.name,
			_installSoftware(runEnvDescriptor.registry, runEnvDescriptor.package)
		),
		customPaths: [ _newArg(true, path.join(_ARG_VAR_JAVA, runEnvDescriptor.binDir)) ]
	}
}

_loadRunEnvironment := func(runEnvDescriptor) {
	if runEnvDescriptor.type == "java" {
		return _loadJavaRunEnvironment(runEnvDescriptor)
	}

	ll.panic("run environment type %q is not currently supported by tengo-sdk", runEnvDescriptor.type)
}

_binPackageCallOptions := func(runOptions, packages, software, descriptor) {
	customPaths := []
	args := []
	envs := {}

	// Real command shoule be:
	//   [<runEnv bin>] [<runEnv options>] [<entrypoint bin>] [<entrypoint options>] <cmd> <args>
	if (maps.containsKey(descriptor, "runEnv")) {
		runEnvInfo := _loadRunEnvironment(descriptor.runEnv)

		packages = append(packages, runEnvInfo.package)
		if len(runEnvInfo.customPaths) > 0 {
			customPaths = append(customPaths, runEnvInfo.customPaths...)
		}
	}

	ll.assert(len(descriptor.cmd) != 0, "cannot render final command for software: empty 'cmd' in software descritor")

	cmd := _newArg(true, descriptor.cmd[0])

	for arg in splice(descriptor.cmd, 1) {
		args = append(args, _newArg(true, arg))
	}
	for arg in runOptions.args {
		args = append(args, _newArg(false, arg))
	}

	for name, val in runOptions.envs {
		envs[name] = _newArg(false, val)
	}

	return oop.inherit(runOptions, {
		packages: packages,
		customPaths: customPaths,
		cmd: cmd,
		args: args,
		envs: envs
	})
}

_devLocalPackageCallOptions := func(runOptions) {
	software := runOptions.software
	localDescriptor := software.descriptor.local

	packages := [_newPackageRef(
		_ARG_VAR_PKG,
		software.name,
		pkg.use({
			hash: localDescriptor.hash,
			path: localDescriptor.path,
			descriptor: json.encode(ll.fromStrict(software.descriptor)),
			origin: {
				registry: "dev-local",
				url: "file://" + localDescriptor.path,
				packageName: software.descriptor.name
			}
		}).software()
	)]

	return _binPackageCallOptions(runOptions, packages, software, localDescriptor)
}

_remotePackageCallOptions := func(runOptions) {
	software := runOptions.software
	binaryDescriptor := software.descriptor.binary

	packages := [_newPackageRef(
		_ARG_VAR_PKG,
		software.name,
		_installSoftware(binaryDescriptor.registry, binaryDescriptor.package)
	)]

	return _binPackageCallOptions(runOptions, packages, software, binaryDescriptor)
}

binaryRunOptions := func(runOptions) {
	// {
	//   cmdName: {isExecRef: bool, value: string},
	//   args: [{isExecRef: bool, value: string}],
	//   softwareName: string
	// }

	if (is_undefined(runOptions.software)) {
		//
		// Simple local command run, no software pacakges involved (backward compatibility)
		//
		return _directCallOptions(runOptions)
	}

	software := runOptions.software
	descriptor := software.descriptor

	if (maps.containsKey(descriptor, "local")) {
		return _devLocalPackageCallOptions(runOptions)
	}

	if (maps.containsKey(descriptor, "binary")) {
		return _remotePackageCallOptions(runOptions)
	}

	ll.panic("Unable to run software %s v%s: 'binary' execution mode is not enabled in software descriptor", software.name, software.version)
}

export {
	binaryRunOptions              : binaryRunOptions
}
