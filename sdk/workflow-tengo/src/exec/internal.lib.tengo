/**
 * Internal 'exec' module library.
 *
 * NOT INTENDEND FOR USE OUTSIDE 'exec' MODULE.
 * May completely change API from release to release.
 */

ll := import(":ll")
oop := import(":oop")
maps := import(":maps")
runcmd := import(":exec.runcmd")
constants := import(":exec.constants")
validation := import(":validation")
loadSoftware := import(":exec.load-software")

//
// Variables, substituted in command arguments and environment variable values.
//
_ARG_VAR_MNZ                 := "monetization" // monetization env value

_directCallOptions := func(runOptions) {
	return ll.toStrict({
		variables: [],
		customPaths: [],
		cmd: runcmd.simpleArg(runOptions.cmd),
		args: [],
		envs: {}
	})
}

binaryRunOptions := func(runOptions, mnzEnvs) {
	validation.assertType(mnzEnvs, {"any": validation.reference})

	runCmdOpts := undefined
	if (is_undefined(ll.fromStrict(runOptions).software)) {
		//
		// Simple local command run, no software packages involved (backward compatibility)
		//
		runCmdOpts = _directCallOptions(runOptions)
	} else {
		software := runOptions.software
		descriptor := software.descriptor

		runCmdOpts = loadSoftware.swToRunCmdOptions(software.name, software.version, descriptor)
	}

	// adds exec builder's defined options from run options.
	// If argsTyped or envsTyped are set (which is a new API from exec.builder),
	// then pass them directly.
	// Otherwise, pass args and envs the old way, without possible expression evaluating.
	opts := ll.fromStrict(runOptions)
	shouldUseNewTyped := !is_undefined(opts.argsTyped) || !is_undefined(opts.envsTyped)

	args := shouldUseNewTyped ? runOptions.argsTyped : runOptions.args
	for _, arg in args {
		typedArg := shouldUseNewTyped ? arg :	runcmd.simpleArg(arg)
		runCmdOpts.args = append(runCmdOpts.args, typedArg)
	}

	envs := shouldUseNewTyped ? runOptions.envsTyped : runOptions.envs
	for name, v in envs {
		typedEnv := shouldUseNewTyped ? v : runcmd.simpleArg(v)
		runCmdOpts.envs[name] = typedEnv
	}

	for name, val in mnzEnvs { // can be empty
		// if it's not empty, then we create an env that has
		// a result of monetization client.
		runCmdOpts.envs[name] = runcmd.expressionArg("{" + _ARG_VAR_MNZ + "}")

		runCmdOpts.variables = append(runCmdOpts.variables,
			ll.toStrict({varName: _ARG_VAR_MNZ, refName: "monetization", reference: val}))
	}


	return oop.inherit(runOptions, ll.fromStrict(runCmdOpts))
}

prepareCommandRun := func(wd, opts) {
	runBuilder := runcmd.builder(wd)

	// Make installed packages to be available for the command run
	for varInfo in opts.variables {
		runBuilder.ref(varInfo.refName, varInfo.reference)
		runBuilder.substitutionRule(varInfo.varName, varInfo.refName)
	}

	// Patch command's PATH env variable
	for p in opts.customPaths {
		runBuilder.addPathTyped(p.type, p.value)
	}

	// Configure environment variables required for correct command run environment setup
	for name, value in opts.envs {
		runBuilder.envTyped(name, value.type, value.value)
	}

	return runBuilder
}

_activateRenv := func(wd, opts) {
	activateRenv := prepareCommandRun(wd, opts)
	activateRenv.
		cmd("R").
		inQueue(constants.LIGHT_QUEUE).
		arg("-e").arg("renv::activate()")

	activateRenvRun := activateRenv.build()

	return activateRenvRun
}

prepareWDForRunEnvironment := func(wd, opts) {
	if (!maps.containsKey(opts, "runEnvType")) {
		return wd
	}

	if (opts.runEnvType == "R") {
		return _activateRenv(wd, opts).workdir
	}

	return wd
}

export {
	binaryRunOptions			: binaryRunOptions,

	prepareWDForRunEnvironment	: prepareWDForRunEnvironment,
	prepareCommandRun			: prepareCommandRun
}
