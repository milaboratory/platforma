/** A library that creates RunCommand resource. */

ll := import(":ll")
maps := import(":maps")
oop := import(":oop")
smart := import(":smart")
json := import("json")

_RTYPE_RUN_COMMAND := { Name: "RunCommand", Version: "1" }
_RTYPE_RUN_COMMAND_CMD := { Name: "RunCommandCmd", Version: "1" }
_RTYPE_RUN_COMMAND_ARGS := { Name: "RunCommandArgs", Version: "1" }
_RTYPE_RUN_COMMAND_OPTIONS := { Name: "run-command/options", Version: "1" }
_RTYPE_RUN_COMMAND_REFS := { Name: "RunCommandRefs", Version: "1" }

/**
 * Creates a simple argument for the command.
 *
 * @param argument: string - the argument to create.
 */
_createSimpleArg := func(argument) {
	return {
		type: "string",
		value: argument
	}
}

/**
 * Creates an executable argument for the command.
 *
 * @param executableName: string - the name of the executable.
 * @param pathToBinary: string|undefined - the path to the binary.
 */
_createExecutableArg := func(executableName, pathToBinary) {
	return {
		type: "executableRef",
		value: executableName,
		execPath: pathToBinary // maybe null
	}
}

/**
 * Builder function for creating a RunCommand resource.
 *
 * @param workdir: string - the working directory for the command.
 * @return builder - the builder object with methods for configuring and building the RunCommand resource.
 */
builder := func(workdir) {
	res := smart.ephemeralBuilder(_RTYPE_RUN_COMMAND)
	res.getField("workdirIn").set(workdir)

	self := undefined

	cmd := undefined
	args := []
	envs := {}
	queue := ""
	refs := {}

	stdout := "stdout.txt"
	stderr := "stderr.txt"
	nErrorLines := 200

	self = ll.toStrict(oop.inherit(res, {
		/**
		 * Sets the command, e.g. /usr/bin/env or sh.
		 *
		 * @param commandName: string - the name of the command.
		 */
		cmd: func(commandName) {
			cmd = _createSimpleArg(commandName)
			return self
		},

		/**
		 * Sets the command executable.
		 *
		 * @param softwareName: string - name of software from .softwareRef()
		 * @param targetPath: string - path inside software package.
		 */
		cmdExecutable: func(softwareName, targetPath) {
			ll.assert(maps.containsKey(refs, softwareName),
				"runcmd.builder().cmdExecutable(): attempt to refer to unknown software %q", softwareName)

			cmd = _createExecutableArg(softwareName, targetPath)
			return self
		},

		/**
		 * Use given installed software when running the command.
		 *
		 * @param softwareName: string - key, cmdExecutable() and argExecutable() could use to refer this software on host when running
		 */
		useSoftware: func(softwareName, reference) {
			ll.assert(smart.isReference(reference),
				"runcmd.builder().softwareRef() must be a reference to installed software")
			ll.assert(!maps.containsKey(refs, softwareName),
				"attempt to override software reference %q", softwareName)

			refs[softwareName] = reference
		},

		/**
		 * Adds an argument to the command.
		 *
		 * @param arg: string - the argument to add.
		 */
		arg: func(arg) {
			args = append(args, _createSimpleArg(arg))
			return self
		},

		/**
		 * Adds an argument, that points to some file inside installed software package
		 *
		 * @param softwareName: string - name of software from .softwareRef()
		 * @param targetPath: string - path inside software package.
		 */
		argExecutable: func(softwareName, targetPath) {
			ll.assert(maps.containsKey(refs, softwareName),
				"runcmd.builder().argExecutable(): attempt to refer to unknown software %q", softwareName)

			args = append(args, _createExecutableArg(softwareName, targetPath))
			return self
		},

		/**
		 * Sets an environment variable for the command.
		 *
		 * @param name: string - the name of the environment variable.
		 * @param value: string - the value of the environment variable.
		 */
		env: func(name, value) {
			envs[name] = value
			return self
		},

		/**
		 * Sets the queue name for the command.
		 *
		 * @param queueName: string - the name of the queue.
		 */
		inQueue: func(queueName) {
			queue = queueName
			return self
		},

		/**
		 * Sets the stdout file name for the command.
		 *
		 * @param fileName: string - the name of the stdout file.
		 */
		stdout: func(fileName) {
			stdout = fileName
			return self
		},

		/**
		 * Sets the stderr file name for the command.
		 *
		 * @param fileName: string - the name of the stderr file.
		 */
		stderr: func(fileName) {
			stderr = fileName
			return self
		},

		/**
		 * Sets the number of error lines for the command.
		 *
		 * @param number: int - the number of error lines.
		 */
		nErrorLines: func(number) {
			nErrorLines = number
			return self
		},

		/**
		 * Builds the RunCommand resource.
		 *
		 * @return object - the built RunCommand resource.
		 */
		build: func() {
			// TODO: add assertions about the state

			refsRes := smart.createMapResourceWithType(_RTYPE_RUN_COMMAND_REFS, refs)
			self.getField("refs").set(refsRes)

			cmdRes := smart.createValueResource(_RTYPE_RUN_COMMAND_CMD, json.encode(cmd))
			self.getField("cmd").set(cmdRes)

			options := {
				queueName: queue,
				errorLines: nErrorLines,
				redirectStdout: stdout,
				redirectStderr: stderr,
				env: envs
			}
			optionsRes := smart.createValueResource(_RTYPE_RUN_COMMAND_OPTIONS, json.encode(options))
			self.getField("options").set(optionsRes)

			argsRes := smart.createValueResource(_RTYPE_RUN_COMMAND_ARGS, json.encode(args))
			self.getField("args").set(argsRes)

			res := ll.toStrict(oop.inherit(self.lockAndBuild(), {
				"workdir": self.outputs().workdirOut,
				"options": options
			}))

			return res
		}
	}))

	return self
}

export ll.toStrict({
	builder: builder
})
