/** The library provides all things to work with a monetization. */

base64 := import("base64")
json := import("json")

ll := import(":ll")
feats := import(":feats")

validation := import(":validation")
assets := import(":assets")
internal := import(":exec.internal")
fmt := import("fmt")
text := import("text")
runcmd := import(":exec.runcmd")
workdir := import(":workdir")
render := import(":render")
constants := import(":exec.constants")

_JWT_TOKEN_RESULT_ENV := "PLATFORMA_MNZ_JWT"

/** A number of remaining runs will be stored here. */
REMAINING_RUNS_FILE_NAME := "mnz_remaining_runs.txt"

tokenSchema := {
	mnz: {
		details: {
			remaining: "number"
		}
	}
}

/** Just creates a new monetization as a map of params. */
init := func() {
	return ll.toStrict({
		enabled: false,

		// product key of monetization
		productKey: "",

		// just returns a number of runs without the actual calculation.
		isDryRun: false,

		// does we need to store a number of remaining runs.
		saveRemainingRuns: false,

		// file name to the param, e.g. {fileName: { arg: "dataset", collect: ["size", "lines", "sha256"] }}
		fileParams: {}
	})
}

fileParamsSchema := {
	"arg": "string",
	"collect": [`string,regex=size|lines|sha256`]
}

schema := {
	"enabled": "bool",
	"productKey": "string",
	"isDryRun": "bool",
	"saveRemainingRuns": "bool",
	"fileParams": {"any": fileParamsSchema}
}

/** Same as validation.assertType(params, fileParamsSchema, ...),
 * but with prettier errors for clients. */
_validateParams := func(params) {
	ll.assert(ll.isMap(params), "monetization.validateParams(): mnz params must be a map")
	ll.assert(is_string(params.arg), "monetization.validateParams(): 'arg' in {\"mnz\": {...}} param must be a string")
	ll.assert(is_array(params.collect) && len(params.collect) > 0, "monetization.validateParams(): 'collect' in {\"mnz\": {...}} param must be non-empty an array")
}

_validateIsReady := func(mnz) {
	validation.assertType(mnz, schema,
		"monetization.assertIsReady(): monetization does not fit schema")
	ll.assert(len(mnz.productKey) > 0,
		"monetization.assertIsReady(): product key must be set")
	ll.assert(len(mnz.fileParams) > 0,
		"monetization.assertIsReady(): at least 1 file param must be set")
}

/** Enables the monetization for a product. */
enable := func(mnz, productKey) {
	ll.assert(is_string(productKey),
		"monetization.enable(): product key must be a string, got %v", productKey)

	validation.assertType(mnz, schema,
		"monetization.enable(): mnz object does not fit schema")

	mnz.enabled = true
	mnz.productKey = productKey
}

setDryRun := func(mnz, isDryRun) {
	ll.assert(mnz.enabled,
		"monetization.setDryRun(): monetization must be explicitly enabled by enableMnz(productKey) function")

	ll.assert(is_bool(isDryRun),
		"monetization.setDryRun(): isDryRun must be boolean, got %v", isDryRun)

	validation.assertType(mnz, schema,
		"monetization.setDryRun(): mnz object does not fit schema")

	mnz.isDryRun = isDryRun
}

/** Sets if we need to save a number of remaining runs or not. */
setSaveRemainingRuns := func(mnz, saveRemainingRuns) {
	ll.assert(mnz.enabled,
		"monetization.setSaveRemainingRuns(): monetization must be explicitly enabled by enableMnz(productKey) function")

	validation.assertType(mnz, schema,
		"monetization.saveRemainingRuns(): mnz object does not fit schema")

	ll.assert(is_bool(saveRemainingRuns),
		"monetization.saveRemainingRuns(): saveRemainingRuns must be boolean, got %v", saveRemainingRuns)

	mnz.saveRemainingRuns = saveRemainingRuns
}

/** Is this monetization enabled and should run? */
shouldRun := func(mnz) {
	if mnz.enabled {
		_validateIsReady(mnz)
		return true
	}

	return false
}

toJson := func(mnz) {
	validation.assertType(mnz, schema,
		"monetization.toJson(): monetization object does not fit json schema")

	return ll.fromStrict(mnz)
}

/** Adds monetization parameters by a file. */
addFileParams := func(mnz, fileName, params) {
	validation.assertType(mnz, schema,
		"monetization.addFileParams(): monetization object does not fit json schema")

	_validateParams(params)

	validation.assertType(params, fileParamsSchema,
		"monetization.addFileParams(): file params does not fit json schema")

	ll.assert(mnz.enabled,
		"monetization.addFileParams(): monetization must be explicitly enabled by enableMnz(productKey) function")

	ll.assert(is_string(fileName),
		"monetization.addFileParams(): file name must be a string.")

	mnz.fileParams[fileName] = params
}

/**
 * Runs monetization binary on a workdir with all files, and returns a new workdir and a resulted jwt token.
 * All resources are ephemeral,
 * the deduplication should be above this level.
 *
 * @param: mnz: monetization -- see a beginning of this file.
 * @param: wd: workdir -- workdir where all files from mnz.fileParams already exist.
 * @param: queue: queue - in which queue we should run monetization. */
run := func(mnz, wd, queue) {
	_validateIsReady(mnz)

	exprType := feats.commandExpressions ? constants.ARG_TYPE_EXPRESSION : constants.ARG_TYPE_VAR

	mnzSw := assets.importSoftware("@platforma-open/milaboratories.software-small-binaries:mnz-client")
	builder := runcmd.builder(wd)
	builder.envTyped("MI_LICENSE", exprType, "{secrets.MI_LICENSE}")

	opts := internal.swToRunCmdOptions(mnzSw.name, mnzSw.version, mnzSw.descriptor)
	// load pkg var that points to mnz-client location.
	for _, varInfo in opts.variables {
		builder.ref(varInfo.refName, varInfo.reference)
		builder.substitutionRule(varInfo.varName, varInfo.refName)
	}

	builder.cmdTyped(exprType, opts.cmd.value)
	for _, arg in opts.args {
		// now mnz-client doesn't have additional args; this line is just in case.
		builder.argTyped(exprType, arg)
	}
	if mnz.isDryRun {
		builder.arg("-dry-run")
	}
	builder.arg("-productKey").arg(mnz.productKey)

	// load file params
	for fileName, param in mnz.fileParams {
		// param is of fileParamsSchema type
		toCollect := text.join(param.collect, ",")
		arg := fmt.sprintf("%s:file:%s:%s", param.arg, fileName, toCollect)
		builder.arg(arg)
	}

	builder.inQueue(queue)
	stdout := "mnz_stdout.txt"
	builder.stdout(stdout)
	run := builder.build()

	// save mnz_stdout.txt
	savedWd := workdir.save(run.workdir).
		saveFileContent(stdout).
		build()

	resultAsBytesJson := savedWd.filesContent.getFutureInputField(stdout)

	resultAsStringJson := render.createEphemeral(
		assets.importTemplate(":exec.monetization_to_json"),
		{ resource: resultAsBytesJson }
	)

	// store nRemainingRuns in a file.
	// We don't want to return it as a value resource, because
	// in exec.tpl we can't declare new outputs or else there will be deduplication errors.
	newWd:= workdir.builder().
		writeFile(REMAINING_RUNS_FILE_NAME, resultAsStringJson.output("nRemainingRuns")).
		build()

	return ll.toStrict({
		// other commands should run on this wd,
		// or else they will run concurrently
		// with monetization.
		wdAfter: newWd,

		// mnz-client returns jwt token
		// that we will pass to the next command as env.
		jwtEnvName: _JWT_TOKEN_RESULT_ENV,
		jwtEnvValue: resultAsStringJson.output("jwtToken")
	})
}

/** Decodes a data part of the jwt token into tengo json. */
decodeJwtToken := func(jwt) {
	parts := text.split(jwt, ".")
	ll.assert(len(parts) == 3, "jwt token must consist of 3 parts, got: %v", parts)
	data := parts[1]
	decoded := base64.decode(data)
	obj := json.decode(decoded)

	return obj
}

export ll.toStrict({
	init: init,
	schema: schema,
	enable: enable,
	setDryRun: setDryRun,
	setSaveRemainingRuns: setSaveRemainingRuns,
	shouldRun: shouldRun,
	toJson: toJson,
	addFileParams: addFileParams,
	run: run,
	REMAINING_RUNS_FILE_NAME: REMAINING_RUNS_FILE_NAME,
	decodeJwtToken: decodeJwtToken,
	tokenSchema: tokenSchema
})
