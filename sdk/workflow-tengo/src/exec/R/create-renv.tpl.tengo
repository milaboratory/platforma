/**
 * Creates new r virtual environment.
 */

times := import("times")

self := import(":tpl.light")

ll := import(":ll")
validation := import(":validation")

workdir := import(":workdir")
path := import(":path")
waiter := import(":waiter")

desc := import(":exec.descriptor")
runcmd := import(":exec.runcmd")
runenv := import(":exec.runenv")
internal := import(":exec.R.internal")
pkg := import(":exec.package")

//
// Function declarations (see definitions below)
//
_createRvenv := undefined
_toolsetRenvCreate := undefined

// Create R virtual environment using selected toolset.
_createRvenv = func(operationMode, swPkgRef, rPkgRef, rRunEnvDescriptor, toolset, dependencies) {
	if toolset == "renv" {
		return _toolsetRenvCreate(operationMode, swPkgRef, rPkgRef, rRunEnvDescriptor, dependencies)
	}

	ll.panic("R toolset %q is not supported by current version of workflow-sdk", toolset)
}

_toolsetRenvCreate = func(operationMode, swPkgRef, rPkgRef, rRunEnvDescriptor, dependencies) {
	validation.assert(operationMode == "remote" || operationMode == "dev-local", "exec.R.create-renv: unknown operation mode: %q", operationMode)
	validation.assertType(rPkgRef, validation.reference, "exec.R.create-renv: <rPkgRef> must be reference to R run environment package")
	validation.assertType(rRunEnvDescriptor, desc.runEnvScheme, "exec.R.create-renv: <rRunEnvDescriptor> must be run environment descriptor")
	validation.assert(rRunEnvDescriptor.type == "R", "exec.R.create-renv: <rRunEnvDescriptor> must be R run environment descriptor")
	if (!is_undefined(dependencies)) {
		validation.assertType(dependencies, { "any": "string" }, "exec.R.create-renv: <dependencies> must be map of reference file paths")
	}

	// We do not use <dependencies> map from software package as we shifted to single static renv.lock delivered with R run environment.
	deps := runenv.loadFilesFromPackage(rPkgRef, { "renv.lock": path.join(internal.RENV_ROOT_DIR_NAME, "renv.lock") })

	wdForRenv := workdir.builder().
		inQueue(pkg.DEFAULT_ALLOCATION_QUEUE).
		cpu(pkg.DEFAULT_ALLOCATION_CPU).
		mem(pkg.DEFAULT_ALLOCATION_RAM).
		addFile("renv.lock", deps["renv.lock"]).
		build()

	envDirCreator := runenv.saveBuilder(wdForRenv).
		envType("R").
		addPath("renv.lock").
		addPackage("R", rPkgRef)

	rVenv := envDirCreator.build().runEnv()

	//
	// Activate run environment in new working directory
	// Also creates basic renv structure inside <rVenv> if it does not exist.
	// Does not install any packages but renv itself into it.
	//

	plan := internal.runRPlan("init-R-venv", rPkgRef, rRunEnvDescriptor, rVenv)

	wdForDepsInstallation := workdir.builder().
		inQueue(pkg.DEFAULT_ALLOCATION_QUEUE).
		cpu(pkg.DEFAULT_ALLOCATION_CPU).
		mem(pkg.DEFAULT_ALLOCATION_RAM).
		build()

	activatedWD := internal.activateRenvInWD(
		wdForDepsInstallation,
		pkg.DEFAULT_ALLOCATION_QUEUE,
		{ cpu: pkg.DEFAULT_ALLOCATION_CPU, ram: pkg.DEFAULT_ALLOCATION_RAM },
		plan
	)

	//
	// Install dependencies into activated run environment
	// We cannot do it in single step without 'activate', as renv ignores then part of settings,
	// putting renv dir into some location out of our control.
	//

	depsInstaller := runcmd.builder(activatedWD, plan).
		inQueue(pkg.DEFAULT_ALLOCATION_QUEUE).
		cpu(pkg.DEFAULT_ALLOCATION_CPU).
		mem(pkg.DEFAULT_ALLOCATION_RAM)

	depsInstaller.
		cmd("R").
		arg("--no-echo").
		arg("--no-restore").
		arg("-e").arg("renv::restore( clean = TRUE )")

	// R venv becomes available before environment is restored inside it.
	// We need to wait for restoration process to complete before returning the result.
	w := waiter.builder(rVenv)
	w.wait(depsInstaller.build().workdir)

	return w.build().output()
}

self.defineOutputs("runEnv")
self.validateInputs(internal.rVenvInputSchema)
self.body(func(inputs) {
	venv := _createRvenv(
		inputs.operationMode,
		inputs.software,
		inputs.R, inputs.rRunEnvDescriptor,
		inputs.toolset, inputs.dependencies
	)

	return {
		runEnv: venv
	}
})
