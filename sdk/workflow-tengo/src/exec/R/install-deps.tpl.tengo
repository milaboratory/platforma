/**
 * Install dependencies into R virtual environment using standard R toolchain
 */

self := import(":tpl")

ll := import(":ll")
render := import(":render")
workdir := import(":workdir")
path := import(":path")
validation := import(":validation")
internal := import(":exec.R.internal")
pkg := import(":exec.package")

self.defineOutputs("runEnv")

_installRenvDependencies := func(renv, dependencies, rPackage, rDescriptor) {
	lockFileRef := dependencies.lockFile

	wdForDeps :=
		workdir.builder().
			addFile("renv.lock", lockFileRef).
			build()

	activateBuilder :=
		internal.runRenvBuilder(wdForDeps, renv, rPackage, rDescriptor).
			cmd("R").
			arg("-e").
			arg("renv::activate()").

			inQueue("light").
			stdout("./output").
			stderr("./output").
			nErrorLines(20)

	activate := activateBuilder.build()

	actieatedWD := activate.workdir()

	depsBuilder := internal.runRenvBuilder(actieatedWD, renv, rPackage, rDescriptor).
		cmd("R").
		arg("-e").
		arg("renv::restore()").

		inQueue("light").
		stdout("./output").
		stderr("./output").
		nErrorLines(20)

	return depsBuilder.build()
}

self.prepare(func(inputs) {
	// assert we have inputs we expect.
	validation.assertJsonSchema(inputs, {
		venv: validation.reference,
		rPackage: validation.reference,
		rDescriptor: pkg.runEnvDescriptorScheme,

		toolset: "string",
		dependencies: {"string": validation.reference}
	})

	toolset := inputs.toolset
	if toolset == "renv" {
		depsInstall := _installRenvDependencies(inputs.venv, inputs.dependencies, inputs.rPackage, inputs.rDescriptor)
		return {
			runEnv: inputs.venv,
			sync: depsInstall.workdir // we need it to make 'body' wait for dependencies installation into venv
		}
	}

	ll.panic("R dependencies toolset %q is not supported by current version of workflow-sdk", toolset)
})

// We split the template into prepare and body to install dependencies into venv vefore returning it to the caller
self.body(func(inputs) {
	return {
		runEnv: inputs.runEnv
	}
})
