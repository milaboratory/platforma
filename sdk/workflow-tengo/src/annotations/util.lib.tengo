rand := import("rand")
ll := import(":ll")
xsv := import(":pframes.xsv")
sets := import(":sets")
maps := import(":maps")
slices := import(":slices")
strings := import(":strings")

ANNOTATION_HEADER := "annotation"

createFilterFileName := func(colName) {
	return colName + "_filter.tsv"
}

createAxisSpecFactory := func(blockId) {
	return func(type, name, label) {
		return {
			type: type,
			name: "pl7.app/clonotypeAnnotation/" + name,
			domain: {
				"pl7.app/clonotypeAnnotationRunId": blockId
			},
			annotations: {
				"pl7.app/label": label
			}
		}
	}
}

createColumnSpecFactory := func(trace, blockId) {
	return func(type, name, label, axesSpec) {
		return trace.inject({
			kind: "PColumn",
			valueType: type,
			name: "pl7.app/clonotypeAnnotation/" + name,
			domain: {
				"pl7.app/clonotypeAnnotationRunId": blockId
			},
			axesSpec: axesSpec,
			annotations: {
				"pl7.app/label": label
			}
		})
	}
}

createAnnotationsDataAndSpecFactory := func(mainAxes, createColumnSpec, annotationLabel) {
	return func(dataFile) {
		importSpec := {
			cpu: 1,
			mem: "12GiB",
			storageFormat: "Binary",
			partitionKeyLength: 0,
			axes: mainAxes,
			columns: [{
				column: ANNOTATION_HEADER,
				spec: createColumnSpec("String", ANNOTATION_HEADER, annotationLabel, slices.map(mainAxes, func(a) { return a.spec }))
			}]
		}

		return xsv.importFile(dataFile, "tsv", importSpec, { splitDataAndSpec: true })
	}
}

createFilterDataAndSpecFactory := func(mainAxes, createColumnSpec) {
	return func(file, colName, label) {
		filterColumnSpec := maps.deepMerge(createColumnSpec("Int", "filter", label, slices.map(mainAxes, func(a) { return a.spec })), {
			domain: {
				"pl7.app/filterLabel": label
			},
			annotations: {
				"pl7.app/isSubset": "true"
			}
		});
		
		importSpec := {
			cpu: 1,
			mem: "8GiB",
			storageFormat: "Binary",
			partitionKeyLength: 0,
			axes: mainAxes,
			columns: [{
				column: colName,
				spec: filterColumnSpec
			}]
		}

		return xsv.importFile(file, "tsv", importSpec, { splitDataAndSpec: true })
	}
}

createColumnNameManager := func() {
	safeToName := {}

	return {
		toSafe: func(name) {
			safe := strings.substituteSpecialCharacters(name) + "_" + string(rand.int())
			safeToName[safe] = name;
			return safe
		},
		fromSafe: func(safe) {
			return safeToName[safe]
		}
	}
}

isExpression := func(v) {
	return !is_undefined(v) && is_map(v) && is_string(v.type)
}

expressionTraverse := func(expression, visitFn) {
	if (!isExpression(expression)) {
		return
	}

	visitFn(expression)

	// Main switch by expression.type
	t := expression.type

	if t == "col" {
		return
	}

	if t == "const" {
		return
	}

	// Comparisons
	if t == "eq" || t == "neq" || t == "gt" || t == "lt" || t == "ge" || t == "le" {
		expressionTraverse(expression.lhs, visitFn)
		expressionTraverse(expression.rhs, visitFn)
		return
	}

	// Boolean logic
	if t == "and" || t == "or" {
		if is_array(expression.operands) {
			for _, op in expression.operands { expressionTraverse(op, visitFn) }
		}
		return
	}
	if t == "not" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	// Arithmetic binary
	if t == "plus" || t == "minus" || t == "multiply" || t == "truediv" || t == "floordiv" {
		expressionTraverse(expression.lhs, visitFn)
		expressionTraverse(expression.rhs, visitFn)
		return
	}

	// Unary math
	if t == "log10" || t == "log" || t == "log2" || t == "abs" || t == "sqrt" || t == "negate" || t == "floor" || t == "round" || t == "ceil" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	if t == "cast" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	// Null checks
	if t == "is_na" || t == "is_not_na" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	// String ops
	if t == "str_join" {
		if is_array(expression.operands) {
			for _, op in expression.operands { expressionTraverse(op, visitFn) }
		}
		return
	}
	if t == "hash" {
		expressionTraverse(expression.value, visitFn)
		return
	}
	if t == "to_upper" || t == "to_lower" || t == "str_len" {
		expressionTraverse(expression.value, visitFn)
		return
	}
	if t == "string_distance" {
		expressionTraverse(expression.string1, visitFn)
		expressionTraverse(expression.string2, visitFn)
		return
	}
	if t == "fuzzy_string_filter" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}
	if t == "when_then_otherwise" {
		if is_array(expression.conditions) {
			for _, c in expression.conditions {
				// c expected to be a map with when/then
				if is_map(c) {
					expressionTraverse(c.when, visitFn)
					expressionTraverse(c.then, visitFn)
				}
			}
		}
		expressionTraverse(expression.otherwise, visitFn)
		return
	}
	if t == "substring" {
		expressionTraverse(expression.value, visitFn)
		expressionTraverse(expression.start, visitFn)
		if !is_undefined(expression.length) { expressionTraverse(expression.length, visitFn) }
		if !is_undefined(expression.end) { expressionTraverse(expression.end, visitFn) }
		return
	}
	if t == "str_replace" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		if isExpression(expression.replacement) { expressionTraverse(expression.replacement, visitFn) }
		return
	}
	if t == "str_contains" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}
	if t == "str_starts_with" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.prefix) { expressionTraverse(expression.prefix, visitFn) }
		return
	}
	if t == "str_ends_with" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.suffix) { expressionTraverse(expression.suffix, visitFn) }
		return
	}
	if t == "str_contains_any" {
		expressionTraverse(expression.value, visitFn)
		return
	}
	if t == "str_count_matches" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}
	if t == "str_extract" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}

	// Aggregations / window / others
	if t == "min" || t == "max" {
		if is_array(expression.operands) {
			for _, op in expression.operands { expressionTraverse(op, visitFn) }
		}
		return
	}
	if t == "fill_null" || t == "fill_nan" {
		expressionTraverse(expression.input, visitFn)
		expressionTraverse(expression.fillValue, visitFn)
		return
	}
	if t == "aggregate" {
		expressionTraverse(expression.value, visitFn)
		if is_array(expression.partitionBy) {
			for _, p in expression.partitionBy { expressionTraverse(p, visitFn) }
		}
		return
	}
	if t == "rank" {
		if is_array(expression.partitionBy) {
			for _, p in expression.partitionBy { expressionTraverse(p, visitFn) }
		}
		if is_array(expression.orderBy) {
			for _, o in expression.orderBy { expressionTraverse(o, visitFn) }
		}
		return
	}
	if t == "cumsum" {
		expressionTraverse(expression.value, visitFn)
		if is_array(expression.additionalOrderBy) {
			for _, o in expression.additionalOrderBy { expressionTraverse(o, visitFn) }
		}
		if is_array(expression.partitionBy) {
			for _, p in expression.partitionBy { expressionTraverse(p, visitFn) }
		}
		return
	}
	if t == "struct_field" {
		expressionTraverse(expression.struct, visitFn)
		return
	}

	// Unknown type: do nothing
}

addColumnsFromExpression := func(expression, columnsSet) {
	expressionTraverse(expression, func(node) {
		if node.type == "col" {
			// Direct column reference
			if is_string(node.name) {
				sets.add(columnsSet, node.name)
			}
			return
		}
	})
}

mapExpressionColumnNames := func(expression, transformFn) {
	copy := maps.clone(expression)
	
	expressionTraverse(copy, func(node) {
		if node.type == "col" {
			// Direct column reference
			if is_string(node.name) {
				node.name = transformFn(node.name)
			}
		}
	})

	return copy
}

/**
 * Given a list of annotation steps with expressions, computes the annotations data and specifications.
 *
 * @param expressions - An array of annotation steps, each containing a name and an expression.
 * @return - A list of unique column names extracted from the expressions.
 */
extractColumnsFromExpressions := func(expressions) {
	columnsSet := {}

	for expression in expressions {
		addColumnsFromExpression(expression, columnsSet)
	}

	return sets.toSlice(columnsSet)
}

export ll.toStrict({
	ANNOTATION_HEADER: ANNOTATION_HEADER,

	createFilterFileName: createFilterFileName,
	createAxisSpecFactory: createAxisSpecFactory,
	createColumnSpecFactory: createColumnSpecFactory,
	createAnnotationsDataAndSpecFactory: createAnnotationsDataAndSpecFactory,
	createFilterDataAndSpecFactory: createFilterDataAndSpecFactory,
	createColumnNameManager: createColumnNameManager,
	mapExpressionColumnNames: mapExpressionColumnNames,
	extractColumnsFromExpressions: extractColumnsFromExpressions
})
