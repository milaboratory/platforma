hex := import("hex")
rand := import("rand")
text := import("text")

ll := import(":ll")
wf := import(":workflow")
sets := import(":sets")
maps := import(":maps")
slices := import(":slices")

xsv := import(":pframes.xsv")
pSpec := import(":pframes.spec")

expr := import(":pt.expression-traverse")

ANNOTATION_HEADER := "annotation"

createFilterFileName := func(colName) {
	return colName + "_filter.tsv"
}

createAnnotationsDataAndSpec := func(dataFile, columnSpec) {
	importSpec := {
		cpu: 1,
		mem: "12GiB",
		storageFormat: "Binary",
		partitionKeyLength: 0,
		axes: slices.map(columnSpec.axesSpec, func(v) { return { column: pSpec.getAxisId(v), spec: v } }),
		columns: [{
			column: ANNOTATION_HEADER,
			spec: columnSpec
		}]
	}

	return xsv.importFile(dataFile, "tsv", importSpec, { splitDataAndSpec: true })
}

createFilterDataAndSpec := func(file, columnSpec, colName, label) {
	filterColumnSpec := maps.deepMerge(columnSpec, {
		kind: "PColumn",
		valueType: "Int",
		name: columnSpec.name + "/filter/" + colName,
		annotations: {
			"pl7.app/label": columnSpec.annotations["pl7.app/label"] + "/" + label,
			"pl7.app/isSubset": "true"
		}
	});
	
	importSpec := {
		cpu: 1,
		mem: "8GiB",
		storageFormat: "Binary",
		partitionKeyLength: 0,
		axes: slices.map(columnSpec.axesSpec, func(v) { return { column: pSpec.getAxisId(v), spec: v } }),
		columns: [{
			column: colName,
			spec: filterColumnSpec
		}]
	}

	return xsv.importFile(file, "tsv", importSpec, { splitDataAndSpec: true })
}

encodeColumnName := func(name, idx) {
	return hex.encode(name) + "_encoded_" + string(idx)
}

decodeColumnName := func(encoded) {
	parts := text.split(encoded, "_encoded_")
	if len(parts) != 2 {
		ll.panic("Invalid encoded column name: " + encoded)
	}

	return string(hex.decode(parts[0]))
}

addColumnsFromExpression := func(expression, columnsSet) {
	expr.expressionTraverse(expression, func(node) {
		if node.type == "col" {
			// Direct column reference
			if is_string(node.name) {
				sets.add(columnsSet, node.name)
			}
			return
		}
	})
}

mapExpressionColumnNames := func(expression, transformFn) {
	copy := maps.clone(expression)
	
	expr.expressionTraverse(copy, func(node) {
		if node.type == "col" {
			// Direct column reference
			if is_string(node.name) {
				node.name = transformFn(node.name)
			}
		}
	})

	return copy
}

extractColumnsFromExpressions := func(expressions) {
	columnsSet := {}

	for expression in expressions {
		addColumnsFromExpression(expression, columnsSet)
	}

	return sets.toSlice(columnsSet)
}

prepareResultColumnSpec := func(args) {
	blockId := wf.getBlockId()
	
	steps := slices.filter([args.trace, {
		id: blockId,
		type: "milaboratories.annotation",
		label: args.title,
		importance: 20
	}], func(v) { return !is_undefined(v) })
	
	trace := pSpec.makeTrace(steps...)

	return trace.inject({
		kind: "PColumn",
		valueType: "String",
		name: "pl7.app/annotation/result",
		domain: { "pl7.app/annotationRunId": blockId },
		axesSpec: args.resultAxesSpec,
		annotations: { "pl7.app/label": args.title }
	})
}

export ll.toStrict({
	ANNOTATION_HEADER: ANNOTATION_HEADER,

	encodeColumnName: encodeColumnName,
	decodeColumnName: decodeColumnName,
	createFilterFileName: createFilterFileName,
	prepareResultColumnSpec: prepareResultColumnSpec,
	createAnnotationsDataAndSpec: createAnnotationsDataAndSpec,
	createFilterDataAndSpec: createFilterDataAndSpec,
	mapExpressionColumnNames: mapExpressionColumnNames,
	extractColumnsFromExpressions: extractColumnsFromExpressions
})
