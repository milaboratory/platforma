pt := import(":pt")
wf := import(":workflow")
ll := import(":ll")
pFrames := import(":pframes")
slices := import(":slices")
util := import(":annotations.util")

DATA_FILE := "data.tsv"
ANNOTATION_HEADER := util.ANNOTATION_HEADER

/**
 * Computes annotations and optional filters based on the provided steps and column bundle.
 *
 * @param inputs: A map containing the following keys:
 *   - title: The title for the annotations.
 *   - steps: An array of steps, each containing a name and an expression.
 *   - mainAxis: The main axis specification.
 *   - columnBundle: The column bundle to extract columns from.
 *   - shouldComputeFilters: A boolean indicating whether to compute filters.
 *   - createAxisSpec: A function to create axis specifications.
 *   - createColumnSpec: A function to create column specifications.
 *
 * @returns: A map containing:
 *   - annotations: The computed annotations with their data and specification.
 *   - annotationsFilters (optional): An array of computed filters with their data and specifications.
 */
computeAnnotations := func(inputs) {
	outputs := {}

	title := inputs.title
	steps := inputs.steps

	mainAxis := inputs.mainAxis
	columnBundle := inputs.columnBundle
	shouldComputeFilters := inputs.shouldComputeFilters

	createAxisSpec := inputs.createAxisSpec
	createColumnSpec := inputs.createColumnSpec

	if len(steps) == 0 || is_undefined(columnBundle) {
		return outputs
	}

	columnsFromExpressions := util.extractColumnsFromExpressions(slices.map(steps, func(step) {
		return step.expression
	}))

	annotationsAxisSpec := createAxisSpec("String", ANNOTATION_HEADER, title)

	createAnnotationsDataAndSpec := util.createAnnotationsDataAndSpecFactory(mainAxis, createColumnSpec, title)
	createFilterDataAndSpec := util.createFilterDataAndSpecFactory(mainAxis, createColumnSpec)

	tableBuilder := pFrames.tsvFileBuilder().cpu(1).mem(string(1 + len(columnsFromExpressions) * 2) + "GiB")
	tableBuilder.setAxisHeader(mainAxis.spec, mainAxis.column)
	for colId in columnsFromExpressions {
		tableBuilder.add(columnBundle.getColumn(colId))
	}
	sourceFile := tableBuilder.build()

	columnNameManager := util.createColumnNameManager()

	finalExpressions := slices.map(steps, func(step) {
		return {
			name: columnNameManager.toSafe(step.name),
			expression: util.mapExpressionColumnNames(step.expression, func(colId) {
				return tableBuilder.getHeader(colId)
			})
		}
	})

	safeColumnNames := slices.map(finalExpressions, func(spec) {
		return spec.name
	})
	filterSafeColumnNames := shouldComputeFilters ? safeColumnNames : [];
	safeColumnNamesReversed := slices.reverse(safeColumnNames)

	annotationColumnExpr := slices.
		reduce(safeColumnNamesReversed, func(exp, colName) {
			return exp.when(pt.col(colName)).then(pt.lit(columnNameManager.fromSafe(colName)))
		}, pt).
		otherwise(pt.lit(undefined)).
		alias(ANNOTATION_HEADER)

	wf := pt.workflow()
	
	dfData := wf.frame(sourceFile, { format: "tsv" }).
		withColumns(finalExpressions...).
		withColumns(annotationColumnExpr)

	dfData.
		select(mainAxis.column, ANNOTATION_HEADER).
	    save(DATA_FILE)

	for colName in filterSafeColumnNames {
		dfData.
			filter(pt.col(ANNOTATION_HEADER).eq(pt.lit(columnNameManager.fromSafe(colName)))).
			withColumns(pt.lit(1).alias(ANNOTATION_HEADER).alias(colName)).
			select(mainAxis.column, colName).
			save(util.createFilterFileName(colName))
	}
	
    wfResult := wf.run()

	dataFile := wfResult.getFile(DATA_FILE)
	filterFiles := slices.map(filterSafeColumnNames, func(colName) {
		return { name: colName, file: wfResult.getFile(util.createFilterFileName(colName)) }
	})

	annotationsDataAndSpec := createAnnotationsDataAndSpec(dataFile)
	outputs["annotations"] = {
		column: ANNOTATION_HEADER,
		file: dataFile,
		data: annotationsDataAndSpec[ANNOTATION_HEADER].data,
		spec: annotationsDataAndSpec[ANNOTATION_HEADER].spec
	}

	outputs["annotationsFilters"] = slices.map(filterFiles, func(v) {
		label := columnNameManager.fromSafe(v.name)
		specAndData := createFilterDataAndSpec(v.file, v.name, label)
		return {
			column: v.name,
			file: v.file,
			data: specAndData[v.name].data,
			spec: specAndData[v.name].spec
		}
	})

	return outputs
}

export ll.toStrict({
	computeAnnotations: computeAnnotations,
	extractColumnsFromExpressions: util.extractColumnsFromExpressions
})
