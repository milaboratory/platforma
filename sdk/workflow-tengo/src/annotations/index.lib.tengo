pt := import(":pt")
wf := import(":workflow")
ll := import(":ll")
pFrames := import(":pframes")
slices := import(":slices")
util := import(":annotations.util")

DATA_FILE := "data.tsv"
ANNOTATION_HEADER := util.ANNOTATION_HEADER

computeAnnotations := func(inputs) {
	outputs := {}

	title := inputs.title
	steps := inputs.steps

	mainAxis := inputs.mainAxis
	columnBundle := inputs.columnBundle

	blockId := inputs.blockId
	traceSpec := inputs.traceSpec
	
	shouldComputeFilters := inputs.shouldComputeFilters

	if len(steps) == 0 || is_undefined(columnBundle) {
		return outputs
	}

	columnsFromExpressions := util.extractColumnsFromExpressions(slices.map(steps, func(step) {
		return step.expression
	}))

	createAxisSpec := util.createAxisSpecFactory(blockId)
	createColumnSpec := util.createColumnSpecFactory(traceSpec, blockId)

	annotationsAxisSpec := createAxisSpec("String", ANNOTATION_HEADER, title)
	
	createAnnotationsDataAndSpec := util.createAnnotationsDataAndSpecFactory(mainAxis, createColumnSpec, title)
	createFilterDataAndSpec := util.createFilterDataAndSpecFactory(mainAxis, createColumnSpec)


	tableBuilder := pFrames.tsvFileBuilder().cpu(1).mem(string(1 + len(columnsFromExpressions) * 2) + "GiB")
	tableBuilder.setAxisHeader(mainAxis.spec, mainAxis.column)
	for colId in columnsFromExpressions {
		tableBuilder.add(columnBundle.getColumn(colId))
	}
	sourceFile := tableBuilder.build()

	columnNameManager := util.createColumnNameManager()

	finalExpressions := slices.map(steps, func(step) {
		return {
			name: columnNameManager.toSafe(step.name),
			expression: util.mapExpressionColumnNames(step.expression, func(colId) {
				return tableBuilder.getHeader(colId)
			})
		}
	})

	safeColumnNames := slices.map(finalExpressions, func(spec) {
		return spec.name
	})
	filterSafeColumnNames := shouldComputeFilters ? safeColumnNames : [];
	safeColumnNamesReversed := slices.reverse(safeColumnNames)

	annotationColumnExpr := slices.
		reduce(safeColumnNamesReversed, func(exp, colName) {
			return exp.when(pt.col(colName)).then(pt.lit(columnNameManager.fromSafe(colName)))
		}, pt).
		otherwise(pt.lit(undefined)).
		alias(ANNOTATION_HEADER)

	wf := pt.workflow()
	
	dfData := wf.frame(sourceFile, { format: "tsv" }).
		withColumns(finalExpressions...).
		withColumns(annotationColumnExpr)

	dfData.
		select(mainAxis.column, ANNOTATION_HEADER).
	    save(DATA_FILE)

	for colName in filterSafeColumnNames {
		dfData.
			filter(pt.col(ANNOTATION_HEADER).eq(pt.lit(columnNameManager.fromSafe(colName)))).
			withColumns(pt.lit(1).alias(ANNOTATION_HEADER).alias(colName)).
			select(mainAxis.column, colName).
			save(util.createFilterFileName(colName))
	}
	
    wfResult := wf.run()

	dataFile := wfResult.getFile(DATA_FILE)
	filterFiles := slices.map(filterSafeColumnNames, func(colName) {
		return { name: colName, file: wfResult.getFile(util.createFilterFileName(colName)) }
	})

	annotationsDataAndSpec := createAnnotationsDataAndSpec(dataFile)
	outputs["annotations"] = {
		column: ANNOTATION_HEADER,
		file: dataFile,
		data: annotationsDataAndSpec[ANNOTATION_HEADER].data,
		spec: annotationsDataAndSpec[ANNOTATION_HEADER].spec
	}

	// if (!shouldComputeFilters) {
	// 	return outputs
	// }

	outputs["annotationsFilters"] = slices.map(filterFiles, func(v) {
		label := columnNameManager.fromSafe(v.name)
		specAndData := createFilterDataAndSpec(v.file, v.name, label)
		return {
			column: v.name,
			file: v.file,
			data: specAndData[v.name].data,
			spec: specAndData[v.name].spec
		}
	})

	return outputs
}

export ll.toStrict({
	computeAnnotations: computeAnnotations,
	extractColumnsFromExpressions: util.extractColumnsFromExpressions
})
