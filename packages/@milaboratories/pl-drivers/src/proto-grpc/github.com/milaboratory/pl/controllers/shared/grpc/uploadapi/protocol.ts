// @generated by protobuf-ts 2.11.1 with parameter client_generic,optimize_speed,generate_dependencies,force_server_none
// @generated from protobuf file "github.com/milaboratory/pl/controllers/shared/grpc/uploadapi/protocol.proto" (package "MiLaboratories.Controller.Shared", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI
 */
export interface UploadAPI {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.Init
 */
export interface UploadAPI_Init {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.Init.Request
 */
export interface UploadAPI_Init_Request {
    /**
     * Id of upload resource
     *
     * @generated from protobuf field: uint64 resource_id = 1
     */
    resourceId: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.Init.Response
 */
export interface UploadAPI_Init_Response {
    /**
     * Number of parts in this upload.
     * For parallel upload support, client can generate any number of part upload URLs
     * at the moment and upload them in parallel.
     * <parts_count> keeps the number of chunks supported by this upload.
     * The parts count is calculated from the planned size of the upload, controller
     * configuration and underlying storage restrictions.
     *
     * @generated from protobuf field: uint64 parts_count = 1
     */
    partsCount: bigint;
    /**
     * @generated from protobuf field: uint64 part_size = 3
     */
    partSize: bigint;
    /**
     * Checksum algorithm to use for the part upload.
     *
     * @generated from protobuf field: MiLaboratories.Controller.Shared.UploadAPI.ChecksumAlgorithm checksum_algorithm = 4
     */
    checksumAlgorithm: UploadAPI_ChecksumAlgorithm;
    /**
     * Header name to use for the checksum.
     *
     * @generated from protobuf field: string checksum_header = 5
     */
    checksumHeader: string;
    /**
     * List of IDs of parts that were already uploaded by client.
     * Helps client to recover upload and skip already done parts
     * after being interrupted in the middle of the upload
     * (say, because of the restart).
     * Parts enumeration starts from 1.
     *
     * @generated from protobuf field: repeated uint64 uploaded_parts = 2
     */
    uploadedParts: bigint[];
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress
 */
export interface UploadAPI_UpdateProgress {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress.Request
 */
export interface UploadAPI_UpdateProgress_Request {
    /**
     * Id of upload resource
     *
     * @generated from protobuf field: uint64 resource_id = 1
     */
    resourceId: bigint;
    /**
     * Amount of bytes, uploaded since the earlier call to UpdateProgress.
     * This value is just blindly added to the 'bytes_processed' of progress report,
     * so other clients can see the upload progress.
     * If client uploads the data in several streams (several chunks in parallel), it
     * can safely send progress updates individually for each of the streams, just counting
     * bytes uploaded by particular stream.
     *
     * Negative value can be used to report about upload retry: when upload was interrupted,
     * part of the uploaded data is lost and require re-upload.
     *
     * @generated from protobuf field: int64 bytes_processed = 2
     */
    bytesProcessed: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress.Response
 */
export interface UploadAPI_UpdateProgress_Response {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL
 */
export interface UploadAPI_GetPartURL {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.Request
 */
export interface UploadAPI_GetPartURL_Request {
    /**
     * Id of upload resource
     *
     * @generated from protobuf field: uint64 resource_id = 1
     */
    resourceId: bigint;
    /**
     * Part to be uploaded. It is responsibility of the Client to watch after already uploaded parts:
     * - client can request an URL for the same part twice (request -> request) without errors;
     * - client can request an URL for alrady uploaded part (request -> upload -> request) without errors.
     *
     * Parts enumeration starts from 1.
     *
     * @generated from protobuf field: uint64 part_number = 2
     */
    partNumber: bigint;
    /**
     * Size of the part uploaded by client earlier. Allows controller to count upload progress
     * based on client's input.
     * Client is free to never sent this value (send zeroes in each request).
     *
     * @generated from protobuf field: uint64 uploaded_part_size = 3
     */
    uploadedPartSize: bigint;
    /**
     * Do we need to presign URL for internal use.
     * Controllers could use this if they are trying to download something from internal network.
     * For backward compatibility, by default pl backend will presign external urls.
     *
     * @generated from protobuf field: bool is_internal_use = 4
     */
    isInternalUse: boolean;
    /**
     * Checksum is not used for now, but it is here for case
     * where signing checksum header is required.
     *
     * @generated from protobuf field: string part_checksum = 5
     */
    partChecksum: string;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.HTTPHeader
 */
export interface UploadAPI_GetPartURL_HTTPHeader {
    /**
     * @generated from protobuf field: string Name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string Value = 2
     */
    value: string;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.Response
 */
export interface UploadAPI_GetPartURL_Response {
    /**
     * URL for chunk upload
     *
     * @generated from protobuf field: string upload_url = 1
     */
    uploadUrl: string;
    /**
     * HTTP method to use for chunk upload, say 'PUT' or 'POST'.
     *
     * @generated from protobuf field: string method = 2
     */
    method: string;
    /**
     * List of headers with their values, MANDATORY to be sent by the client for the upload.
     * The destination service (the one, that will handle upload request for specific part)
     * may reject the request if it would not keep the given headers.
     *
     * @generated from protobuf field: repeated MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.HTTPHeader headers = 3
     */
    headers: UploadAPI_GetPartURL_HTTPHeader[];
    /**
     * The number of the _first_ byte in the chunk.
     * Absolute position from the start of the file ( file.seek(<chunk_start>, SEEK_START) ).
     * The client is expected to send [<chunk_start>; <chunk_end>) range.
     *
     * @generated from protobuf field: uint64 chunk_start = 4
     */
    chunkStart: bigint;
    /**
     * The number of the byte _after_ the last to be sent in the chunk.
     * Absolute position from the start of the file.
     * The client is expected to send [<chunk_start>; <chunk_end>) range.
     *
     * @generated from protobuf field: uint64 chunk_end = 5
     */
    chunkEnd: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.Finalize
 */
export interface UploadAPI_Finalize {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.Finalize.Request
 */
export interface UploadAPI_Finalize_Request {
    /**
     * @generated from protobuf field: uint64 resource_id = 1
     */
    resourceId: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.UploadAPI.Finalize.Response
 */
export interface UploadAPI_Finalize_Response {
}
/**
 * @generated from protobuf enum MiLaboratories.Controller.Shared.UploadAPI.ChecksumAlgorithm
 */
export enum UploadAPI_ChecksumAlgorithm {
    /**
     * @generated from protobuf enum value: CHECKSUM_ALGORITHM_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CHECKSUM_ALGORITHM_CRC32C = 1;
     */
    CRC32C = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI$Type extends MessageType<UploadAPI> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI", []);
    }
    create(value?: PartialMessage<UploadAPI>): UploadAPI {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI): UploadAPI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI
 */
export const UploadAPI = new UploadAPI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_Init$Type extends MessageType<UploadAPI_Init> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.Init", []);
    }
    create(value?: PartialMessage<UploadAPI_Init>): UploadAPI_Init {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_Init>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_Init): UploadAPI_Init {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_Init, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.Init
 */
export const UploadAPI_Init = new UploadAPI_Init$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_Init_Request$Type extends MessageType<UploadAPI_Init_Request> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.Init.Request", [
            { no: 1, name: "resource_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_Init_Request>): UploadAPI_Init_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceId = 0n;
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_Init_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_Init_Request): UploadAPI_Init_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 resource_id */ 1:
                    message.resourceId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_Init_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 resource_id = 1; */
        if (message.resourceId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.resourceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.Init.Request
 */
export const UploadAPI_Init_Request = new UploadAPI_Init_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_Init_Response$Type extends MessageType<UploadAPI_Init_Response> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.Init.Response", [
            { no: 1, name: "parts_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "part_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "checksum_algorithm", kind: "enum", T: () => ["MiLaboratories.Controller.Shared.UploadAPI.ChecksumAlgorithm", UploadAPI_ChecksumAlgorithm, "CHECKSUM_ALGORITHM_"] },
            { no: 5, name: "checksum_header", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uploaded_parts", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_Init_Response>): UploadAPI_Init_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.partsCount = 0n;
        message.partSize = 0n;
        message.checksumAlgorithm = 0;
        message.checksumHeader = "";
        message.uploadedParts = [];
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_Init_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_Init_Response): UploadAPI_Init_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 parts_count */ 1:
                    message.partsCount = reader.uint64().toBigInt();
                    break;
                case /* uint64 part_size */ 3:
                    message.partSize = reader.uint64().toBigInt();
                    break;
                case /* MiLaboratories.Controller.Shared.UploadAPI.ChecksumAlgorithm checksum_algorithm */ 4:
                    message.checksumAlgorithm = reader.int32();
                    break;
                case /* string checksum_header */ 5:
                    message.checksumHeader = reader.string();
                    break;
                case /* repeated uint64 uploaded_parts */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uploadedParts.push(reader.uint64().toBigInt());
                    else
                        message.uploadedParts.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_Init_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 parts_count = 1; */
        if (message.partsCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.partsCount);
        /* repeated uint64 uploaded_parts = 2; */
        if (message.uploadedParts.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uploadedParts.length; i++)
                writer.uint64(message.uploadedParts[i]);
            writer.join();
        }
        /* uint64 part_size = 3; */
        if (message.partSize !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.partSize);
        /* MiLaboratories.Controller.Shared.UploadAPI.ChecksumAlgorithm checksum_algorithm = 4; */
        if (message.checksumAlgorithm !== 0)
            writer.tag(4, WireType.Varint).int32(message.checksumAlgorithm);
        /* string checksum_header = 5; */
        if (message.checksumHeader !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.checksumHeader);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.Init.Response
 */
export const UploadAPI_Init_Response = new UploadAPI_Init_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_UpdateProgress$Type extends MessageType<UploadAPI_UpdateProgress> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress", []);
    }
    create(value?: PartialMessage<UploadAPI_UpdateProgress>): UploadAPI_UpdateProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_UpdateProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_UpdateProgress): UploadAPI_UpdateProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_UpdateProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress
 */
export const UploadAPI_UpdateProgress = new UploadAPI_UpdateProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_UpdateProgress_Request$Type extends MessageType<UploadAPI_UpdateProgress_Request> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress.Request", [
            { no: 1, name: "resource_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bytes_processed", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_UpdateProgress_Request>): UploadAPI_UpdateProgress_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceId = 0n;
        message.bytesProcessed = 0n;
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_UpdateProgress_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_UpdateProgress_Request): UploadAPI_UpdateProgress_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 resource_id */ 1:
                    message.resourceId = reader.uint64().toBigInt();
                    break;
                case /* int64 bytes_processed */ 2:
                    message.bytesProcessed = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_UpdateProgress_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 resource_id = 1; */
        if (message.resourceId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.resourceId);
        /* int64 bytes_processed = 2; */
        if (message.bytesProcessed !== 0n)
            writer.tag(2, WireType.Varint).int64(message.bytesProcessed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress.Request
 */
export const UploadAPI_UpdateProgress_Request = new UploadAPI_UpdateProgress_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_UpdateProgress_Response$Type extends MessageType<UploadAPI_UpdateProgress_Response> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress.Response", []);
    }
    create(value?: PartialMessage<UploadAPI_UpdateProgress_Response>): UploadAPI_UpdateProgress_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_UpdateProgress_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_UpdateProgress_Response): UploadAPI_UpdateProgress_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_UpdateProgress_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.UpdateProgress.Response
 */
export const UploadAPI_UpdateProgress_Response = new UploadAPI_UpdateProgress_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_GetPartURL$Type extends MessageType<UploadAPI_GetPartURL> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.GetPartURL", []);
    }
    create(value?: PartialMessage<UploadAPI_GetPartURL>): UploadAPI_GetPartURL {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_GetPartURL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_GetPartURL): UploadAPI_GetPartURL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_GetPartURL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL
 */
export const UploadAPI_GetPartURL = new UploadAPI_GetPartURL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_GetPartURL_Request$Type extends MessageType<UploadAPI_GetPartURL_Request> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.Request", [
            { no: 1, name: "resource_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "part_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "uploaded_part_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_internal_use", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "part_checksum", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_GetPartURL_Request>): UploadAPI_GetPartURL_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceId = 0n;
        message.partNumber = 0n;
        message.uploadedPartSize = 0n;
        message.isInternalUse = false;
        message.partChecksum = "";
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_GetPartURL_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_GetPartURL_Request): UploadAPI_GetPartURL_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 resource_id */ 1:
                    message.resourceId = reader.uint64().toBigInt();
                    break;
                case /* uint64 part_number */ 2:
                    message.partNumber = reader.uint64().toBigInt();
                    break;
                case /* uint64 uploaded_part_size */ 3:
                    message.uploadedPartSize = reader.uint64().toBigInt();
                    break;
                case /* bool is_internal_use */ 4:
                    message.isInternalUse = reader.bool();
                    break;
                case /* string part_checksum */ 5:
                    message.partChecksum = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_GetPartURL_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 resource_id = 1; */
        if (message.resourceId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.resourceId);
        /* uint64 part_number = 2; */
        if (message.partNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.partNumber);
        /* uint64 uploaded_part_size = 3; */
        if (message.uploadedPartSize !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.uploadedPartSize);
        /* bool is_internal_use = 4; */
        if (message.isInternalUse !== false)
            writer.tag(4, WireType.Varint).bool(message.isInternalUse);
        /* string part_checksum = 5; */
        if (message.partChecksum !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.partChecksum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.Request
 */
export const UploadAPI_GetPartURL_Request = new UploadAPI_GetPartURL_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_GetPartURL_HTTPHeader$Type extends MessageType<UploadAPI_GetPartURL_HTTPHeader> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.HTTPHeader", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_GetPartURL_HTTPHeader>): UploadAPI_GetPartURL_HTTPHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_GetPartURL_HTTPHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_GetPartURL_HTTPHeader): UploadAPI_GetPartURL_HTTPHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name */ 1:
                    message.name = reader.string();
                    break;
                case /* string Value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_GetPartURL_HTTPHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.HTTPHeader
 */
export const UploadAPI_GetPartURL_HTTPHeader = new UploadAPI_GetPartURL_HTTPHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_GetPartURL_Response$Type extends MessageType<UploadAPI_GetPartURL_Response> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.Response", [
            { no: 1, name: "upload_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UploadAPI_GetPartURL_HTTPHeader },
            { no: 4, name: "chunk_start", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "chunk_end", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_GetPartURL_Response>): UploadAPI_GetPartURL_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uploadUrl = "";
        message.method = "";
        message.headers = [];
        message.chunkStart = 0n;
        message.chunkEnd = 0n;
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_GetPartURL_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_GetPartURL_Response): UploadAPI_GetPartURL_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string upload_url */ 1:
                    message.uploadUrl = reader.string();
                    break;
                case /* string method */ 2:
                    message.method = reader.string();
                    break;
                case /* repeated MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.HTTPHeader headers */ 3:
                    message.headers.push(UploadAPI_GetPartURL_HTTPHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 chunk_start */ 4:
                    message.chunkStart = reader.uint64().toBigInt();
                    break;
                case /* uint64 chunk_end */ 5:
                    message.chunkEnd = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_GetPartURL_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string upload_url = 1; */
        if (message.uploadUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uploadUrl);
        /* string method = 2; */
        if (message.method !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.method);
        /* repeated MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.HTTPHeader headers = 3; */
        for (let i = 0; i < message.headers.length; i++)
            UploadAPI_GetPartURL_HTTPHeader.internalBinaryWrite(message.headers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 chunk_start = 4; */
        if (message.chunkStart !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.chunkStart);
        /* uint64 chunk_end = 5; */
        if (message.chunkEnd !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.chunkEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.GetPartURL.Response
 */
export const UploadAPI_GetPartURL_Response = new UploadAPI_GetPartURL_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_Finalize$Type extends MessageType<UploadAPI_Finalize> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.Finalize", []);
    }
    create(value?: PartialMessage<UploadAPI_Finalize>): UploadAPI_Finalize {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_Finalize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_Finalize): UploadAPI_Finalize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_Finalize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.Finalize
 */
export const UploadAPI_Finalize = new UploadAPI_Finalize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_Finalize_Request$Type extends MessageType<UploadAPI_Finalize_Request> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.Finalize.Request", [
            { no: 1, name: "resource_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UploadAPI_Finalize_Request>): UploadAPI_Finalize_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceId = 0n;
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_Finalize_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_Finalize_Request): UploadAPI_Finalize_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 resource_id */ 1:
                    message.resourceId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_Finalize_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 resource_id = 1; */
        if (message.resourceId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.resourceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.Finalize.Request
 */
export const UploadAPI_Finalize_Request = new UploadAPI_Finalize_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadAPI_Finalize_Response$Type extends MessageType<UploadAPI_Finalize_Response> {
    constructor() {
        super("MiLaboratories.Controller.Shared.UploadAPI.Finalize.Response", []);
    }
    create(value?: PartialMessage<UploadAPI_Finalize_Response>): UploadAPI_Finalize_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadAPI_Finalize_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadAPI_Finalize_Response): UploadAPI_Finalize_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadAPI_Finalize_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.UploadAPI.Finalize.Response
 */
export const UploadAPI_Finalize_Response = new UploadAPI_Finalize_Response$Type();
/**
 * @generated ServiceType for protobuf service MiLaboratories.Controller.Shared.Upload
 */
export const Upload = new ServiceType("MiLaboratories.Controller.Shared.Upload", [
    { name: "Init", options: { "google.api.http": { post: "/v1/upload/init", body: "*" } }, I: UploadAPI_Init_Request, O: UploadAPI_Init_Response },
    { name: "GetPartURL", options: { "google.api.http": { post: "/v1/upload/get-part-url", body: "*" } }, I: UploadAPI_GetPartURL_Request, O: UploadAPI_GetPartURL_Response },
    { name: "UpdateProgress", options: { "google.api.http": { post: "/v1/upload/update-progress", body: "*" } }, I: UploadAPI_UpdateProgress_Request, O: UploadAPI_UpdateProgress_Response },
    { name: "Finalize", options: { "google.api.http": { post: "/v1/upload/finalize", body: "*" } }, I: UploadAPI_Finalize_Request, O: UploadAPI_Finalize_Response }
]);
