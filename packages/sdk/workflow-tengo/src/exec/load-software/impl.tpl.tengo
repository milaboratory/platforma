self := import(":tpl.light")

ll := import(":ll")
json := import("json")
text := import("text")
maps := import(":maps")
path := import(":path")
pkg := import(":exec.package")
runcmd := import(":exec.runcmd")
python := import(":exec.python")
conda := import(":exec.conda")
R := import(":exec.R")
desc := import(":exec.descriptor")
validation := import(":validation")

//
// Variables, substituted in command arguments and environment variable values.
//
_ARG_VAR_PKG                 := "pkg"  // abs path to software package

_ARG_VAR_JAVA                := "java" // abs path to 'java' run environment

_ARG_VAR_CONDA               := "conda" // abs path to conda package (basically equal to {pkg}).
_ARG_VAR_CONDA_ENV           := "conda_env" // abs path to conda environment restored on runner side.

_ARG_VAR_PYTHON_VENV         := "python" // abs path to python virtual environment. WARNING: not change the name, it's used in other part of code
_ARG_VAR_PYTHON_RUN_ENV      := "python_run_env" // abs path to python run environment used to create venv
_ARG_VAR_VENV_BIN_DIR        := "venv_bin_dir" // name of bin dir in python venv depending on OS type (Scripts on Windows, bin on Unix)
_ARG_PYTHON_LOCAL_SCRIPT_DIR := "python_local_script_dir" // abs path to directory with local python scripts.
_ARG_PATH_DELIMETER          := "path_delimeter"

/** Converts the args above to the expressions. */
_expr := func(varName) {
	return "{" + varName + "}"
}

_newRefVar := func(varName, refName, reference) {
	return ll.toStrict({
		varName: varName,
		refName: refName,
		reference: reference
	})
}

_installSoftware := func(registry, pkgName) {
	ll.assert(is_string(registry), "exec.internal._installSoftware(): registry is not a string, got: %v", registry, pkgName)
	ll.assert(is_string(pkgName), "exec.internal._installSoftware(): pkgName is not a string, got: %v", pkgName, registry)

	archive := pkg.get(registry, pkgName).archive()
	return pkg.install(archive).package()
}

_loadJavaRunEnvironment := func(operationMode, descriptor) {
	plan := runcmd.createRunCommandPlan()

	javaPkg := _installSoftware(descriptor.runEnv.registry, descriptor.runEnv.package)
	plan.refVar(_ARG_VAR_JAVA, descriptor.runEnv.name, javaPkg)

	plan.addPathExpression(path.join(_expr(_ARG_VAR_JAVA), descriptor.runEnv.binDir))

	return ll.toStrict({
		runEnvType: "java",
		plan:       plan
	})
}

_loadCondaRunEnvironment := func(operationMode, condaDescriptor, softName, condaPkg) {
	validation.assert(operationMode != "dev-local", "conda run environment does not support dev-local mode yet (not implemented)")

	plan := runcmd.createRunCommandPlan()

	env := conda.condaBuilder(condaDescriptor).
		software(condaPkg).
		cacheDays(7).
		build()

	plan.refVar(_ARG_VAR_CONDA, softName + "/conda", env.conda())
	plan.refVar(_ARG_VAR_CONDA_ENV, softName + "/condaEnv", env.env())

	plan.envExpression("MAMBA_ROOT_PREFIX", path.join(_expr(_ARG_VAR_CONDA), condaDescriptor["conda-root-dir"]))
	plan.envExpression("CONDA_PKGS_DIRS", path.join(_expr(_ARG_VAR_CONDA), condaDescriptor["conda-root-dir"], "pkgs"))

	return ll.toStrict({
		runEnvType: "conda",
		plan:       plan
	})
}

_loadPythonRunEnvironment := func(operationMode, descriptor, softName, softPkg) {
	plan := runcmd.createRunCommandPlan()

	venvBuilder := python.venvBuilder().
		software(softPkg).
		runEnvDescriptor(descriptor.runEnv).
		dependencies(descriptor.dependencies)

	if !is_undefined(descriptor.toolset) && descriptor.toolset != "" {
		venvBuilder.useToolset(descriptor.toolset)
	}

	venv := venvBuilder.
		cacheDays(7).
		build()

	plan.refVar(_ARG_VAR_PYTHON_RUN_ENV, softName + "/python", venv.python())
	plan.refVar(_ARG_VAR_PYTHON_VENV, softName + "/venv", venv.venv())
	plan.refVar(_ARG_VAR_VENV_BIN_DIR, softName + "/binDir", venv.binDir() )
	plan.refVar(_ARG_PATH_DELIMETER, softName + "/pathDelimeter", venv.pathDelimeter())

	plan.addPathExpression(path.join(_expr(_ARG_VAR_PYTHON_VENV), "venv", _expr(_ARG_VAR_VENV_BIN_DIR)))
	plan.envExpression("VIRTUAL_ENV", path.join(_expr(_ARG_VAR_PYTHON_VENV), "venv"))
	plan.envExpression("PYTHONHOME", _expr(_ARG_VAR_PYTHON_RUN_ENV))
	plan.envExpression("PYTHONPATH", path.join(_expr(_ARG_VAR_PYTHON_RUN_ENV), descriptor.runEnv.binDir, "python_stdlib") + _expr(_ARG_PATH_DELIMETER) + _expr(_ARG_VAR_PKG))

	if !is_undefined(descriptor.runEnv.envVars) {
		for envVar in descriptor.runEnv.envVars {
			split := text.split(envVar, "=")
			plan.envExpression(split[0], split[1])
		}
	}

	return ll.toStrict({
		runEnvType: "python",
		plan:       plan
	})
}

_loadRRunEnvironment := func(operationMode, descriptor, softName, softPkg) {
	rVenvBuilder := R.rVenvBuilder().
		operationMode(operationMode).
		software(softPkg).
		runEnvDescriptor(descriptor.runEnv).
		dependencies(descriptor.dependencies)

	if !is_undefined(descriptor.toolset) && descriptor.toolset != "" {
		rVenvBuilder.useToolset(descriptor.toolset)
	}

	rRuntime := rVenvBuilder.
		cacheDays(7).
		build()

	plan := R.runRPlan(
		softName,
		rRuntime.R(),
		descriptor.runEnv,
		undefined // no separate renv location, keep it in current working directory
	)

	return ll.toStrict({
		runEnvType: "R",
		plan:       plan
	})
}


_loadRunEnvironment := func(operationMode, descriptor, softName, softPackage) {
	if descriptor.runEnv.type == "java" {
		return _loadJavaRunEnvironment(operationMode, descriptor)
	}
	if descriptor.runEnv.type == "python" {
		return _loadPythonRunEnvironment(operationMode, descriptor, softName, softPackage)
	}
	if descriptor.runEnv.type == "R" {
		return _loadRRunEnvironment(operationMode, descriptor, softName, softPackage)
	}

	ll.panic("run environment type %q is not currently supported by workflow-sdk",	descriptor.runEnv.type)
}

/**
 * @param operationMode: "remote" | "dev-local"
 */
_binPackageCallOptions := func(operationMode, softwareName, variables, descriptor, softPackage) {
	runEnvPlan := runcmd.createRunCommandPlan()
	runEnvType := "binary"

	cmd := descriptor.cmd

	// Real command should be:
	//   [<runEnv bin>] [<runEnv options>] [<entrypoint bin>] [<entrypoint options>] <cmd> <args>
	if (maps.containsKey(descriptor, "runEnv")) {
		runEnvInfo := _loadRunEnvironment(operationMode, descriptor, softwareName, softPackage)
		runEnvPlan = runEnvInfo.plan
		runEnvType = runEnvInfo.runEnvType
	} else if descriptor.type == "conda" {
		runEnvInfo := _loadCondaRunEnvironment(operationMode, descriptor, softwareName, softPackage)
		runEnvPlan = runEnvInfo.plan
		runEnvType = runEnvInfo.runEnvType

		origCmd := cmd
		cmd = append([
			path.join(_expr(_ARG_VAR_CONDA), "micromamba"),
			"run",
			"--prefix", path.join(_expr(_ARG_VAR_CONDA_ENV), "env")
			], origCmd...)
	}

	ll.assert(
		len(cmd) != 0,
		"cannot render final command for software: empty 'cmd' in software descriptor")

	plan := runcmd.createRunCommandPlan(runEnvPlan.state())

	for _, v in variables {
		plan.refVar(v.varName, v.refName, v.reference)
	}

	plan.cmdExpression(cmd[0])

	for arg in splice(cmd, 1) {
		plan.argExpression(arg)
	}

	return ll.toStrict({
		runEnvType: runEnvType,
		plan:       plan
	})
}

_devLocalPackageCallOptions := func(softwareName, localDescriptor) {
	softPackage := pkg.use({
		hash: localDescriptor.hash,
		path: localDescriptor.path,
		descriptor: json.encode(ll.fromStrict(localDescriptor)),
		origin: {
			registry: "dev-local",
			url: "file://" + localDescriptor.path,
			packageName: softwareName
		}
	}).package()

	variables := [ _newRefVar(_ARG_VAR_PKG, softwareName, softPackage) ]

	return _binPackageCallOptions("dev-local", softwareName, variables, localDescriptor, softPackage)
}

_remotePackageCallOptions := func(softwareName, binaryDescriptor) {
	softPackage := _installSoftware(binaryDescriptor.registry, binaryDescriptor.package)

	variables := [ _newRefVar(_ARG_VAR_PKG, softwareName, softPackage) ]

	return _binPackageCallOptions("remote", softwareName, variables, binaryDescriptor, softPackage)
}

_dockerCallOptions := func(softwareName, dockerDescriptor) {
	ll.assert(
		len(dockerDescriptor.cmd) != 0,
		"cannot render final command for software: empty 'cmd' and 'command' in software descriptor")

	plan := runcmd.createRunCommandPlan()

	plan.cmdExpression(dockerDescriptor.cmd[0])

	// FIXME: expression ref???
	for arg in splice(dockerDescriptor.cmd, 1) {
		plan.argExpression(arg)
	}

	plan.
		dockerImageTag(dockerDescriptor.tag).
		dockerEntrypoint(dockerDescriptor.entrypoint)

	if !is_undefined(dockerDescriptor.pkg) {
		// Auto-generated docker images have 'pkg' field in descriptor that points to the software location
		// inside docker image. This helps to avoid unnecessary 'cmd' parameter hacking that was initially created by
		// block developer for binary packages.
		plan.refVar(_ARG_VAR_PKG, softwareName, text.trim_right(dockerDescriptor.pkg, "/"))
	}

	return ll.toStrict({
		runEnvType: "docker",
		plan:       plan
	})
}

/**
 * Turns a given software to a list of options that needs to be passed to run cmd builder.
 * Creates resources to install a software and runs R or Python env builder templates
 * if it's necessary.
 *
 * The function returns a plan state object that can be passed to runcmd functions.
 * The plan state is augmented with `runEnvType` in `options` property.
 *
 * @see exec.runcmd.createRunCommandPlan
 *
 * @param isDockerAvailable: boolean - whether docker is available in installation
 * @param softwareName: string - name of the software entrypoint (i.e. 'abc-package:main')
 * @param softwareVersion: string - version of the software package
 * @param softwareDescriptor: softwareDescriptor - software entrypoint descriptor
 *
 * @return result: runcmd.RUN_CMD_PLAN_STATE_SCHEMA - plan state object that can be passed to runcmd functions
 */
swToRuncmdPlan := func(isDockerAvailable, softwareName, softwareVersion, softwareDescriptor) {
	ll.assert(is_bool(isDockerAvailable),
		"exec.internal.swToRunCmdOptions: isDockerAvailable must be a boolean, got %v", isDockerAvailable)
	ll.assert(is_string(softwareName),
		"exec.internal.swToRunCmdOptions: software name must be a string, got %v", softwareName)
	ll.assert(is_string(softwareVersion),
		"exec.internal.swToRunCmdOptions: software version must be a string, got %v", softwareVersion)
	validation.assertType(softwareDescriptor, desc.scheme,
		"exec.internal.swToRunCmdOptions: descriptor does not fit schema")

	result := undefined

	if isDockerAvailable && maps.containsKey(softwareDescriptor, "docker") {
		result = _dockerCallOptions(softwareName, softwareDescriptor.docker)
	} else if maps.containsKey(softwareDescriptor, "local") {
		result = _devLocalPackageCallOptions(softwareName, softwareDescriptor.local)
	} else if maps.containsKey(softwareDescriptor, "binary") {
		result = _remotePackageCallOptions(softwareName, softwareDescriptor.binary)
	} else {
		ll.panic(
			"Unable to run software %s v%s: 'binary' execution mode is not enabled in software descriptor",
			softwareName, softwareVersion)
	}

	plan := result.plan.state()
	plan.options.runEnvType = result.runEnvType

	return plan
}

self.defineOutputs("plan")

self.validateInputs({
	environment: {
		isDockerAvailable: "bool"
	},
	software: pkg.softwareInfoScheme
})

self.body(func(inputs) {
	software := inputs.software

	return {
		plan: swToRuncmdPlan(
			inputs.environment.isDockerAvailable,
			software.name,
			software.version,
			software.descriptor
		)
	}
})
