// This code implements the `-sMODULARIZE` settings by taking the generated
// JS program code (INNER_JS_CODE) and wrapping it in a factory function.

// When targetting node and ES6 we use `await import ..` in the generated code
// so the outer function needs to be marked as async.
async function Module(moduleArg = {}) {
  var moduleRtn;

// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = moduleArg;

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).
// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == "object";

var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";

// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == "object" && process.versions?.node && process.type != "renderer";

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
var arguments_ = [];

var thisProgram = "./this.program";

var quit_ = (status, toThrow) => {
  throw toThrow;
};

var _scriptName = import.meta.url;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = "";

// Hooks that are implemented differently in different runtime environments.
var readAsync, readBinary;

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  try {
    scriptDirectory = new URL(".", _scriptName).href;
  } catch {}
  {
    // include: web_or_worker_shell_read.js
    if (ENVIRONMENT_IS_WORKER) {
      readBinary = url => {
        var xhr = new XMLHttpRequest;
        xhr.open("GET", url, false);
        xhr.responseType = "arraybuffer";
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));
      };
    }
    readAsync = async url => {
      var response = await fetch(url, {
        credentials: "same-origin"
      });
      if (response.ok) {
        return response.arrayBuffer();
      }
      throw new Error(response.status + " : " + response.url);
    };
  }
} else {}

var out = console.log.bind(console);

var err = console.error.bind(console);

// end include: shell.js
// include: preamble.js
// === Preamble library stuff ===
// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
var wasmBinary;

// Wasm globals
//========================================
// Runtime essentials
//========================================
// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// include: runtime_common.js
// include: runtime_stack_check.js
// end include: runtime_stack_check.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
// include: runtime_debug.js
// end include: runtime_debug.js
var readyPromiseResolve, readyPromiseReject;

// Memory management
var wasmMemory;

var /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;

// BigInt64Array type is not correctly defined in closure
var /** not-@type {!BigInt64Array} */ HEAP64, /* BigUint64Array type is not correctly defined in closure
/** not-@type {!BigUint64Array} */ HEAPU64;

var runtimeInitialized = false;

function updateMemoryViews() {
  var b = wasmMemory.buffer;
  HEAP8 = new Int8Array(b);
  HEAP16 = new Int16Array(b);
  HEAPU8 = new Uint8Array(b);
  HEAPU16 = new Uint16Array(b);
  HEAP32 = new Int32Array(b);
  HEAPU32 = new Uint32Array(b);
  HEAPF32 = new Float32Array(b);
  HEAPF64 = new Float64Array(b);
  HEAP64 = new BigInt64Array(b);
  HEAPU64 = new BigUint64Array(b);
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// end include: runtime_common.js
function preRun() {
  if (Module["preRun"]) {
    if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
    while (Module["preRun"].length) {
      addOnPreRun(Module["preRun"].shift());
    }
  }
  // Begin ATPRERUNS hooks
  callRuntimeCallbacks(onPreRuns);
}

function initRuntime() {
  runtimeInitialized = true;
  // Begin ATINITS hooks
  if (!Module["noFSInit"] && !FS.initialized) FS.init();
  TTY.init();
  // End ATINITS hooks
  wasmExports["u"]();
  // Begin ATPOSTCTORS hooks
  FS.ignorePermissions = false;
}

function preMain() {}

function postRun() {
  // PThreads reuse the runtime from the main thread.
  if (Module["postRun"]) {
    if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
    while (Module["postRun"].length) {
      addOnPostRun(Module["postRun"].shift());
    }
  }
  // Begin ATPOSTRUNS hooks
  callRuntimeCallbacks(onPostRuns);
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;

var dependenciesFulfilled = null;

// overridden to take different actions when all run dependencies are fulfilled
function addRunDependency(id) {
  runDependencies++;
  Module["monitorRunDependencies"]?.(runDependencies);
}

function removeRunDependency(id) {
  runDependencies--;
  Module["monitorRunDependencies"]?.(runDependencies);
  if (runDependencies == 0) {
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback();
    }
  }
}

/** @param {string|number=} what */ function abort(what) {
  Module["onAbort"]?.(what);
  what = "Aborted(" + what + ")";
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);
  ABORT = true;
  what += ". Build with -sASSERTIONS for more info.";
  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.
  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);
  readyPromiseReject?.(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

var wasmBinaryFile;

function findWasmBinary() {
  return base64Decode("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BEAgBUGkxgFqIAA2AgAgAA0BQfjDASALQX4gAXdxNgIADAILAkAgAiAJKAIQRgRAIAkgADYCEAwBCyAJIAA2AhQLIABFDQELIAAgCTYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACKAIUIgFFDQAgACABNgIUIAEgADYCGAsCQCADQQ9NBEAgAiADIAZqIgBBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMAQsgAiAGQQNyNgIEIAIgBmoiBSADQQFyNgIEIAMgBWogAzYCACAIBEAgCEF4cUGcxAFqIQBBiMQBKAIAIQECf0EBIAhBA3Z0IgcgBHFFBEBB9MMBIAQgB3I2AgAgAAwBCyAAKAIICyEEIAAgATYCCCAEIAE2AgwgASAANgIMIAEgBDYCCAtBiMQBIAU2AgBB/MMBIAM2AgALIAJBCGohAAsgCkEQaiQAIAALxgEBAX8jAEGwAmsiAyQAIAMgAjYCLCADECc3A6gCIANBMGpByAFBsYABIANBqAJqIANB/AFqEEkQPUUEQEGxxABBjQ9BABATQagOQQZBAUGwwAEQGBoLIANBFjYCICADIANBMGo2AiRB2MIBQd+BASADQSBqEBogA0HMgAE2AhQgA0EINgIQQdjCAUHfgQEgA0EQahAaQdjCASABIAJBBkEHEDwaIAMgADYCAEHYwgFBpo4BIAMQGkHYwgEQMRogA0GwAmokAAvNCgIFfwl+IwBB4ABrIgUkACAEQv///////z+DIQogAiAEhUKAgICAgICAgIB/gyELIAJC////////P4MiDEIgiCEPIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDUKAgICAgIDA//8AVCANQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQsMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCyADIQEMAgsgASANQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhC0IAIQEMAwsgC0KAgICAgIDA//8AhCELQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgDYRCACEB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IApCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIFGyEEQgAgASAFGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQEgASAKhFAEQCADIAmEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAmEQgBSDQAgASEDIAIhBAwBCyADIAEgASADVCAJIApWIAkgClEbIggbIQogBCACIAgbIgxC////////P4MhCSACIAQgCBsiC0IwiKdB//8BcSEHIAxCMIinQf//AXEiBUUEQCAGQeAAaiAKIAkgCiAJIAlQIgUbeULAAEIAIAUbfKciBUEPaxAgIAYpA2ghCSAGKQNgIQpBECAFayEFCyABIAMgCBshAyALQv///////z+DIQEgBwR+IAEFIAZB0ABqIAMgASADIAEgAVAiBxt5QsAAQgAgBxt8pyIHQQ9rECBBECAHayEHIAYpA1AhAyAGKQNYC0IDhiADQj2IhEKAgICAgICABIQhASAJQgOGIApCPYiEIAIgBIUhBAJ+IANCA4YiAiAFIAdGDQAaIAUgB2siB0H/AEsEQEIAIQFCAQwBCyAGQUBrIAIgAUGAASAHaxAgIAZBMGogAiABIAcQOSAGKQM4IQEgBikDMCAGKQNAIAYpA0iEQgBSrYQLIQlCgICAgICAgASEIQsgCkIDhiEKAkAgBEIAUwRAQgAhA0IAIQQgCSAKhSABIAuFhFANAiAKIAl9IQIgCyABfSAJIApWrX0iBEL/////////A1YNASAGQSBqIAIgBCACIAQgBFAiBxt5QsAAQgAgBxt8p0EMayIHECAgBSAHayEFIAYpAyghBCAGKQMgIQIMAQsgCSAKfCICIAlUrSABIAt8fCIEQoCAgICAgIAIg1ANACAJQgGDIARCP4YgAkIBiISEIQIgBUEBaiEFIARCAYghBAsgDEKAgICAgICAgIB/gyEDIAVB//8BTgRAIANCgICAgICAwP//AIQhBEIAIQMMAQtBACEHAkAgBUEASgRAIAUhBwwBCyAGQRBqIAIgBCAFQf8AahAgIAYgAiAEQQEgBWsQOSAGKQMAIAYpAxAgBikDGIRCAFKthCECIAYpAwghBAsgBEI9hiACQgOIhCEBIARCA4hC////////P4MgB61CMIaEIAOEIQQCQAJAIAKn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DAAaC0EAIQEgAEEANgIcIABCADcDECAAQgA3AgQgAg0BCwsgAQvcAgEGfwJ/IABBoH9PBEBB8MMBQTA2AgBBAAwBC0EAQRAgAEELakF4cSAAQQtJGyIEQSxqEBUiAEUNABogAEEIayEBAkAgAEEfcUUEQCABIQAMAQsgAEEEayIFKAIAIgZBeHEgAEEfakFgcUEIayIAQSBBACAAIAFrQQ9NG2oiACABayICayEDIAZBA3FFBEAgASgCACEBIAAgAzYCBCAAIAEgAmo2AgAMAQsgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgMgAygCBEEBcjYCBCABIAIQRwsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIARBEGpNDQAgACAEIAFBAXFyQQJyNgIEIAAgBGoiASACIARrIgRBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASAEEEcLIABBCGoLC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQCAAIAJUIAEgA1MgASADURsEQEF/DwsgACAChSABIAOFhEIAUg8LIAAgAlYgASADVSABIANRGwRAQX8PCyAAIAKFIAEgA4WEQgBSIQQLIAQLFgEBfyAAQQAgARBQIgIgAGsgASACGwtSAQJ/QajAASgCACIBIABBB2pBeHEiAmohAAJAIAJBACAAIAFNG0UEQCAAPwBBEHRNDQEgABADDQELQfDDAUEwNgIAQX8PC0GowAEgADYCACABC9oDAQd/IwBB4ABrIgIkACAAIAAoAhgiA0GABGoiATYCGAJAIAFFBEAgAkEANgIAQbjCAEG1DyACEBMMAQsCfyAAKAIEIgRFBEAgARAVDAELIAQgARAhCyIBRQRAIAIgACgCGDYCEEG4wgBBmg8gAkEQahATDAELIAAgATYCBCAAKAIYIgFFBEAgAkEANgIgQaA4QbUPIAJBIGoQEwwBCwJ/IAAoAggiBEUEQCABEBUMAQsgBCABECEL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BSABCzYCpAFBwAAhBgNAIAIgBmoiASwAACIEQX9HBEAgASADQSBqIARqLQAAIgQ6AAAgASAEOgAgCyABLAABIgRBf0cEQCABIANBIGogBGotAAAiBDoAASABIAQ6ACELIAZBAmoiBkHgAEcNAAsgAkGAAWohASACLABAIgRBf0cEQCABIARqQcAAOgAACyAgLAAAIgRBf0cEQCABIARqQcEAOgAACyAfLAAAIgRBf0cEQCABIARqQcIAOgAACyAeLAAAIgRBf0cEQCABIARqQcMAOgAACyAdLAAAIgRBf0cEQCABIARqQcQAOgAACyAcLAAAIgRBf0cEQCABIARqQcUAOgAACyACLABGIgRBf0cEQCABIARqQcYAOgAACyACLABHIgRBf0cEQCABIARqQccAOgAACyACLABIIgRBf0cEQCABIARqQcgAOgAACyACLABJIgRBf0cEQCABIARqQckAOgAACyACLABKIgRBf0cEQCABIARqQcoAOgAACyACLABLIgRBf0cEQCABIARqQcsAOgAACyACLABMIgRBf0cEQCABIARqQcwAOgAACyACLABNIgRBf0cEQCABIARqQc0AOgAACyACLABOIgRBf0cEQCABIARqQc4AOgAACyACLABPIgRBf0cEQCABIARqQc8AOgAACyACLABQIgRBf0cEQCABIARqQdAAOgAACyACLABRIgRBf0cEQCABIARqQdEAOgAACyACLABSIgRBf0cEQCABIARqQdIAOgAACyACLABTIgRBf0cEQCABIARqQdMAOgAACyACLABUIgRBf0cEQCABIARqQdQAOgAACyACLABVIgRBf0cEQCABIARqQdUAOgAACyACLABWIgRBf0cEQCABIARqQdYAOgAACyACLABXIgRBf0cEQCABIARqQdcAOgAACyACLABYIgRBf0cEQCABIARqQdgAOgAACyACLABZIgRBf0cEQCABIARqQdkAOgAACyACLABaIgRBf0cEQCABIARqQdoAOgAACyACLABbIgRBf0cEQCABIARqQdsAOgAACyACLABcIgRBf0cEQCABIARqQdwAOgAACyACLABdIgRBf0cEQCABIARqQd0AOgAACyACLABeIgRBf0cEQCABIARqQd4AOgAACyACLABfIgRBf0cEQCABIARqQd8AOgAACyAAIAIoAqQBOgCoBCAA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AgAgA2ooAgAiAkUNAQsgAhAUIAAoAgAgA2pBADYCAAwBC0GwKEH5DEEAEBYLIAFBAWoiASAAKAIISA0ACwsgACgCACIBBEAgARAUIAAQFA8LQewbQfkMQQAQFiAAEBQLwAYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABAzRQ0AAn8gBEL///////8/gyEKAn8gBEIwiKdB//8BcSIHQf//AUcEQEEEIAcNARpBAkEDIAMgCoRQGwwCCyADIAqEUAsLRQ0AIAJCMIinIghB//8BcSIGQf//AUcNAQsgBUEQaiABIAIgAyAEEBcgBSAFKQMQIgIgBSkDGCIBIAIgARCNASAFKQMIIQIgBSkDACEEDAELIAEgAkL///////////8AgyIKIAMgBEL///////////8AgyIJEDNBAEwEQCABIAogAyAJEDMEQCABIQQMAgsgBUHwAGogASACQgBCABAXIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEHIAYEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAEBcgBSkDaCIKQjCIp0H4AGshBiAFKQNgCyEEIAdFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAXIAUpA1giCUIwiKdB+ABrIQcgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSgRAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAXIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAGQQFrIgYgB0oNAAsgByEGCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEBcgBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIAZBAWshBiAEQgGGIQQgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAhBgIACcSEHIAZBAEwEQCAFQUBrIAQgCUL///////8/gyAGQfgAaiAHcq1CMIaEQgBCgICAgICAwMM/EBcgBSkDSCECIAUpA0AhBAwBCyAJQv///////z+DIAYgB3Kt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AUP//3//IAFD//9//14bIAiTOAIQIAxBAmohDCALQQJqIgsgFEcNAAtFDQELIA8gDEEMbGoiC0H///97NgIAIAtB////ezYCCCALIAtBCGsqAgAiASALQQxrKgIAIgIgASACXhsgCJM4AgQLIA8gDkEMbGoiC0H///97NgIIIAtC////+////79/NwIAIBIgFUgEQCAQQQFqIQ0gDiAAKAJQRiEUA0AgGCASIBdqLQAAQQJ0aigCACETIBEqAgQhASARQf///3s2AgQgESoCACEDIBFB////ezYCACARKgIIIQUgEQJ9IBAEQCAFIAeTIgIgAyAEkyIGIAIgBl4bDAELIAUgAyADIAVdGyAIkws4AghD//9//yEGQ///f/8hCSAQIgshDCANIgAgDkgEQANAIA8gACIMQQxsaiIAKgIEIBMgCyAWai0AAEECdGoqAgAhCiAAIAYgB5MiBiAJIASTIgkgBiAJXhsiBjgCBCADIAEgBJMiASABIANdGyEBIAAqAgAhAyAAIAogASAFIASTIgUgASAFXhuSIgk4AgAgACAAKgIIIgUgB5MiASADIASTIgogASAKXhs4AgghASAMIgtBAWoiACAORw0ACyAOIQALIBMgDCAWai0AAEECdGoqAgAhBiAPIABBDGxqIgBB////ezYCBCAAKgIAIQIgACAGIAMgASAEkyIBIAEgA10bIgEgBSAEkyIDIAEgA14bkjgCACAAKgIIIQEgAAJ9IBRFBEAgASAHkyIBIAIgBJMiAiABIAJeGwwBCyABIAIgASACXhsgCJMLOAIIIBJBAWoiEiAVRw0ACwsL6QgCCn0MfyAAKAI4IQ0gACgCQCETIAAoAjQhESAAKAIMIRQgACgCCCESIAAoAhAiDigCBCEVIA4qAhAhCCAOKgIMIQcgDioCCCEEIAAoAhgiDyAAKAJEIgtBDGxqIhAgDyoCACIBOAIAIBAgDyoCBCICOAIEIBAgDyoCCDgCCCALQQFrIQ4CQCALIAAoAlBGIhZFBEAgDSAOTg0BIAtBAmshDCANIAtrQQFxBH8gDgUgDyAOQQxsaiIAQf///3s2AgggAEH///97NgIAIAAgAiAHkyIDIAEgBJMiASABIANdGyICOAIEIA4hCyAMCyEAIAwgDUYNAUP//3//IASTIQEDQCAPIABBDGxqIgxB////ezYCACAPIAtBDGxqKgIAIQMgDEH///97NgIIIAxBDGsiC0H///97NgIIIAtB////ezYCACAMIAIgB5MiAiADIASTIgMgAiADXhsiAzgCBCALIAMgB5MiAyABIAEgA10bIgI4AgQgAEEBayELIABBAmsiACANSg0ACwwBCyANIA5ODQAgC0ECayEMIA0gC2tBAXEEfyAOBSAPIA5BDGxqIgBB////ezYCCCAAQf///3s2AgAgACACIAEgASACXRsgCJMiAjgCBCAOIQsgDAshACAMIA1GDQADQCAPIABBDGxqIgxB////ezYCACAPIAtBDGxqKgIAIQEgDEH///97NgIIIAxBDGsiC0H///97NgIIIAtB////ezYCACAMIAIgASABIAJdGyAIkyIBOAIEIAsgAUP//3//IAFD//9//14bIAiTIgI4AgQgAEEBayELIABBAmsiACANSg0ACwsgDyANQQxsaiIAQf///3s2AgggAEL////7////v383AgAgESATRwRAIBEgEmohEiATIBFBf3NqIQsDQCAVIBIgCyIMai0AAEECdGooAgAhESAQKgIEIQEgEEH///97NgIEIBAqAgAhAiAQQf///3s2AgAgECoCCCEFIBACfSAWRQRAIAUgB5MiAyACIASTIgYgAyAGXhsMAQsgBSACIAIgBV0bIAiTCzgCCEP//3//IQZD//9//yEJIA4iACELIAAgDUoEQANAIA8gAEEMbGoiCyoCBCARIAAgFGotAABBAnRqKgIAIQogCyAGIAeTIgYgCSAEkyIJIAYgCV4bIgY4AgQgAiABIASTIgEgASACXRshASALKgIAIQIgCyAKIAEgBSAEkyIFIAEgBV4bkiIJOAIAIAsgCyoCCCIFIAeTIgEgAiAEkyIKIAEgCl4bOAIIIQEgAEEBayIAIA1KDQALIA0hCwsgESALIBRqLQAAQQJ0aioCACEGIA8gC0EMbGoiAEH///97NgIEIAAqAgAhAyAAIAYgAiABIASTIgEgASACXRsiASAFIASTIgIgASACXhuSOAIAIAAqAgghASAAAn0gDQRAIAEgB5MiASADIASTIgMgASADXhsMAQsgASADIAEgA14bIAiTCzgCCCAMQQFrIQsgDA0ACwsLmgUCDH0MfyABKAIMIhMgASgCCCIRa7JDAAAAP5QgEbKSIQggACgCACABKAIQQQh0aiIVKgLsAiEKIAAoAhghGCAAKAIUIRYCQCARIBNOBEBD//9//yEFQX8hFEF/IRIMAQsgACgCECoCCCAAKAJUspQhCyAVKgJsIQ0gACgCOCEcQX8hEkP//3//IQVBfyEUA0AgGCARQQxsIhdqIgEqAgAiDCAWIBdqIhcqAgSSIAuTIAggEbKTi0MAAHpElSIHkyIJIBcqAgAiBiABKgIIIg6SIAqSIAeTIg8gBiABKgIEkiALkyAHkyIQIAYgDJIgB5MiBiAFIAUgBl0iARsiBSAFIBBdIhkbIgUgBSAPXSIaGyIFIAUgCV0iGxshBUEFQQNBAkEBIBIgARsgGRsgGhsgGxshEiARIBEgESAUIAEgGXIbIBsbIBobIQEgDiAXKgIIIgmSIQYCQCAcRQRAIAYgFSoC9AKSIAeTIgYgBV5FDQFBBiESIBEhASAGIQUMAQsgBiAVKgLwApIgB5MiBiAFXkUNAEEGIRIgESEBIAYhBQsgDCAJkiANkiAHkyIGIAUgBSAGXSIUGyEFQQcgEiAUGyESIBEgASAUGyEUIBFBAWoiESATRw0ACwsgFiATQQxsIgFqIhYqAgAgASAYaioCCCIHkiAKkiAIIBOyk4tDAAB6RJUiBpMiCCAFIAUgCF0iERshBUEDIBIgERshASATIBQgERshESAHIBYqAgiSIQcCQCAAKAJEIAAoAlBGBEAgByAVKgL0ApIgBpMiBiAFXkUNAUEGIQEgEyERIAYhBQwBCyAHIBUqAvACkiAGkyIGIAVeRQ0AQQYhASATIREgBiEFCyACIBE2AgAgAyABNgIAIAQgBTgCAAu0CQIKfQ1/IAAoAgwhFiAAKAIQIgsqAgggCyoCDCALKgIQIQQgACgCVCAAKAIAIRMgACgCMCEUIAAoAhQiDyAAKAI4IhBBDGxqIhEgDyoCACIFOAIAIBEgDyoCBCIDOAIEIBEgDyoCCDgCCLIiAZQhCCABlCEGIAAoAkQhDgJAIBAEQCAQQQFqIgsgDk4NASAOQQJrIRICQCAQIA5rQQFxBEAgCyENIBAhCwwBCyAPIAtBDGxqIgxB////ezYCCCAMQf///3s2AgAgDCADIAiTIgEgBSAGkyICIAEgAl4bIgM4AgQgEEECaiENCyAQIBJGDQFD//9//yAGkyEBA0AgDyANQQxsaiIMQf///3s2AgAgDyALQQxsaioCACECIAxB////ezYCFCAMQv////v///+/fzcCCCAMIAMgCJMiAyACIAaTIgIgAiADXRsiAjgCBCAMIAIgCJMiAiABIAEgAl0bIgM4AhAgDUEBaiELIA1BAmoiDSAORw0ACwwBCyAOQQJIDQAgBCABlCEBQQEhDSAOQQJHBEAgDkEBayILQQFxIAtBfnEhFUEAIQsDQCAPIA1BDGxqIgxB////ezYCACAMQf///3s2AhQgDEL////7////v383AgggDCAMQQhrKgIAIgIgDEEMayoCACIDIAIgA14bIAGTIgI4AgQgDCACQ///f/8gAkP//3//XhsgAZM4AhAgDUECaiENIAtBAmoiCyAVRw0AC0UNAQsgDyANQQxsaiILQf///3s2AgAgC0H///97NgIIIAsgC0EIayoCACICIAtBDGsqAgAiAyACIANeGyABkzgCBAsgDyAOQQxsaiILQf///3s2AgggC0L////7////v383AgAgACgCPCIVIBRKBEAgEyAUQQh0aiENIBBBAWohEyAOIAAoAlBGIRcDQCARKgIAIQMgEUH///97NgIAIBEqAgghBCARKgIEIQEgEUH///97NgIEAkAgEARAIBEgBCANKgLwApIiAiADIA0qAuwCkiIFIAIgBV4bOAIIDAELIBEgBCADIAMgBF0bIA0qAvQCkjgCCAsgDUGAAmohEgJ/IA4gE0wEQCAQIQsgEwwBC0P//3//IQUgEyEMIBAhAEP//3//IQcDQCAPIAwiC0EMbGoiDCoCBCASIAAgFmotAABBAnRqKgKAASEJIA0qAmwhCiAMIAUgCJMiBSAHIAaTIgcgBSAHXhsiBTgCBCADIAEgBpMiASABIANdGyEBIAwqAgAhAyAMIAkgASAEIAqSIgQgASAEXhuSIgc4AgAgDCAMKgIIIgQgDSoC8AKSIgEgAyANKgLsApIiCSABIAleGzgCCCEBIAsiAEEBaiIMIA5HDQALIA4LIQwgEiALIBZqLQAAQQJ0aioCgAEhBSANKgJsIQcgDyAMQQxsaiIAQf///3s2AgQgACoCACECIAAgBSADIAEgBpMiASABIANdGyIBIAQgB5IiAyABIANeG5I4AgAgACoCCCEBIAACfSAXRQRAIAEgDSoC8AKSIgEgAiANKgLsApIiAiABIAJeGwwBCyANKgL0AiABIAIgASACXhuSCzgCCCASIQ0gFEEBaiIUIBVHDQALCwvJCQIMfwp9IAAoAgwhCiAAKAIAIQkgACgCQCEIIAAoAhAiBCoCCCAEKgIMIAQqAhAhECAAKAJUIAAoAhgiBiAAKAJEIgFBDGxqIgcgBioCACINOAIAIAcgBioCBCIPOAIEIAcgBioCCDgCCCABQQFrIQSyIg6UIRQgDpQhESAAKAI4IQUCQCABIAAoAlBGIgtFBEAgBCAFTA0BIAFBAmshAiAFIAFrQQFxBH8gBAUgBiAEQQxsaiIBQf///3s2AgggAUH///97NgIAIAEgDyAUkyIOIA0gEZMiDSANIA5dGyIPOAIEIAQhASACCyEDIAIgBUYNAUP//3//IBGTIQ0DQCAGIANBDGxqIgJB////ezYCACAGIAFBDGxqKgIAIQ4gAkH///97NgIIIAJBDGsiAUH///97NgIIIAFB////ezYCACACIA8gFJMiDyAOIBGTIg4gDiAPXRsiDjgCBCABIA4gFJMiDiANIA0gDl0bIg84AgQgA0EBayEBIANBAmsiAyAFSg0ACwwBCyAEIAVMDQAgECAOlCEOIAFBAmshAiAFIAFrQQFxBH8gBAUgBiAEQQxsaiIBQf///3s2AgggAUH///97NgIAIAEgDyANIA0gD10bIA6TIg84AgQgBCEBIAILIQMgAiAFRg0AA0AgBiADQQxsaiICQf///3s2AgAgBiABQQxsaioCACENIAJB////ezYCCCACQQxrIgFB////ezYCCCABQf///3s2AgAgAiAPIA0gDSAPXRsgDpMiDTgCBCABIA1D//9//yANQ///f/9eGyAOkyIPOAIEIANBAWshASADQQJrIgMgBUoNAAsLIAYgBUEMbGoiAUH///97NgIIIAFC////+////79/NwIAIAAoAjQiASAIRwRAIAkgCEEIdGpBgAJqIQAgCCABQX9zaiEBA0AgASEIIAcqAgAhDyAHQf///3s2AgAgByoCCCEQIAcqAgQhDSAHQf///3s2AgQCQCALRQRAIAcgECAAQZABayoCAJIiDiAPIABBlAFrKgIAkiISIA4gEl4bOAIIDAELIAcgECAPIA8gEF0bIABBjAFrKgIAkjgCCAsgAEGAAmshAiACIAQgBUwEfyAEBSAAQZQBayEJIABBkAFrIQxD//9//yESIAQhA0P//3//IRMDQCAGIANBDGxqIgEqAgQgAiADIApqLQAAQQJ0aioCgAEhFSAAKgJsIRYgASASIBSTIhIgEyARkyITIBIgE14bIhI4AgQgDyANIBGTIg0gDSAPXRshDSABKgIAIQ8gASAVIA0gECAWkiIQIA0gEF4bkiITOAIAIAEgASoCCCIQIAwqAgCSIg0gDyAJKgIAkiIVIA0gFV4bOAIIIQ0gA0EBayIDIAVKDQALIAULIgEgCmotAABBAnRqKgKAASESIAAqAmwhEyAGIAFBDGxqIgFB////ezYCBCABKgIAIQ4gASASIA8gDSARkyINIA0gD10bIg0gECATkiIPIA0gD14bkjgCACABKgIIIQ0gAQJ9IAUEQCANIABBkAFrKgIAkiINIA4gAEGUAWsqAgCSIg4gDSAOXhsMAQsgAEGMAWsqAgAgDSAOIA0gDl4bkgs4AgggCEEBayEBIAIhACAIDQALCwuvBQILfQ1/IAAoAgAgASgCEEEIdGohFCABKAIMIhUgASgCCCIBa7JDAAAAP5QgAbKSIQogACgCGCEYIAAoAhQhFgJAIAEgFU4EQCAUKgLsAiEIQ///f/8hBUF/IRBBfyERDAELIAAoAgQgAUEIdGohEiAUKgJsIQwgFCoC7AIhCCAAKAI4IRxBfyERQ///f/8hBUF/IRADQCAYIAFBDGwiF2oiEyoCACILIBYgF2oiFyoCBJIgEioCbJIgCiABspOLQwAAekSVIgeTIgkgFyoCACIGIBMqAggiDZIgCJIgB5MiDiAGIBMqAgSSIBIqAuwCkiAHkyIPIAYgC5IgB5MiBiAFIAUgBl0iExsiBSAFIA9dIhkbIgUgBSAOXSIaGyIFIAUgCV0iGxshBUEFQQNBAkEBIBEgExsgGRsgGhsgGxshESABIAEgASAQIBMgGXIbIBsbIBobIRAgDSAXKgIIIgmSIQYCQCAcRQRAIAYgFCoC9AKSIAeTIgYgBV5FDQFBBiERIAEhECAGIQUMAQsgBiAUKgLwApIgB5MiBiAFXkUNAEEGIREgASEQIAYhBQsgEkGAAmohEiALIAmSIAySIAeTIgYgBSAFIAZdIhMbIQVBByARIBMbIREgASAQIBMbIRAgAUEBaiIBIBVHDQALCyAWIBVBDGwiAWoiFioCACABIBhqKgIIIgeSIAiSIAogFbKTi0MAAHpElSIGkyIIIAUgBSAIXSIBGyEFQQMgESABGyESIBUgECABGyEBIAcgFioCCJIhBwJAIAAoAkQgACgCUEYEQCAHIBQqAvQCkiAGkyIGIAVeRQ0BQQYhEiAVIQEgBiEFDAELIAcgFCoC8AKSIAaTIgYgBV5FDQBBBiESIBUhASAGIQULIAIgATYCACADIBI2AgAgBCAFOAIAC+8SAhl/B30gACgCACEMIAAoAjAhECAAKAIEIAAoAhQiCiAAKAI4IgtBDGxqIg0gCioCACIeOAIAIA0gCioCBCIaOAIEIA0gCioCCDgCCCALQQh0aiEGIAAoAkQhCAJAIAsEQCALQQFqIgUgCE4NASAIQQJrAkAgCyAIa0EBcQRAIAUhBCALIQUMAQsgCiAFQQxsaiIEQf///3s2AgAgBioC8AIhHCAGKgLsAiEbIARB////ezYCCCAEIBogHJIiGiAeIBuSIhsgGiAbXhsiGjgCBCALQQJqIQQgBkGAAmohBgsgC0YNAQNAIAogBEEMbGoiCUH///97NgIAIAogBUEMbGoqAgAhHiAGKgLwAiEcIAYqAuwCIRsgCUL////7////v383AgggCSAaIBySIhogHiAbkiIbIBogG14bIho4AgQgBioC7AQhHCAGKgLwBCEbIAlB////ezYCFCAJIBogG5IiGiAcQ///f/+SIhsgGiAbXhsiGjgCECAGQYAEaiEGIARBAWohBSAEQQJqIgQgCEcNAAsMAQsgCEECSA0AQQEhBCAIQQJHBEAgCEEBayIFQQFxIAVBfnEhCUEAIQUDQCAKIARBDGxqIgdB////ezYCACAGKgL0AiEbIAdC////+////79/NwIIIAcgGyAHQQhrKgIAIhogB0EMayoCACIbIBogG14bkiIaOAIEIAYqAvQEIRsgB0H///97NgIUIAcgGyAaQ///f/8gGkP//3//XhuSOAIQIARBAmohBCAGQYAEaiEGIAVBAmoiBSAJRw0AC0UNAQsgCiAEQQxsaiIFQf///3s2AgAgBioC9AIhGyAFQf///3s2AgggBSAbIAVBCGsqAgAiGiAFQQxrKgIAIhsgGiAbXhuSOAIEIAZBgAJqIQYLIAogCEEMbGoiBUH///97NgIIIAVC////+////79/NwIAIAAoAjwiFCAQSgRAIAwgEEEIdGohAiMAQeAAayIDQQRyIREgCyAIa0EIdCEV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RCAAIAQ2AjgCQCAFBEAgABAtDAELIAAQKAsgACACKAIQNgIwIAIoAgQhBCAAIANBAWo2AjggACAENgI8IAAgAigCDDYCRCAAKAIUIgJB////ezYCCCACQv////sPNwIAIAAoAhgiAiABKgIMOAIAIAIgASoCEDgCBCACIAEqAhQ4AgggBUUNBAwGCyAGIAIoAhBBAnRqIAM2AgAgACgCFCIEIAEqAgA4AgAgBCABKgIEOAIEIAQgASoCCDgCCCAAKAIYIgRB////ezYCCCAEQoCAgIDw//+/fzcCACAAIAIoAgA2AjAgACACKAIQQQFrNgI8IAIoAgghBCAAIANBAWs2AkQgACAENgI4AkAgBQRAIAAQLQwBCyAAECgLIAAgAigCEEEBajYCMCACKAIEIQQgACADNgI4IAAgBDYCPCAAIAIoAgw2AkQgACgCFCICQQA2AgggAkL////7////v383AgAgACgCGCICIAEqAgw4AgAgAiABKgIQOAIEIAIgASoCFDgCCCAFRQ0DDAULIAYgAigCEEECdGogA0EBaiIGNgIEIAAoAhQiBCABKgIAOAIAIAQgASoCBDgCBCAEIAEqAgg4AgggACgCGCIEQf///3s2AgggBEL////7DzcCACAAIAIoAgA2AjAgACACKAIQNgI8IAIoAgghBCAAIANBAWs2AkQgACAENgI4AkAgBQRAIAAQLQwBCyAAECgLIAAgAigCEEEBajYCMCACKAIEIQMgACAGNgI4IAAgAzYCPCAAIAIoAgw2AkQgACgCFCICQf///3s2AgggAkKAgICA8P//v383AgAgACgCGCICIAEqAgw4AgAgAiABKgIQOAIEIAIgASoCFDgCCCAFRQ0CDAQLIAAoAhQiBCABKgIAOAIAIAQgASoCBDgCBCAEIAEqAgg4AgggACgCGCIEQQA2AgggBEL////7////v383AgAgACACKAIANgIwIAAgAigCEEEBazYCPCACKAIIIQQgACADNgJEIAAgBDYCOAJAIAUEQCAAEC0MAQsgABAoCyAAIAIoAhBBAWo2AjAgAigCBCEEIAAgAzYCOCAAIAQ2AjwgACACKAIMNgJEIAAoAhQiAkEANgIIIAJC////+////79/NwIAIAAoAhgiAiABKgIMOAIAIAIgASoCEDgCBCACIAEqAhQ4AgggBUUNAQwDCyAGIAIoAhBBAnRqIANBAWoiBjYCBCAAKAIUIgQgASoCADgCACAEIAEqAgQ4AgQgBCABKgIIOAIIIAAoAhgiBEEANgIIIARC////+////79/NwIAIAAgAigCADYCMCAAIAIoAhBBAWs2AjwgAigCCCEEIAAgAzYCRCAAIAQ2AjgCQCAFBEAgABAtDAELIAAQKAsgACACKAIQQQFqNgIwIAIoAgQhAyAAIAY2AjggACADNgI8IAAgAigCDDYCRCAAKAIUIgJB////ezYCCCACQoCAgIDw//+/fzcCACAAKAIYIgIgASoCDDgCACACIAEqAhA4AgQgAiABKgIUOAIIIAVFDQAMAgsgABAoCw8LIAAQLQvCAgEFfyMAQdAAayIDJAACfwJAQRAQFSIERQRAIANBEDYCAEHcFUG1DyADEBMMAQsgBCABNgIMIARBADYCCCAEQQA2AgAgBCABQQN0QQRrIgIQFSIFNgIEIAUEQAJAIAFBAXRBAkgNACACRQ0AIAVBACAC/AsACyABQQJ0IgJFBEAgA0EANgIgQdTFAEG1DyADQSBqEBMMAgsgBCACEBUiBTYCAAJAAkAgBQRAQQAhAiABQQBMDQIMAQsgAyACNgIwQdTFAEG1DyADQTBqEBMMAwsDQAJAIAUgAkECdGpBGBAVIgY2AgAgBkUNACABIAJBAWoiAkcNAQwCCwsgA0EYNgJAQZssQbUPIANBQGsQEwwCCyAAIAQ2AgBBAAwCCyADIAI2AhBBuR5BtQ8gA0EQahATCyAEEFRBAQsgA0HQAGokAAuVAgEDfyMAQdAAayIBJAACfwJAAkBBHBAVIgJFBEAgAUEcNgIAQdzVAEG1DyABEBMMAQsgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAkKAgICAgMAANwIUIAJBgAIQFSIDNgIAIANFBEAgAUGAAjYCEEHg0wBBtQ8gAUEQahATDAELIAJBgAQQFSIDNgIEIANFBEAgAUGABDYCIEHcwwBBtQ8gAUEgahATDAELIAJBgAQQFSIDNgIIIANFBEAgAUGABDYCMEH5OkG1DyABQTBqEBMMAQsgAkGEEBAZIgM2AgwgAw0BIAFBhBA2AkBB0zNBtQ8gAUFAaxATCyACEFVBAQwBCyAAIAI2AgBBAAsgAUHQAGokAAvkAQEFfyMAQUBqIgEkAAJAAkBBEBAVIgJFBEAgAUEQNgIAQf81QbUPIAEQEwwBCyACIAA2AgQgAkKACDcCCCACQYAgEBUiBTYCAAJAIAUEQAwBCyABQYAgNgIQQZjXAEG1DyABQRBqEBMMAQsDQCAFIARBAnRqQQwQFSIDNgIAIANFBEAgAUEMNgIgQa41QbUPIAFBIGoQEwwCCyADQgA3AgQgAyAAEBUiAzYCACADBEAgBEEBaiIEQYAIRg0DDAELCyABIAA2AjBB9xhBtQ8gAUEwahATC0EAIQILIAFBQGskACACCwUAEAkAC7gBAQR/IwBBEGsiAiQAQX8hAwJAAn8gACAAKAJIIgFBAWsgAXI2AkggACgCFCAAKAIcRwRAIABBAEEAIAAoAiQRAwAaCyAAQQA2AhwgAEIANwMQIAAoAgAiAUEEcQRAIAAgAUEgcjYCAEF/DAELIAAgACgCLCAAKAIwaiIENgIIIAAgBDYCBCABQRt0QR91Cw0AIAAgAkEPakEBIAAoAiARAwBBAUcNACACLQAPIQMLIAJBEGokACADC/8DAgJ+BX8jAEEgayIFJAAgAUL///////8/gyECAn4gAUIwiEL//wGDIgOnIgRBgfgAa0H9D00EQCACQgSGIABCPIiEIQIgBEGA+ABrrSEDAkAgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILQgAgAiACQv////////8HViIEGyEAIAStIAN8DAELAkAgACAChFANACADQv//AVINACACQgSGIABCPIiEQoCAgICAgIAEhCEAQv8PDAELIARB/ocBSwRAQgAhAEL/DwwBC0GA+ABBgfgAIANQIgYbIgggBGsiB0HwAEoEQEIAIQBCAAwBCyACIAJCgICAgICAwACEIAYbIQJBACEGIAQgCEcEQCAFQRBqIAAgAkGAASAHaxAgIAUpAxAgBSkDGIRCAFIhBgsgBSAAIAIgBxA5IAUpAwhCBIYgBSkDACICQjyIhCEAAkAgBq0gAkL//////////w+DhCICQoGAgICAgICACFoEQCAAQgF8IQAMAQsgAkKAgICAgICAgAhSDQAgAEIBgyAAfCEACyAAQoCAgICAgIAIhSAAIABC/////////wdWIgQbIQAgBK0LIQIgBUEgaiQAIAFCgICAgICAgICAf4MgAkI0hoQgAIS/C4ABAQJ/IwBBEGsiAiQAIAIgAToADwJAAkAgACgCECIDBH8gAwUgABBdDQIgACgCEAsgACgCFCIDRg0AIAAoAlAgAUH/AXFGDQAgACADQQFqNgIUIAMgAToAAAwBCyAAIAJBD2pBASAAKAIkEQMAQQFHDQAgAi0ADxoLIAJBEGokAAtGAQN/QduQASEBIABBP3EiAkExTQRAQfC0ASEAIAJFBEBB8LQBDwsDQCAALQAAIABBAWoiASEADQAgAkEBayICDQALCyABC8ABAgF/An5BfyEDAkAgAEIAUiABQv///////////wCDIgRCgICAgICAwP//AFYgBEKAgICAgIDA//8AURsNACACQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AUnENACAAIAQgBYSEUARAQQAPCyABIAKDQgBZBEAgASACUiABIAJTcQ0BIAAgASAChYRCAFIPCyAAQgBSIAEgAlUgASACURsNACAAIAEgAoWEQgBSIQMLIAMLIgAgACABEBAiAEGBYE8Ef0HwwwFBACAAazYCAEF/BSAACwuHEAIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQsgAkL///////8/gyEKIAIgBIVCgICAgICAgICAf4MhDCAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCEH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIg5CgICAgICAwP//AFQgDkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEMDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQwgAyEBDAILIAEgDkKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACEMDAMLIAxCgICAgICAwP//AIQhDEIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAOhFAEQEKAgICAgIDg//8AIAwgAiADhFAbIQxCACEBDAILIAIgA4RQBEAgDEKAgICAgIDA//8AhCEMQgAhAQwCCyAOQv///////z9YBEAgBUHAAmogASAKIAEgCiAKUCIGG3lCwABCACAGG3ynIgZBD2sQIEEQIAZrIQYgBSkDyAIhCiAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyALIAMgCyALUCIJG3lCwABCACAJG3ynIglBD2sQICAGIAlqQRBrIQYgBSkDuAIhCyAFKQOwAiEDCyAFQaACaiALQoCAgICAgMAAhCISQg+GIANCMYiEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABAfIAVBkAJqQgAgBSkDqAJ9QgAgBEIAEB8gBUGAAmogBSkDmAJCAYYgBSkDkAJCP4iEIgRCACACQgAQHyAFQfABaiAEQgBCACAFKQOIAn1CABAfIAVB4AFqIAUpA/gBQgGGIAUpA/ABQj+IhCIEQgAgAkIAEB8gBUHQAWogBEIAQgAgBSkD6AF9QgAQHyAFQcABaiAFKQPYAUIBhiAFKQPQAUI/iIQiBEIAIAJCABAfIAVBsAFqIARCAEIAIAUpA8gBfUIAEB8gBUGgAWogAkIAIAUpA7gBQgGGIAUpA7ABQj+IhEIBfSICQgAQHyAFQZABaiADQg+GQgAgAkIAEB8gBUHwAGogAkIAQgAgBSkDqAEgBSkDoAEiDiAFKQOYAXwiBCAOVK18IARCAVatfH1CABAfIAVBgAFqQgEgBH1CACACQgAQHyAGIAggB2tqIghB//8AaiEGAn4gBSkDcCITQgGGIg0gBSkDiAEiD0IBhiAFKQOAAUI/iIR8IhBC5+wAfSIUQiCIIgIgCkKAgICAgIDAAIQiFUIBhiIWQiCIIgR+IhEgAUIBhiIOQiCIIgsgECAUVq0gDSAQVq0gBSkDeEIBhiATQj+IhCAPQj+IfHx8QgF9IhNCIIgiEH58Ig0gEVStIA0gDSATQv////8PgyITIAFCP4giFyAKQgGGhEL/////D4MiCn58Ig1WrXwgBCAQfnwgBCATfiIRIAogEH58Ig8gEVStQiCGIA9CIIiEfCANIA9CIIZ8Ig8gDVStfCAPIA8gFEL/////D4MiFCAKfiINIAIgC358IhEgDVStIBEgESATIA5C/v///w+DIg1+fCIRVq18fCIPVq18IA8gBCAUfiIYIA0gEH58IgQgAiAKfnwiCiALIBN+fCIQQiCIIAogEFatIAQgGFStIAQgClatfHxCIIaEfCIEIA9UrXwgBCAEIBEgAiANfiIKIAsgFH58IgJCIIggAiAKVK1CIIaEfCIKIBFUrSAKIAogEEIghnwiClatfHwiBFatfCAEIAQgCiACQiCGIgIgDSAUfnwgAlStQn+FIgJWIAIgClJxrXwiBFatfCICQv////////8AWARAIBYgF4QhFSAFQdAAaiAEIAJCgICAgICAwABUIgetIguGIgogAiALhiAEQgGIIAdBP3OtiIQiBCADIBIQHyAIQf7/AGogBiAHG0EBayEGIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hC0IAIAF9DAELIAVB4ABqIAJCP4YgBEIBiIQiCiACQgGIIgQgAyASEB8gAUIwhiAFKQNofSAFKQNgIgJCAFKtfSELIAEhDkIAIAJ9CyECIAZB//8BTgRAIAxCgICAgICAwP//AIQhDEIAIQEMAQsCfiAGQQBKBEAgC0IBhiACQj+IhCEBIARC////////P4MgBq1CMIaEIQsgAkIBhgwBCyAGQY9/TARAQgAhAQwCCyAFQUBrIAogBEEBIAZrEDkgBUEwaiAOIBUgBkHwAGoQICAFQSBqIAMgEiAFKQNAIgogBSkDSCILEB8gBSkDOCAFKQMoQgGGIAUpAyAiAUI/iIR9IAUpAzAiAiABQgGGIgRUrX0hASACIAR9CyECIAVBEGogAyASQgNCABAfIAUgAyASQgVCABAfIAsgCiADIApCAYMiAyACfCICVCABIAIgA1StfCIBIBJWIAEgElEbrXwiAyAKVK18IgQgAyADIARCgICAgICAwP//AFQgAiAFKQMQViABIAUpAxgiBFYgASAEURtxrXwiA1atfCIEIAMgBEKAgICAgIDA//8AVCACIAUpAwBWIAEgBSkDCCICViABIAJRG3GtfCIBIANUrXwgDIQhDAsgACABNwMAIAAgDDcDCCAFQdACaiQACxgAQX9BASAAKAIAKAIMIAEoAgAoAgxIGwtNAQJ/An9BASAAKAIAIgAoAgQiAiABKAIAIgEoAgQiA0oNABpBfyACIANHDQAaQQEgACgCCCIAIAEoAggiAUoNABpBf0EAIAAgAUcbCwsYAEEBQX8gACgCACgCECABKAIAKAIQShsLnwEBA38gACgCACIAKAIUIgIgASgCACIBKAIUIgNKBEBBfw8LIAIgA0cEQEEBDwsgASgCACEBAkAgACgCACICLQAAIgBFBEBBACEA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bGQgYmUgbm8gY2hhcmFjdGVyIG5vdCBtYXRjaGluZyB0aGUgYWxwaGFiZXQALS1mb3JtYXQASW5wdXQgYWxpZ25tZW50cyBoYXZlIGRpZmZlcmVudCBhbHBoYWJldHMATm8gdGFza3MATm8gaW5maWxlcwBObyBpbnB1dCBmaWxlcwBDYWxjdWxhdGluZyBwYWlyd2lzZSBkaXN0YW5jZXMALW4vLS1udGhyZWFkcwBObyBmaWxlbmFtZSBmb3VuZCBpbjogJXMAQ291bGQgbm90IGRldGVjdCBpbnB1dCBpbiBmaWxlOiAlcwBDUFUgVGltZTogJS4yZnUgJXMgRWxhcHNlZDogJXMAaSA9PSBudW1fYW5jaG9yAG1hbGxvYyBvbiBhIG51bi1udWxsIHBvaW50ZXIAZnJlZSBvbiBhIG51bGwgcG9pbnRlcgBoZWxwAC0tZ3BvAHZlcnNpb24AcHJvdGVpbgBBdHRlbXB0aW5nIHN0ZGluAGthbGlnbgBuYW4AaW50ZXJuYWwAQWxpZ25pbmcAbXNmAGluZgAgTmFtZTogJS0qLipzICBMZW46ICAlNWQgIENoZWNrOiAlNGQgIFdlaWdodDogJS4yZgAtLXR5cGUALS10Z3BlAC0tZ3BlAG5vdGltZQBFbmNvdW50ZXJlZCBhIHNlcXVlbmNlIGJlZm9yZSBlbmNvdW50ZXJpbmcgaXQncyBuYW1lAG91dGZpbGUAaW5maWxlACUwKmxsZAAlKmxsZAArJWxsZAAlKy40bGQAd3JpdGUgZmFpbGVkAHJlYWxsb2MgZm9yIHNpemUgJWQgZmFpbGVkAG1hbGxvYyBvZiBzaXplICVkIGZhaWxlZAAlMDJkOiUwMmQ6JTAyZC4lMDJkAENvdW5kIG5vdCBzZWxlY3QgYWxsIGFuY2hvcnMJbnVtX2FuY2hvcjolZAkgbnVtc2VxOiVkACVZLSVtLSVkAERJTTEgaXMgdG9vIHNtYWxsOiAlZAByd2EAZmFzdGEATm8gbXNhAHJuYQBkbmEAZmEAW0Zhc3RhXQBbcm5hXQBbXQBbTkFdAFthdXRvOiBOLTEsIG1heCAxNl0AQ0xVU1RBTCBXAGk6bzpmOm46aHF2VgAhIU5BX01VTFRJUExFX0FMSUdOTUVOVAAhIUFBX01VTFRJUExFX0FMSUdOTUVOVAAlSDolTTolUwBDTFVTVEFMIE8ATkFOACVCICVkLCAlWSAlSDolTQBtc2EhPSBOVUxMAHQgIT0gTlVMTABtc2EgIT0gTlVMTABJTkYAdGltZSBmYWlsZWQ/Pz8Ab2ZmZW5kaW5nIGNoYXJhY3RlcjogPj4+JWM8PDwATGVuOgBOYW1lOgBNU0Y6AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDI5OQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxOTkAL2J1aWxkL2thbGlnbi9saWIvc3JjL3Rhc2suYyBsaW5lIDE5OQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSAxODkAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9tZW0uYyBsaW5lIDg5AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDk3OQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjc5AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDE3OQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSA5NjkAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMzY5AC9idWlsZC9rYWxpZ24vbGliL3NyYy90YXNrLmMgbGluZSAxNjkAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9jaGVjay5jIGxpbmUgNjkAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMzQ5AC9idWlsZC9rYWxpZ24vbGliL3NyYy9lc2xfc3RvcHdhdGNoLmMgbGluZSAzOQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSA1MjkAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMzI5AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fc2V0dXAuYyBsaW5lIDI5AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEyMDkAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMjA5AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfY2hlY2suYyBsaW5lIDk4AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDExODgAL2J1aWxkL2thbGlnbi9saWIvc3JjL3BpY2tfYW5jaG9yLmMgbGluZSA4OAAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3dyYXAuYyBsaW5lIDg4AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fbWVtLmMgbGluZSA4OAAvYnVpbGQva2FsaWduL3NyYy9ydW5fa2FsaWduLmMgbGluZSAyNzgAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgNTgAL2J1aWxkL2thbGlnbi9saWIvc3JjL3BpY2tfYW5jaG9yLmMgbGluZSA0OAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjM4AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDUyOAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjI4AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEyOAAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3BhcmFtLmMgbGluZSAyOAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2FsbG9jLmMgbGluZSAyOAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAzOTcAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgMTk3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDE5NwAvYnVpbGQva2FsaWduL3NyYy9wYXJhbWV0ZXJzLmMgbGluZSA5NwAvYnVpbGQva2FsaWduL2xpYi9zcmMvdGFzay5jIGxpbmUgMTc3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9waWNrX2FuY2hvci5jIGxpbmUgNzcAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9tZW0uYyBsaW5lIDc3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9zZXF1ZW5jZV9kaXN0YW5jZS5jIGxpbmUgNzcAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMzY3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDE2NwAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3dyYXAuYyBsaW5lIDY3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcGFyYW0uYyBsaW5lIDY3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDU0NwAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSAzNDcAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMjQ3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDE0NwAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3J1bi5jIGxpbmUgMTQ3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDUyNwAvYnVpbGQva2FsaWduL2xpYi9zcmMvdGxtaXNjLmMgbGluZSAxMjcAL2J1aWxkL2thbGlnbi9zcmMvcGFyYW1ldGVycy5jIGxpbmUgMTE3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDExNwAvYnVpbGQva2FsaWduL2xpYi9zcmMvdGFzay5jIGxpbmUgMTE3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEwMTcAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgMjA3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fd3JhcC5jIGxpbmUgMTA3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9zZXF1ZW5jZV9kaXN0YW5jZS5jIGxpbmUgMTA3AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDI3NgAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX21lbS5jIGxpbmUgNzYAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMzY2AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDQ1NgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSAzNTYAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMTI0NgAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3BhcmFtLmMgbGluZSA0NgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAyMzYAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTI2AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEyMjYAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMTI2AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDUxNgAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3dyYXAuYyBsaW5lIDExNgAvYnVpbGQva2FsaWduL2xpYi9zcmMvdGFzay5jIGxpbmUgMTE2AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fbWVtLmMgbGluZSAxNgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSA1MDYAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgODk1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDQ5NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjg1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDI4NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxODUAL2J1aWxkL2thbGlnbi9saWIvc3JjL3Rhc2suYyBsaW5lIDE4NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvcGlja19hbmNob3IuYyBsaW5lIDg1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcGFyYW0uYyBsaW5lIDc1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfY2hlY2suYyBsaW5lIDc1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDc2NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjY1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcGFyYW0uYyBsaW5lIDI2NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX21lbS5jIGxpbmUgNjUAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgMzU1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcnVuLmMgbGluZSAyNTUAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9zZXR1cC5jIGxpbmUgNTUAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl93cmFwLmMgbGluZSA1NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3J1bi5jIGxpbmUgMjQ1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDE0NQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMzUAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMTM1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDUyNQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjI1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDEwMjUAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTE1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDExNQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2NoZWNrLmMgbGluZSAxMTUAL2J1aWxkL2thbGlnbi9saWIvc3JjL3RsbWlzYy5jIGxpbmUgMTE1AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfYWxsb2MuYyBsaW5lIDExNQAvYnVpbGQva2FsaWduL3NyYy9ydW5fa2FsaWduLmMgbGluZSAzMDUAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMTIwNQAzLjQuNQAvYnVpbGQva2FsaWduL2xpYi9zcmMvYmlzZWN0aW5nS21lYW5zLmMgbGluZSA4OTQAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMjg0AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDExODQAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgNjc0AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDExNzQAL2J1aWxkL2thbGlnbi9saWIvc3JjL3BpY2tfYW5jaG9yLmMgbGluZSA2NAAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX21lbS5jIGxpbmUgNjQAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9wYXJhbS5jIGxpbmUgNjQAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgMTU0AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfYWxsb2MuYyBsaW5lIDU0AC9idWlsZC9rYWxpZ24vc3JjL3J1bl9rYWxpZ24uYyBsaW5lIDE0NAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2FsbG9jLmMgbGluZSAxMzQAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMzQAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTI0AC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDEyNAAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3BhcmFtLmMgbGluZSAyNAAvYnVpbGQva2FsaWduL2xpYi9zcmMvYmlzZWN0aW5nS21lYW5zLmMgbGluZSA3MTQAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTE0AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDIxNAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2FsbG9jLmMgbGluZSAxMTQAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgMTAxNAAvYnVpbGQva2FsaWduL3NyYy9ydW5fa2FsaWduLmMgbGluZSAzMDQAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMjA0AC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDkzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEyODMAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgMTgzAC9idWlsZC9rYWxpZ24vbGliL3NyYy90bGRldmVsLmMgbGluZSAxODMAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgOTczAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDU3MwAvYnVpbGQva2FsaWduL2xpYi9zcmMvd2VhdmVfYWxpZ25tZW50LmMgbGluZSA3MwAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAzNjMAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMzYzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcGFyYW0uYyBsaW5lIDI2MwAvYnVpbGQva2FsaWduL3NyYy9ydW5fa2FsaWduLmMgbGluZSAyNTMAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMTUzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDQ0MwAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjQzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcnVuLmMgbGluZSA0MwAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX21lbS5jIGxpbmUgNDMAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgMTMzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEzMwAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3J1bi5jIGxpbmUgMTMzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfYWxsb2MuYyBsaW5lIDEzMwAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSA1MjMAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTEzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEyMTMAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMTEzAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfYWxsb2MuYyBsaW5lIDEzAC9idWlsZC9rYWxpZ24vbGliL3NyYy90bGRldmVsLmMgbGluZSAyOTIAL2J1aWxkL2thbGlnbi9saWIvc3JjL2FscGhhYmV0LmMgbGluZSA5MgAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3dyYXAuYyBsaW5lIDkyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDM4MgAvYnVpbGQva2FsaWduL2xpYi9zcmMvdGFzay5jIGxpbmUgMTgyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fd3JhcC5jIGxpbmUgODIAL2J1aWxkL2thbGlnbi9saWIvc3JjL3dlYXZlX2FsaWdubWVudC5jIGxpbmUgNzIAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl93cmFwLmMgbGluZSA3MgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMjYyAC9idWlsZC9rYWxpZ24vc3JjL3BhcmFtZXRlcnMuYyBsaW5lIDYyAC9idWlsZC9rYWxpZ24vc3JjL3J1bl9rYWxpZ24uYyBsaW5lIDM1MgAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX3J1bi5jIGxpbmUgMjUyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfYWxsb2MuYyBsaW5lIDE1MgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSA0NDIAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9tZW0uYyBsaW5lIDQyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDEwMzIAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTIyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDEyMgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSA1MTIAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgMzEyAC9idWlsZC9rYWxpZ24vbGliL3NyYy90YXNrLmMgbGluZSAyMTIAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgMTEyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDExMgAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSA1MDIAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgNDAyAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDU5MQAvYnVpbGQva2FsaWduL2xpYi9zcmMvYWxuX21lbS5jIGxpbmUgOTEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgOTEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9jaGVjay5jIGxpbmUgNzEAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgOTYxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcnVuLmMgbGluZSAyNjEAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgMTYxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDE2MQAvYnVpbGQva2FsaWduL2xpYi9zcmMvcGlja19hbmNob3IuYyBsaW5lIDYxAC9idWlsZC9rYWxpZ24vc3JjL3J1bl9rYWxpZ24uYyBsaW5lIDYxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcGFyYW0uYyBsaW5lIDYxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcnVuLmMgbGluZSAyNTEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMTUxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fcnVuLmMgbGluZSAxNDEAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9ydW4uYyBsaW5lIDQxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fbWVtLmMgbGluZSA0MQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSA0MzEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9jaGVjay5jIGxpbmUgMTMxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDEwMzEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9pby5jIGxpbmUgNDIxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDUxMQAvYnVpbGQva2FsaWduL3NyYy9ydW5fa2FsaWduLmMgbGluZSAzMTEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMTExAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2Ffb3AuYyBsaW5lIDUwMQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSAzMDEAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Jpc2VjdGluZ0ttZWFucy5jIGxpbmUgMjAxAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDIwMQAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMDEAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9hbGxvYy5jIGxpbmUgMTAxAG1zYS0+bnVtc2VxID4gMQBkaW0xID49IDEAL2J1aWxkL2thbGlnbi9zcmMvcnVuX2thbGlnbi5jIGxpbmUgMzkwAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDkwAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fbWVtLmMgbGluZSA5MAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSAxMTgwAC9idWlsZC9rYWxpZ24vbGliL3NyYy9hbG5fd3JhcC5jIGxpbmUgNzAAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTUwAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfYWxsb2MuYyBsaW5lIDE1MAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSA3NDAAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9tZW0uYyBsaW5lIDQwAC9idWlsZC9rYWxpZ24vbGliL3NyYy9tc2FfaW8uYyBsaW5lIDEzMAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX2lvLmMgbGluZSA5MjAAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl93cmFwLmMgbGluZSAxMjAAL2J1aWxkL2thbGlnbi9saWIvc3JjL2Fsbl9wYXJhbS5jIGxpbmUgMjAAL2J1aWxkL2thbGlnbi9saWIvc3JjL21zYV9vcC5jIGxpbmUgNTEwAC9idWlsZC9rYWxpZ24vbGliL3NyYy9iaXNlY3RpbmdLbWVhbnMuYyBsaW5lIDkwMAAvYnVpbGQva2FsaWduL2xpYi9zcmMvbXNhX29wLmMgbGluZSAzMDAAISFOQV9NVUxUSVBMRV9BTElHTk1FTlQgMS4wACEhQUFfTVVMVElQTEVfQUxJR05NRU5UIDEuMAB0LT5uX3Rhc2tzICE9IDAALy8AVGVybWluYWwgZ2FwIGV4dGVuc2lvbiBwZW5hbHR5LgBHYXAgZXh0ZW5zaW9uIHBlbmFsdHkuAEdhcCBvcGVuIHBlbmFsdHkuAE5vIHNlcXVlbmNlcyB3ZXJlIGZvdW5kIGluIHRoZSBpbnB1dCBmaWxlcyBvciBzdGFuZGFyZCBpbnB1dC4AUmVhZCAlZCBzZXF1ZW5jZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4ARmlsZTogJXMgZG9lcyBub3QgZXhpc3QuAE91dHB1dCBmb3JtYXQuAERldGVjdGVkIHByb3RlaW4gc2VxdWVuY2VzLgBEZXRlY3RlZCBETkEgc2VxdWVuY2VzLgBOdW1iZXIgb2YgdGhyZWFkcy4AUmVhZCAlZCBzZXF1ZW5jZXMgZnJvbSAlcy4AUHJpbnRzIHZlcnNpb24uAFVuYWJsZSB0byBkZXRlcm1pbmUgd2hhdCBhbHBoYWJldCB0byB1c2UuAEJ1aWxkaW5nIGd1aWRlIHRyZWUuAG9ubHkgJWQgc2VxdWVuY2VzIGZvdW5kLgBBbHBoYWJldCBub3QgcmVjb2duaXplZC4ARm9ybWF0ICVzIG5vdCByZWNvZ25pemVkLgBJbiAlcyBub3QgcmVjb2duaXplZC4ARGV0ZWN0ZWQgRE5BIHNlcXVlbmNlcyBidXQgLS10eXBlIHByb3RlaW4gb3B0aW9uIHdhcyBzZWxlY3RlZC4ARGV0ZWN0ZWQgcHJvdGVpbiBzZXF1ZW5jZXMgYnV0IC0tdHlwZSBybmEgb3B0aW9uIHdhcyBzZWxlY3RlZC4ARGV0ZWN0ZWQgcHJvdGVpbiBzZXF1ZW5jZXMgYnV0IC0tdHlwZSBkbmEgb3B0aW9uIHdhcyBzZWxlY3RlZC4ARGV0ZWN0ZWQgcHJvdGVpbiBzZXF1ZW5jZXMgYnV0IC0tdHlwZSBpbnRlcm5hbCAgb3B0aW9uIHdhcyBzZWxlY3RlZC4AQ2Fubm90IHByb2R1Y2UgbXNhIG91dHB1dDogU2VxdWVuY2VzIGFyZSBub3QgYWxpZ25lZC4ARnVuY3Rpb24gInByaW50X2thbGlnbl9oZWxwKGFyZ3YpIiBmYWlsZWQuAEZ1bmN0aW9uICJrYWxpZ25fcmVhZF9pbnB1dChwYXJhbS0+aW5maWxlW2ldLCAmbXNhLHBhcmFtLT5xdWlldCkiIGZhaWxlZC4ARnVuY3Rpb24gImthbGlnbl9yZWFkX2lucHV0KHBhcmFtLT5pbmZpbGVbMF0sICZtc2EscGFyYW0tPnF1aWV0KSIgZmFpbGVkLgBGdW5jdGlvbiAiY2hlY2tfbXNhX2Zvcm1hdF9zdHJpbmcocGFyYW0tPmZvcm1hdCkiIGZhaWxlZC4ARnVuY3Rpb24gImthbGlnbl93cml0ZV9tc2EobXNhLCBwYXJhbS0+b3V0ZmlsZSwgcGFyYW0tPmZvcm1hdCkiIGZhaWxlZC4ARnVuY3Rpb24gImFuY2hvcnMgPSBwaWNrX2FuY2hvcihtc2EsICZudW1fYW5jaG9ycykiIGZhaWxlZC4ARnVuY3Rpb24gImJ1aWxkX3RyZWVfa21lYW5zKG1zYSwmdGFza3MpIiBmYWlsZWQuAEZ1bmN0aW9uICJjcmVhdGVfbXNhX3RyZWUobXNhLCBhcCwgdGFza3MpIiBmYWlsZWQuAEZ1bmN0aW9uICJfR2VuZXJpYygoJmRtKSwgY2hhcioqKjogYWxsb2NfMkRfYXJyYXlfc2l6ZV9jaGFyLCBpbnQ4X3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfaW50OF90LCB1aW50OF90KioqOiBhbGxvY18yRF9hcnJheV9zaXplX3VpbnQ4X3QsIGludDE2X3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfaW50MTZfdCwgdWludDE2X3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfdWludDE2X3QsIGludDMyX3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfaW50MzJfdCwgdWludDMyX3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfdWludDMyX3QsIGludDY0X3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfaW50NjRfdCwgdWludDY0X3QqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfdWludDY0X3QsIGZsb2F0KioqOiBhbGxvY18yRF9hcnJheV9zaXplX2Zsb2F0LCBkb3VibGUqKio6IGFsbG9jXzJEX2FycmF5X3NpemVfZG91YmxlLCBkZWZhdWx0OiBnYWxsb2NfdW5rbm93bl90eXBlX2Vycm9yICkoJmRtLG51bV9zYW1wbGVzLG51bV9zYW1wbGVzKSIgZmFpbGVkLgBGdW5jdGlvbiAicmVzID0gYWxsb2Nfa21lYW5zX3Jlc3VsdChudW1fc2FtcGxlcykiIGZhaWxlZC4ARnVuY3Rpb24gImFuY2hvcnMgPSBzZWxlY3Rfc2Vxcyhtc2EsIG51bV9hbmNob3IpIiBmYWlsZWQuAEZ1bmN0aW9uICJhbGxvY190YXNrcygmdCwgbXNhLT5udW1zZXEpIiBmYWlsZWQuAEZ1bmN0aW9uICJhbGxvY190YXNrcygmdGFza3MsIG1zYS0+bnVtc2VxKSIgZmFpbGVkLgBGdW5jdGlvbiAicnVuX2thbGlnbihwYXJhbSkiIGZhaWxlZC4ARnVuY3Rpb24gImRldGVjdF9hbHBoYWJldChtKSIgZmFpbGVkLgBGdW5jdGlvbiAic2V0X3NpcF9uc2lwKG0pIiBmYWlsZWQuAEZ1bmN0aW9uICJpbml0X2Fsbm1lbShtKSIgZmFpbGVkLgBGdW5jdGlvbiAicmVzaXplX2Fsbl9tZW0obSkiIGZhaWxlZC4ARnVuY3Rpb24gInJlYWRfY2x1KGIsJm0pIiBmYWlsZWQuAEZ1bmN0aW9uICJyZWFkX21zZihiLCZtKSIgZmFpbGVkLgBGdW5jdGlvbiAicmVhZF9mYXN0YShiLCZtKSIgZmFpbGVkLgBGdW5jdGlvbiAibWVyZ2VfbXNhKG1zYSwgbSkiIGZhaWxlZC4ARnVuY3Rpb24gImxiID0gYWxsb2NfbGluZV9idWZmZXIobGluZV9sZW5ndGgpIiBmYWlsZWQuAEZ1bmN0aW9uICJtYWtlX3NlcShtc2EsYSxiLG0tPnBhdGgpIiBmYWlsZWQuAEZ1bmN0aW9uICJzZXRfYWxuX3R5cGUoaW5fdHlwZSwgJnBhcmFtLT50eXBlKSIgZmFpbGVkLgBGdW5jdGlvbiAiYSA9IGNyZWF0ZV9hbHBoYWJldCh0eXBlKSIgZmFpbGVkLgBGdW5jdGlvbiAicGFyc2VfZm9ybWF0X2FyZ3VtZW50KGZvcm1hdCwgJnR5cGUpIiBmYWlsZWQuAEZ1bmN0aW9uICJrYWxpZ25fcnVuKG1zYSwgcGFyYW0tPm50aHJlYWRzLCBwYXJhbS0+dHlwZSwgcGFyYW0tPmdwbywgcGFyYW0tPmdwZSwgcGFyYW0tPnRncGUpIiBmYWlsZWQuAEZ1bmN0aW9uICJhbG5fcGFyYW1faW5pdCgmYXAsIG1zYS0+YmlvdHlwZSwgbl90aHJlYWRzLCB0eXBlLCBncG8sIGdwZSwgdGdwZSkiIGZhaWxlZC4ARnVuY3Rpb24gInRsZmlsZW5hbWUob3V0ZmlsZSwgJmJhc2VuYW1lKSIgZmFpbGVkLgBGdW5jdGlvbiAidGxmaWxlbmFtZShhcmd2WzBdLCAmYmFzZW5hbWUpIiBmYWlsZWQuAEZ1bmN0aW9uICJ3cml0ZV9tc2FfY2x1KG1zYSwgb3V0ZmlsZSkiIGZhaWxlZC4ARnVuY3Rpb24gIndyaXRlX21zYV9tc2YobXNhLCBvdXRmaWxlKSIgZmFpbGVkLgBGdW5jdGlvbiAid3JpdGVfbXNhX2Zhc3RhKG1zYSwgb3V0ZmlsZSkiIGZhaWxlZC4ARnVuY3Rpb24gInJlYWRfZmlsZV9zdGRpbigmYixpbmZpbGUpIiBmYWlsZWQuAEZ1bmN0aW9uICJkZXRlY3RfYWxwaGFiZXQoZCkiIGZhaWxlZC4ARnVuY3Rpb24gInNldF9zaXBfbnNpcChkKSIgZmFpbGVkLgBGdW5jdGlvbiAicmVzaXplX21zYShkKSIgZmFpbGVkLgBGdW5jdGlvbiAicmVzaXplX2luX2J1ZmZlcihiKSIgZmFpbGVkLgBGdW5jdGlvbiAiY2hlY2tfZm9yX3NlcXVlbmNlcygqbXNhKSIgZmFpbGVkLgBGdW5jdGlvbiAiZmluYWxpc2VfYWxpZ25tZW50KG1zYSkiIGZhaWxlZC4ARnVuY3Rpb24gInJlc2l6ZV9tc2EobXNhKSIgZmFpbGVkLgBGdW5jdGlvbiAiYWxsb2NfbXNhX3NlcSgmbS0+c2VxdWVuY2VzW2ldKSIgZmFpbGVkLgBGdW5jdGlvbiAiYWxsb2NfbXNhX3NlcSgmbXNhLT5zZXF1ZW5jZXNbaV0pIiBmYWlsZWQuAEZ1bmN0aW9uICJtYWtlX3Byb2ZpbGVfbihtLT5hcCwgbXNhLT5zZXF1ZW5jZXNbYl0tPnMsbS0+bGVuX2IsJnQtPnByb2ZpbGVbYl0pIiBmYWlsZWQuAEZ1bmN0aW9uICJtYWtlX3Byb2ZpbGVfbihtLT5hcCwgbXNhLT5zZXF1ZW5jZXNbYV0tPnMsbS0+bGVuX2EsJnQtPnByb2ZpbGVbYV0pIiBmYWlsZWQuAEZ1bmN0aW9uICJjb252ZXJ0X21zYV90b19pbnRlcm5hbChtc2EsIDUpIiBmYWlsZWQuAEZ1bmN0aW9uICJhbGxvY19pbl9idWZmZXIoJmIsIDEwMjQpIiBmYWlsZWQuAEZ1bmN0aW9uICJjb252ZXJ0X21zYV90b19pbnRlcm5hbChtc2EsIDIzKSIgZmFpbGVkLgBGdW5jdGlvbiAiY29udmVydF9tc2FfdG9faW50ZXJuYWwobXNhLCAxMykiIGZhaWxlZC4ARnVuY3Rpb24gImFsbG9jX21zYSgmbXNhLDUxMikiIGZhaWxlZC4ARnVuY3Rpb24gInNvcnRfdGFza3ModCwgMikiIGZhaWxlZC4ARnVuY3Rpb24gImRtID0gZF9lc3RpbWF0aW9uKG1zYSwgc2FtcGxlcywgbnVtX3NhbXBsZXMsMSkiIGZhaWxlZC4ARnVuY3Rpb24gImRtID0gZF9lc3RpbWF0aW9uKG1zYSwgYW5jaG9ycywgbnVtX2FuY2hvcnMsMCkiIGZhaWxlZC4ARnVuY3Rpb24gImthbGlnbl9lc3NlbnRpYWxfaW5wdXRfY2hlY2sobXNhLCAwKSIgZmFpbGVkLgBGdW5jdGlvbiAicGFyYW0gPSBpbml0X3BhcmFtKCkiIGZhaWxlZC4ARnVuY3Rpb24gImZfcHRyID0gZm9wZW4ob3V0ZmlsZSwgInciKSIgZmFpbGVkLgBGdW5jdGlvbiAiZl9wdHIgPSBmb3BlbihpbmZpbGUsICJyIikiIGZhaWxlZC4ATnVtYmVyIG9mIHRocmVhZHMgaGFzIHRvIGJlID49IDEuAFJlbW92aW5nICVkIHNlcXVlbmNlcyB3aXRoIGEgbGVuZ3RoIG9mIDAuAFJlbW92aW5nICVkIHNlcXVlbmNlIHdpdGggYSBsZW5ndGggb2YgMC4AICVzICBNU0Y6ICVkICBUeXBlOiAlYyAgJXMgIENoZWNrOiAlZCAgLi4AQWxpZ25tZW50IHR5cGUgKHJuYSwgZG5hLCBpbnRlcm5hbCkuACAgICAgICAgIHJuYSwgZG5hLCBpbnRlcm5hbCAobnVjKS4ALS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0ALS12ZXJzaW9uICgtVi8tdikAT3B0aW9uczogcHJvdGVpbiwgZGl2ZXJnZW50IChwcm90ZWluKQAobnVsbCkAJQBCVVQgdGhlIHByZXN1bWFibHkgYWxpZ25lZCBzZXF1ZW5jZXMgZG8gbm90IABObyBzZXF1ZW5jZSBmb3VuZCBmb3Igc2VxdWVuY2UgJXMgAFslRiAlSDolTTolU10gAEVSUk9SIABMT0cgAFdBUk5JTkcgADogb3B0aW9uIHJlcXVpcmVzIGFuIGFyZ3VtZW50OiAAOiBvcHRpb24gZG9lcyBub3QgdGFrZSBhbiBhcmd1bWVudDogADogb3B0aW9uIGlzIGFtYmlndW91czogAFRoZSBpbnB1dCBzZXF1ZW5jZXMgY29udGFpbiBnYXAgY2hhcmFjdGVyczogACUqczogADogdW5yZWNvZ25pemVkIG9wdGlvbjogAFVuYWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2VxdWVuY2VzICAgAEthbGlnbiB3aWxsIHJlbW92ZSB0aGUgZ2FwIGNoYXJhY3RlcnMgYW5kICAgAEFsbCBpbnB1dCBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGguICAgAEJVVCB0aGVyZSBhcmUgbm8gZ2FwIGNoYXJhY3RlcnMuICAgICAgICAgICAgAEthbGlnbiB3aWxsIGFsaWduIHRoZSBzZXF1ZW5jZXMuICAgICAgICAgICAgAGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAgICAgICAgICAgICAgICAgICAgICAgAGFsaWduIHRoZSBzZXF1ZW5jZXMuICAgICAgICAgICAgICAgICAgICAgICAgAGFyZSBhbHJlYWR5IGFsaWduZWQuICAgICAgICAgICAgICAgICAgICAgICAgACIlYyIgOiAlNGQgZm91bmQgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgAFRoaXMgaXMgZnJlZSBzb2Z0d2FyZSwgYW5kIHlvdSBhcmUgd2VsY29tZSB0byByZWRpc3RyaWJ1dGUgaXQKAD4lcwoAJSpzJS0qczogJXMgJXMKACUqcyUtKnMgICVzICVzCgBDb3B5cmlnaHQgKEMpIDIwMDYsMjAxOSwyMDIwLDIwMjEsMjAyMyBUaW1vIExhc3NtYW5uCgBIT0xERVJTIEFORC9PUiBPVEhFUiBQQVJUSUVTIFBST1ZJREUgVEhFIFBST0dSQU0gIkFTIElTIiBXSVRIT1VUIFdBUlJBTlRZCgBUSEVSRSBJUyBOTyBXQVJSQU5UWSBGT1IgVEhFIFBST0dSQU0sIFRPIFRIRSBFWFRFTlQgUEVSTUlUVEVEIEJZCgBBUFBMSUNBQkxFIExBVy4gIEVYQ0VQVCBXSEVOIE9USEVSV0lTRSBTVEFURUQgSU4gV1JJVElORyBUSEUgQ09QWVJJR0hUCgBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSCgBQVVJQT1NFLiAgVEhFIEVOVElSRSBSSVNLIEFTIFRPIFRIRSBRVUFMSVRZIEFORCBQRVJGT1JNQU5DRSBPRiBUSEUgUFJPR1JBTQoASVMgV0lUSCBZT1UuICBTSE9VTEQgVEhFIFBST0dSQU0gUFJPVkUgREVGRUNUSVZFLCBZT1UgQVNTVU1FIFRIRSBDT1NUIE9GCgBQbGVhc2UgY2l0ZToKAFRoaXMgcHJvZ3JhbSBjb21lcyB3aXRoIEFCU09MVVRFTFkgTk8gV0FSUkFOVFk7IGZvciBkZXRhaWxzIHR5cGU6CgBIZXJlIGlzIHRoZSBEaXNjbGFpbWVyIG9mIFdhcnJhbnR5IHNlY3Rpb24gb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIChHUEwpOgoAICBodHRwczovL2RvaS5vcmcvMTAuMTA5My9iaW9pbmZvcm1hdGljcy9idHo3OTUKADE1LiBEaXNjbGFpbWVyIG9mIFdhcnJhbnR5LgoAdW5kZXIgY2VydGFpbiBjb25kaXRpb25zOyBjb25zdWx0IHRoZSBDT1BZSU5HIGZpbGUgZm9yIGRldGFpbHMuCgAgIExhc3NtYW5uLCBUaW1vLgoAQSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBHUEwgY2FuIGJlIGZvdW5kIGluIHRoZSAiQ09QWUlORyIgZmlsZS4KAEFMTCBORUNFU1NBUlkgU0VSVklDSU5HLCBSRVBBSVIgT1IgQ09SUkVDVElPTi4KAGBrYWxpZ24gLXNob3d3Jy4KAE9GIEFOWSBLSU5ELCBFSVRIRVIgRVhQUkVTU0VEIE9SIElNUExJRUQsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLAoAS2FsaWduICglcykKACAgIkthbGlnbiAzOiBtdWx0aXBsZSBzZXF1ZW5jZSBhbGlnbm1lbnQgb2YgbGFyZ2UgZGF0YSBzZXRzLiIKACAgQmlvaW5mb3JtYXRpY3MgKDIwMTkpIAoAClVzYWdlOiAlcyAlcwoKAFBhc3Npbmcgc2VxdWVuY2VzIHZpYSBzdGRpbjoKCiAgIGNhdCBpbnB1dC5mYSB8IGthbGlnbiAtZiBmYXN0YSA+IG91dC5hZmEKCgBDb21iaW5pbmcgbXVsdGlwbGUgaW5wdXQgZmlsZXM6CgogICBrYWxpZ24gc2Vxc0EuZmEgc2Vxc0IuZmEgc2Vxc0MuZmEgLWYgZmFzdGEgPiBjb21iaW5lZC5hZmEKCgBPcHRpb25zOgoKAApFeGFtcGxlczoKCgAJAAAAAAAvBABB7JABC9YBBQAAAC0FAAABAAAAAAAAAAEAAABwBQAAAQAAAAAAAABmAAAAFgcAAAEAAAAAAAAADQAAAJcGAAABAAAAAAAAAAYAAAAkBwAAAQAAAAAAAAAHAAAAHQcAAAEAAAAAAAAACAAAAOgFAAABAAAAAAAAAG4AAACiBAAAAQAAAAAAAABpAAAAbAcAAAEAAAAAAAAAaQAAALkGAAABAAAAAAAAAGkAAAA5BAAAAQAAAAAAAABvAAAAZAcAAAEAAAAAAAAAbwAAAKsEAAABAAAAAAAAAG8AAACQBgBBzJIBCwZoAAAAmwYAQdySAQsGdgAAADEFAEHskgELAXEAQYCTAQttIC1pIDxzZXEgZmlsZT4gLW8gPG91dCBhbG4+IAAAAAAYAAAA+v////3////9////BQAAAP7///8AAAAABQAAAPj////4////9P////z////5////6f///wMAAAALAAAABgAAANz////q////AQBB/JMBC1D6////LwAAAAMAAAD9////6v///w8AAAAEAAAA9v///wYAAADo////6v///xsAAADv////4P////f////+/////v////D////u////7P///wBB2JQBC1D9////AwAAACYAAAAWAAAA7v///wcAAAAJAAAABAAAAAwAAADk////4v///wgAAADq////4f////f///8JAAAABQAAANz////y////6v///wBBtJUBC1D9/////f///xYAAAAvAAAA4P///wkAAAAbAAAAAQAAAAQAAADa////2P///wUAAADi////0/////n///8FAAAAAAAAAMz////k////4////wBBkJYBC0wFAAAA6v///+7////g////cwAAAOj////i////7P////P////1////8f///+T////3////+P///+H///8BAAAA+/////b////7////AEHslgELUP7///8PAAAABwAAAAkAAADo////GwAAABEAAAD2////DAAAAO3////w////DwAAAPb////m/////v///wIAAAAAAAAA5f///+/////x////AEHMlwELTAQAAAAJAAAAGwAAAOL///8RAAAAJAAAAPj///8EAAAA5f///+T///8MAAAA7P///9n////7////AgAAAP/////V////5f///+3///8AQaSYAQtQBQAAAPb///8EAAAAAQAAAOz////2////+P///0IAAADy////0////9T////1////3f///8z////w////BAAAAPX////Y////2P///9////8AQYCZAQtQ+P///wYAAAAMAAAABAAAAPP///8MAAAABAAAAPL///88AAAA6v///+3///8GAAAA8//////////1/////v////3////4////FgAAAOz///8AQdyZAQtN+P///+j////k////2v////X////t////5f///9P////q////KAAAABwAAADr////GQAAAAoAAADm////7v////r////u////+f///x8AQbiaAQtN9P///+r////i////2P////H////w////5P///9T////t////HAAAACgAAADr////HAAAABQAAADp////6/////P////5////AAAAABIAQZSbAQtQ/P///xsAAAAIAAAABQAAAOT///8PAAAADAAAAPX///8GAAAA6////+v///8gAAAA8v///9/////6////AQAAAAEAAADd////6////+////8AQfCbAQtN+f///+/////q////4v////f////2////7P///93////z////GQAAABwAAADy////KwAAABAAAADo////8v////r////2/////v///xAAQcycAQtN6f///+D////h////0/////j////m////2f///8z/////////CgAAABQAAADf////EAAAAEYAAADa////5P///+r///8kAAAAMwAAAAEAQaidAQtQAwAAAPf////3////+f///+H////+////+/////D////1////5v///+n////6////6P///9r///9MAAAABAAAAAEAAADO////4f///+7///8AQYSeAQtQCwAAAP7///8JAAAABQAAAAEAAAACAAAAAgAAAAQAAAD+////7v///+v///8BAAAA8v///+T///8EAAAAFgAAAA8AAADf////7f////b///8AQeCeAQtMBgAAAP7///8FAAAAAAAAAPv///8AAAAA//////X////9////+v////P///8BAAAA+v///+r///8BAAAADwAAABkAAADd////7f///wBBvJ8BC1Dc////8P///9z////M////9v///+X////V////2P////j////u////+f///93////2////JAAAAM7////f////3f///44AAAApAAAA5v///wBBmKABC1Dq////7v////L////k////+////+/////l////2P///xYAAAD5////AAAAAOv////+////MwAAAOH////t////7f///ykAAABOAAAA9f///wBB9KABC00BAAAA7P///+r////j////AAAAAPH////t////3////+z///8fAAAAEgAAAO////8QAAAAAQAAAO7////2////AAAAAOb////1////IgBB8KMBC80BBQAAAP///////////v////7//////////////wAAAAD+////////////////////AAAAAP7/////////AQAAAAAAAAD+/////v///wAAAAD+/////////wAAAAD/////BgAAAAAAAAD//////f///wEAAAABAAAA/v///wAAAAD+/////v///wMAAAD//////f///////////////////////////////v///wAAAAABAAAA//////////8AAAAABgAAAAIAAAD9////AQBBzKUBC50G/f////3///8AAAAA/v////7/////////AQAAAAAAAAD+//////////7///8EAAAAAAAAAP/////+/////////wIAAAAHAAAA/f///wEAAAACAAAA///////////9/////f///wAAAAD9/////f////////8AAAAA//////3////+/////f///wUAAAACAAAA//////7////9/////f////3///8MAAAA/f////z////9/////v////7////9/////f////7//////////f////7////+/////f////7////+/////f////3////+/////////wEAAAABAAAAAQAAAP3///8FAAAAAgAAAP7///8AAAAA/v////7///8BAAAAAAAAAP7/////////AAAAAAAAAAD///////////7///8BAAAAAwAAAAAAAAD/////AQAAAAAAAAACAAAA/P///wIAAAAGAAAA/v/////////9/////f///wEAAAD+/////f///wAAAAAAAAAA//////7////+/////v///wEAAAAEAAAA/////wAAAAD+////AAAAAP/////9/////v////7///8HAAAA/v////z////8/////v////3////9/////v///wAAAAD+/////f////3////9//////////7//////////v///wAAAAAAAAAA//////7///8AAAAA//////7///8KAAAA/f////3///8AAAAA/v////7////+///////////////+////AQAAAP3///8AAAAAAAAAAP///////////v////3////9/////v////7////9/////P////3///8FAAAAAgAAAP7///8CAAAAAAAAAP3////+////////////////////AwAAAP3////+///////////////+/////f////3////9/////v////3////8/////f///wIAAAAFAAAA/v///wMAAAABAAAA/f////3////+////AAAAAP////8BAAAA/f////7//////////////wMAQfSrAQv0Av3///8BAAAAAQAAAP7///8AAAAA/v////7///8FAAAA//////3/////////AAAAAAAAAAD+/////v////7///8AAAAAAQAAAP////8AAAAA//////7////9/////v///wAAAAD+/////f////7///8CAAAAAwAAAP////8GAAAAAQAAAP7//////////////wAAAAD/////AQAAAP7/////////AAAAAP7////9/////v////3//////////v////3////9/////v///wAAAAABAAAA/f///wEAAAAHAAAA/f////7////+////AgAAAAMAAAAAAAAA/f////3///////////////////////////////3/////////AAAAAP7////+/////f////3//////////v////3///8JAAAAAAAAAP/////+/////v////7///////////////////8BAAAA/////wEAAAAAAAAA/v///wBB9K4BCzD//////v////3///8AAAAA//////7///8AAAAABAAAAAIAAAD+/////v////////8AQbSvAQtI/////wAAAAD//////v///wAAAAD//////v///////////////v///wAAAAD//////v////////8CAAAABQAAAP//////////AEGMsAELqAT+//////////7////9/////f/////////+/////f////7/////////AAAAAP7///8AAAAAAgAAAP7////+/////////w0AAAADAAAA/v////7////+//////////7///////////////7////+//////////7////9////AQAAAP///////////v////////8DAAAA/v////7/////////AwAAAAkAAAD//////v////7/////////AAAAAP7////+/////f////7////+/////v////3////9////AwAAAAEAAAD+////AQAAAAAAAAD+/////////wAAAAD+/////////wQAAAD9/////v/////////+////AAAAAAQAAAAFAAAA/f///wEAAAABAAAA/////wAAAAD9/////f///wAAAAD+/////f////////8AAAAAAAAAAP7////+/////f///wQAAAABAAAA//////////8BAAAAAAAAAAIAAAD9////AwAAAAQAAAD+////AAAAAP7////+////AQAAAP/////9/////////wAAAAAAAAAA/v////7////+////AQAAAAQAAAD/////AAAAAP////////////////7///8AAAAA////////////////////////////////AAAAAP//////////AAAAAAAAAAD///////////////////////////////8AQcS0AQvdA4DeKACAyE0AAKd2AAA0ngCAEscAgJ/uAAB+FwGAXEABgOlnAQDIkAEAVbgBU3VuAE1vbgBUdWUAV2VkAFRodQBGcmkAU2F0AFN1bmRheQBNb25kYXkAVHVlc2RheQBXZWRuZXNkYXkAVGh1cnNkYXkARnJpZGF5AFNhdHVyZGF5AEphbgBGZWIATWFyAEFwcgBNYXkASnVuAEp1bABBdWcAU2VwAE9jdABOb3YARGVjAEphbnVhcnkARmVicnVhcnkATWFyY2gAQXByaWwATWF5AEp1bmUASnVseQBBdWd1c3QAU2VwdGVtYmVyAE9jdG9iZXIATm92ZW1iZXIARGVjZW1iZXIAQU0AUE0AJWEgJWIgJWUgJVQgJVkAJW0vJWQvJXkAJUg6JU06JVMAJUk6JU06JVMgJXAAAAAlbS8lZC8leQAwMTIzNDU2Nzg5ACVhICViICVlICVUICVZACVIOiVNOiVTAAAAAADRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUZAAsAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkACgoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBBsbgBCyEOAAAAAAAAAAAZAAsNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQeu4AQsBDABB97gBCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQaW5AQsBEABBsbkBCxUPAAAABA8AAAAACRAAAAAAABAAABAAQd+5AQsBEgBB67kBCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQaK6AQsOGgAAABoaGgAAAAAAAAkAQdO6AQsBFABB37oBCxUXAAAAABcAAAAACRQAAAAAABQAABQAQY27AQsBFgBBmbsBC/MBFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzbAEG0vQELAQwAQdy9AQsI//////////8AQaS+AQs5EAAAABAAAAARAAAAEQAAABEAAAARAAAAEQAAABEAAAAQAAAAEAAAABEAAAAQAAAAEAAAABAAAAAQAEGAvwELHREAAAARAAAAEAAAABAAAAAAAAAAEAAAAAAAAAARAEGowAELCaBtAQABAAAABQBBvMABCwELAEHUwAELCgkAAAAIAAAA/GQAQezAAQsBAgBB/MABCwj//////////wBBwMEBCwkwYAAAAAAAAAkAQdTBAQsBCwBB6MEBCxIKAAAAAAAAAAgAAAAIZQAAAAQAQZTCAQsE/////wBB2MIBCwEFAEHkwgELAQ4AQfzCAQsOCQAAAA8AAAAYaQAAAAQAQZTDAQsBAQBBpMMBCwX/////CgBB6MMBCwJYYQD8FwRuYW1lAAwLa2FsaWduLndhc20BkBKjAQAPX193YXNpX2ZkX2Nsb3NlARFfX3N5c2NhbGxfZmNudGw2NAIEZXhpdAMWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAQTZW1zY3JpcHRlbl9kYXRlX25vdwUJX3R6c2V0X2pzBg1fc2V0aXRpbWVyX2pzBw1fbG9jYWx0aW1lX2pzCCNfZW1zY3JpcHRlbl9ydW50aW1lX2tlZXBhbGl2ZV9jbGVhcgkJX2Fib3J0X2pzChBfX3dhc2lfcHJvY19leGl0Cw9fX3dhc2lfZmRfd3JpdGUMDl9fd2FzaV9mZF9zZWVrDQ5fX3dhc2lfZmRfcmVhZA4UX193YXNpX2ZkX2Zkc3RhdF9nZXQPFV9fd2FzaV9jbG9ja190aW1lX2dldBAQX19zeXNjYWxsX3N0YXQ2NBEQX19zeXNjYWxsX29wZW5hdBIPX19zeXNjYWxsX2lvY3RsEwVlcnJvchQXZW1zY3JpcHRlbl9idWlsdGluX2ZyZWUVGWVtc2NyaXB0ZW5fYnVpbHRpbl9tYWxsb2MWB3dhcm5pbmcXCF9fbXVsdGYzGAZmd3JpdGUZGWVtc2NyaXB0ZW5fYnVpbHRpbl9jYWxsb2MaCGZpcHJpbnRmGwZzdHJzdHIcCF9fc2hnZXRjHQNvdXQeA3BhZB8IX19tdWx0aTMgCV9fYXNobHRpMyEaZW1zY3JpcHRlbl9idWlsdGluX3JlYWxsb2MiCF9fYWRkdGYzIwtsb2dfbWVzc2FnZSQLX19mbG9hdHNpdGYlCHNucHJpbnRmJgVmcHV0YycGX190aW1lKAphbG5fcnVubmVyKQ1fX2V4dGVuZGRmdGYyKghfX21lbWNweSsGc3RybGVuLAVjbG9jay0RYWxuX3J1bm5lcl9zZXJpYWwuBnN0cmNoci8ScmVzaXplX2xpbmVfYnVmZmVyMA9rYWxpZ25fZnJlZV9tc2ExBmZmbHVzaDIbZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduMwdfX2xldGYyNAdzdHJubGVuNQRzYnJrNg5yZXNpemVfbXNhX3NlcTcFcXNvcnQ4BWZtdF91OQlfX2xzaHJ0aTM6DV9fZmxvYXR1bnNpdGY7B2lzcHVuY3Q8E19fdmZwcmludGZfaW50ZXJuYWw9DF9fc3RyZnRpbWVfbD4MX19nZXRvcHRfbXNnPwd0cmlua2xlQBR0bF9zdG9wd2F0Y2hfRGlzcGxheUEGc3BsaXQyQgNzaHJDA3NobEQKcmVzaXplX21zYUUFZm9wZW5GBmZjbG9zZUcNZGlzcG9zZV9jaHVua0gJYnBtX2Jsb2NrSQ1fX2xvY2FsdGltZV9ySgh3ZWVrX251bUsGc3RydG9kTARzaWZ0TQZzY2FsYm5ODXJlY3Vyc2l2ZV9hbG5PEXByaW50X2thbGlnbl9oZWxwUAZtZW1jaHJRBm1idG93Y1IObGFiZWxfaW50ZXJuYWxTBmlzYXR0eVQKZnJlZV90YXNrc1UMZnJlZV9tc2Ffc2VxVg5mcmVlX2luX2J1ZmZlclcMZnJlZV9hbG5fbWVtWAZmaWxlbm9ZDGNyZWF0ZV90YXNrc1oXY29udmVydF9tc2FfdG9faW50ZXJuYWxbEGJpc2VjdGluZ19rbWVhbnNcCWFsbG9jX21zYV0JX190b3dyaXRlXghfX3N1YnRmM18IX19tZW1zZXRgCV9fZndyaXRleGEHd2NydG9tYmIJdmZpcHJpbnRmYwp0bGZpbGVuYW1lZAhzaXByaW50ZmUMc2V0X3NpcF9uc2lwZgdzY2FuZXhwZwdzY2FsYm5saAtwcmludGZfY29yZWkHcG9wX2FyZ2oEcG50emsObWFrZV9wcm9maWxlX25sEWthbGlnbl9yZWFkX2lucHV0bQdpc19sZWFwbgZnZXRpbnRvBWZyZXhwcBBmcmVlX2xpbmVfYnVmZmVycQVmbW9kbHIIZG9fdHpzZXRzD2RldGVjdF9hbHBoYWJldHQOZGV0ZWN0X2FsaWduZWR1DGRfZXN0aW1hdGlvbnYFY3ljbGV3CWNvcHlzaWdubHgEYXRvaXkRYWxuX3NlcXNlcV9tZWV0dXB6EWFsbl9zZXFzZXFfZm93YXJkexNhbG5fc2Vxc2VxX2JhY2t3YXJkfBVhbG5fc2VxcHJvZmlsZV9tZWV0dXB9FWFsbl9zZXFwcm9maWxlX2Zvd2FyZH4XYWxuX3NlcXByb2ZpbGVfYmFja3dhcmR/GWFsbl9wcm9maWxlcHJvZmlsZV9tZWV0dXCAARlhbG5fcHJvZmlsZXByb2ZpbGVfZm93YXJkgQEbYWxuX3Byb2ZpbGVwcm9maWxlX2JhY2t3YXJkggEMYWxuX2NvbnRpbnVlgwELYWxsb2NfdGFza3OEAQ1hbGxvY19tc2Ffc2VxhQERYWxsb2NfbGluZV9idWZmZXKGAQVhYm9ydIcBB19fdWZsb3eIAQxfX3RydW5jdGZkZjKJAQpfX292ZXJmbG93igEPX19ubF9sYW5naW5mb19siwEHX19nZXRmMowBCV9fZnN0YXRhdI0BCF9fZGl2dGYzjgEPc29ydF90YXNrc19ieV9jjwEOc29ydF9vdXRfbGluZXOQAQxzb3J0X2J5X3JhbmuRARBzb3J0X2J5X2xlbl9uYW1lkgELc29ydF9ieV9sZW6TAQhzbl93cml0ZZQBE3BvcF9hcmdfbG9uZ19kb3VibGWVAQRtYWlulgEGZm10X2ZwlwEeZGVtYW5nbGluZ190ZXJtaW5hdGVfaGFuZGxlcigpmAEQYWN0aW9uX3Rlcm1pbmF0ZZkBDGFjdGlvbl9hYm9ydJoBE19lbXNjcmlwdGVuX3RpbWVvdXSbARdfZW1zY3JpcHRlbl9zdGFja19hbGxvY5wBEV9fd2FzbV9jYWxsX2N0b3JznQENX19zdGRpb193cml0ZZ4BDF9fc3RkaW9fc2Vla58BDF9fc3RkaW9fcmVhZKABDV9fc3RkaW9fY2xvc2WhARhfX2Vtc2NyaXB0ZW5fc3Rkb3V0X3NlZWuiARlfX2Vtc2NyaXB0ZW5fc3Rkb3V0X2Nsb3NlBxIBAA9fX3N0YWNrX3BvaW50ZXIJvwU/AAcucm9kYXRhAQkucm9kYXRhLjECCS5yb2RhdGEuMgMJLnJvZGF0YS4zBAkucm9kYXRhLjQFCS5yb2RhdGEuNQYJLnJvZGF0YS42Bwkucm9kYXRhLjcICS5yb2RhdGEuOAkJLnJvZGF0YS45Cgoucm9kYXRhLjEwCwoucm9kYXRhLjExDAoucm9kYXRhLjEyDQoucm9kYXRhLjEzDgoucm9kYXRhLjE0Dwoucm9kYXRhLjE1EAoucm9kYXRhLjE2EQoucm9kYXRhLjE3Egoucm9kYXRhLjE4Ewoucm9kYXRhLjE5FAoucm9kYXRhLjIwFQoucm9kYXRhLjIxFgoucm9kYXRhLjIyFwoucm9kYXRhLjIzGAoucm9kYXRhLjI0GQoucm9kYXRhLjI1Ggoucm9kYXRhLjI2Gwoucm9kYXRhLjI3HAoucm9kYXRhLjI4HQoucm9kYXRhLjI5Hgoucm9kYXRhLjMwHwoucm9kYXRhLjMxIAoucm9kYXRhLjMyIQoucm9kYXRhLjMzIgoucm9kYXRhLjM0Iwoucm9kYXRhLjM1JAoucm9kYXRhLjM2JQoucm9kYXRhLjM3Jgoucm9kYXRhLjM4Jwoucm9kYXRhLjM5KAoucm9kYXRhLjQwKQoucm9kYXRhLjQxKgoucm9kYXRhLjQyKwoucm9kYXRhLjQzLAoucm9kYXRhLjQ0LQoucm9kYXRhLjQ1Lgoucm9kYXRhLjQ2Lwoucm9kYXRhLjQ3MAUuZGF0YTEHLmRhdGEuMTIHLmRhdGEuMjMHLmRhdGEuMzQHLmRhdGEuNDUHLmRhdGEuNTYHLmRhdGEuNjcHLmRhdGEuNzgHLmRhdGEuODkHLmRhdGEuOToILmRhdGEuMTA7CC5kYXRhLjExPAguZGF0YS4xMj0ILmRhdGEuMTM+CC5kYXRhLjE0");
}

function getBinarySync(file) {
  if (ArrayBuffer.isView(file)) {
    return file;
  }
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw "both async and sync fetching of the wasm failed";
}

async function getWasmBinary(binaryFile) {
  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);
    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    "a": wasmImports
  };
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {
    wasmExports = instance.exports;
    wasmMemory = wasmExports["t"];
    updateMemoryViews();
    assignWasmExports(wasmExports);
    removeRunDependency("wasm-instantiate");
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency("wasm-instantiate");
  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    return receiveInstance(result["instance"]);
  }
  var info = getWasmImports();
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module["instantiateWasm"]) {
    return new Promise((resolve, reject) => {
      Module["instantiateWasm"](info, (mod, inst) => {
        resolve(receiveInstance(mod, inst));
      });
    });
  }
  wasmBinaryFile ??= findWasmBinary();
  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
  var exports = receiveInstantiationResult(result);
  return exports;
}

// end include: preamble.js
// Begin JS library code
class ExitStatus {
  name="ExitStatus";
  constructor(status) {
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
}

var callRuntimeCallbacks = callbacks => {
  while (callbacks.length > 0) {
    // Pass the module as the first argument.
    callbacks.shift()(Module);
  }
};

var onPostRuns = [];

var addOnPostRun = cb => onPostRuns.push(cb);

var onPreRuns = [];

var addOnPreRun = cb => onPreRuns.push(cb);

/** @noinline */ var base64Decode = b64 => {
  var b1, b2, i = 0, j = 0, bLength = b64.length;
  var output = new Uint8Array((bLength * 3 >> 2) - (b64[bLength - 2] == "=") - (b64[bLength - 1] == "="));
  for (;i < bLength; i += 4, j += 3) {
    b1 = base64ReverseLookup[b64.charCodeAt(i + 1)];
    b2 = base64ReverseLookup[b64.charCodeAt(i + 2)];
    output[j] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
    output[j + 1] = b1 << 4 | b2 >> 2;
    output[j + 2] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i + 3)];
  }
  return output;
};

var noExitRuntime = true;

/** @suppress {duplicate } */ var syscallGetVarargI = () => {
  // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.
  var ret = HEAP32[((+SYSCALLS.varargs) >> 2)];
  SYSCALLS.varargs += 4;
  return ret;
};

var syscallGetVarargP = syscallGetVarargI;

var PATH = {
  isAbs: path => path.charAt(0) === "/",
  splitPath: filename => {
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
    return splitPathRe.exec(filename).slice(1);
  },
  normalizeArray: (parts, allowAboveRoot) => {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === ".") {
        parts.splice(i, 1);
      } else if (last === "..") {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
      for (;up; up--) {
        parts.unshift("..");
      }
    }
    return parts;
  },
  normalize: path => {
    var isAbsolute = PATH.isAbs(path), trailingSlash = path.slice(-1) === "/";
    // Normalize the path
    path = PATH.normalizeArray(path.split("/").filter(p => !!p), !isAbsolute).join("/");
    if (!path && !isAbsolute) {
      path = ".";
    }
    if (path && trailingSlash) {
      path += "/";
    }
    return (isAbsolute ? "/" : "") + path;
  },
  dirname: path => {
    var result = PATH.splitPath(path), root = result[0], dir = result[1];
    if (!root && !dir) {
      // No dirname whatsoever
      return ".";
    }
    if (dir) {
      // It has a dirname, strip trailing slash
      dir = dir.slice(0, -1);
    }
    return root + dir;
  },
  basename: path => path && path.match(/([^/]+|\/)\/*$/)[1],
  join: (...paths) => PATH.normalize(paths.join("/")),
  join2: (l, r) => PATH.normalize(l + "/" + r)
};

var initRandomFill = () => view => crypto.getRandomValues(view);

var randomFill = view => {
  // Lazily init on the first invocation.
  (randomFill = initRandomFill())(view);
};

var PATH_FS = {
  resolve: (...args) => {
    var resolvedPath = "", resolvedAbsolute = false;
    for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? args[i] : FS.cwd();
      // Skip empty and invalid entries
      if (typeof path != "string") {
        throw new TypeError("Arguments to path.resolve must be strings");
      } else if (!path) {
        return "";
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = PATH.isAbs(path);
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(p => !!p), !resolvedAbsolute).join("/");
    return ((resolvedAbsolute ? "/" : "") + resolvedPath) || ".";
  },
  relative: (from, to) => {
    from = PATH_FS.resolve(from).slice(1);
    to = PATH_FS.resolve(to).slice(1);
    function trim(arr) {
      var start = 0;
      for (;start < arr.length; start++) {
        if (arr[start] !== "") break;
      }
      var end = arr.length - 1;
      for (;end >= 0; end--) {
        if (arr[end] !== "") break;
      }
      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim(from.split("/"));
    var toParts = trim(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
};

var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder : undefined;

var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {
  var maxIdx = idx + maxBytesToRead;
  if (ignoreNul) return maxIdx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on
  // null terminator by itself.
  // As a tiny code save trick, compare idx against maxIdx using a negation,
  // so that maxBytesToRead=undefined/NaN means Infinity.
  while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;
  return idx;
};

/**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */ var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {
  var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);
  // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  }
  var str = "";
  while (idx < endPtr) {
    // For UTF8 byte structure, see:
    // http://en.wikipedia.org/wiki/UTF-8#Description
    // https://www.ietf.org/rfc/rfc2279.txt
    // https://tools.ietf.org/html/rfc3629
    var u0 = heapOrArray[idx++];
    if (!(u0 & 128)) {
      str += String.fromCharCode(u0);
      continue;
    }
    var u1 = heapOrArray[idx++] & 63;
    if ((u0 & 224) == 192) {
      str += String.fromCharCode(((u0 & 31) << 6) | u1);
      continue;
    }
    var u2 = heapOrArray[idx++] & 63;
    if ((u0 & 240) == 224) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
    }
    if (u0 < 65536) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 65536;
      str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
    }
  }
  return str;
};

var FS_stdin_getChar_buffer = [];

var lengthBytesUTF8 = str => {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
    // unit, not a Unicode code point of the character! So decode
    // UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var c = str.charCodeAt(i);
    // possibly a lead surrogate
    if (c <= 127) {
      len++;
    } else if (c <= 2047) {
      len += 2;
    } else if (c >= 55296 && c <= 57343) {
      len += 4;
      ++i;
    } else {
      len += 3;
    }
  }
  return len;
};

var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
  // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
  // undefined and false each don't write out any bytes.
  if (!(maxBytesToWrite > 0)) return 0;
  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1;
  // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
    // and https://www.ietf.org/rfc/rfc2279.txt
    // and https://tools.ietf.org/html/rfc3629
    var u = str.codePointAt(i);
    if (u <= 127) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 2047) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 192 | (u >> 6);
      heap[outIdx++] = 128 | (u & 63);
    } else if (u <= 65535) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 224 | (u >> 12);
      heap[outIdx++] = 128 | ((u >> 6) & 63);
      heap[outIdx++] = 128 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 240 | (u >> 18);
      heap[outIdx++] = 128 | ((u >> 12) & 63);
      heap[outIdx++] = 128 | ((u >> 6) & 63);
      heap[outIdx++] = 128 | (u & 63);
      // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
      // We need to manually skip over the second code unit for correct iteration.
      i++;
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
};

/** @type {function(string, boolean=, number=)} */ var intArrayFromString = (stringy, dontAddNull, length) => {
  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
};

var FS_stdin_getChar = () => {
  if (!FS_stdin_getChar_buffer.length) {
    var result = null;
    if (typeof window != "undefined" && typeof window.prompt == "function") {
      // Browser.
      result = window.prompt("Input: ");
      // returns null on cancel
      if (result !== null) {
        result += "\n";
      }
    } else {}
    if (!result) {
      return null;
    }
    FS_stdin_getChar_buffer = intArrayFromString(result, true);
  }
  return FS_stdin_getChar_buffer.shift();
};

var TTY = {
  ttys: [],
  init() {},
  shutdown() {},
  register(dev, ops) {
    TTY.ttys[dev] = {
      input: [],
      output: [],
      ops
    };
    FS.registerDevice(dev, TTY.stream_ops);
  },
  stream_ops: {
    open(stream) {
      var tty = TTY.ttys[stream.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream.tty = tty;
      stream.seekable = false;
    },
    close(stream) {
      // flush any pending line data
      stream.tty.ops.fsync(stream.tty);
    },
    fsync(stream) {
      stream.tty.ops.fsync(stream.tty);
    },
    read(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length; i++) {
        var result;
        try {
          result = stream.tty.ops.get_char(stream.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === undefined && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === undefined) break;
        bytesRead++;
        buffer[offset + i] = result;
      }
      if (bytesRead) {
        stream.node.atime = Date.now();
      }
      return bytesRead;
    },
    write(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length; i++) {
          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length) {
        stream.node.mtime = stream.node.ctime = Date.now();
      }
      return i;
    }
  },
  default_tty_ops: {
    get_char(tty) {
      return FS_stdin_getChar();
    },
    put_char(tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    },
    fsync(tty) {
      if (tty.output?.length > 0) {
        out(UTF8ArrayToString(tty.output));
        tty.output = [];
      }
    },
    ioctl_tcgets(tty) {
      // typical setting
      return {
        c_iflag: 25856,
        c_oflag: 5,
        c_cflag: 191,
        c_lflag: 35387,
        c_cc: [ 3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
      };
    },
    ioctl_tcsets(tty, optional_actions, data) {
      // currently just ignore
      return 0;
    },
    ioctl_tiocgwinsz(tty) {
      return [ 24, 80 ];
    }
  },
  default_tty1_ops: {
    put_char(tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    },
    fsync(tty) {
      if (tty.output?.length > 0) {
        err(UTF8ArrayToString(tty.output));
        tty.output = [];
      }
    }
  }
};

var mmapAlloc = size => {
  abort();
};

var MEMFS = {
  ops_table: null,
  mount(mount) {
    return MEMFS.createNode(null, "/", 16895, 0);
  },
  createNode(parent, name, mode, dev) {
    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
      // no supported
      throw new FS.ErrnoError(63);
    }
    MEMFS.ops_table ||= {
      dir: {
        node: {
          getattr: MEMFS.node_ops.getattr,
          setattr: MEMFS.node_ops.setattr,
          lookup: MEMFS.node_ops.lookup,
          mknod: MEMFS.node_ops.mknod,
          rename: MEMFS.node_ops.rename,
          unlink: MEMFS.node_ops.unlink,
          rmdir: MEMFS.node_ops.rmdir,
          readdir: MEMFS.node_ops.readdir,
          symlink: MEMFS.node_ops.symlink
        },
        stream: {
          llseek: MEMFS.stream_ops.llseek
        }
      },
      file: {
        node: {
          getattr: MEMFS.node_ops.getattr,
          setattr: MEMFS.node_ops.setattr
        },
        stream: {
          llseek: MEMFS.stream_ops.llseek,
          read: MEMFS.stream_ops.read,
          write: MEMFS.stream_ops.write,
          mmap: MEMFS.stream_ops.mmap,
          msync: MEMFS.stream_ops.msync
        }
      },
      link: {
        node: {
          getattr: MEMFS.node_ops.getattr,
          setattr: MEMFS.node_ops.setattr,
          readlink: MEMFS.node_ops.readlink
        },
        stream: {}
      },
      chrdev: {
        node: {
          getattr: MEMFS.node_ops.getattr,
          setattr: MEMFS.node_ops.setattr
        },
        stream: FS.chrdev_stream_ops
      }
    };
    var node = FS.createNode(parent, name, mode, dev);
    if (FS.isDir(node.mode)) {
      node.node_ops = MEMFS.ops_table.dir.node;
      node.stream_ops = MEMFS.ops_table.dir.stream;
      node.contents = {};
    } else if (FS.isFile(node.mode)) {
      node.node_ops = MEMFS.ops_table.file.node;
      node.stream_ops = MEMFS.ops_table.file.stream;
      node.usedBytes = 0;
      // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
      // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
      // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
      // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
      node.contents = null;
    } else if (FS.isLink(node.mode)) {
      node.node_ops = MEMFS.ops_table.link.node;
      node.stream_ops = MEMFS.ops_table.link.stream;
    } else if (FS.isChrdev(node.mode)) {
      node.node_ops = MEMFS.ops_table.chrdev.node;
      node.stream_ops = MEMFS.ops_table.chrdev.stream;
    }
    node.atime = node.mtime = node.ctime = Date.now();
    // add the new node to the parent
    if (parent) {
      parent.contents[name] = node;
      parent.atime = parent.mtime = parent.ctime = node.atime;
    }
    return node;
  },
  getFileDataAsTypedArray(node) {
    if (!node.contents) return new Uint8Array(0);
    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
    // Make sure to not return excess unused bytes.
    return new Uint8Array(node.contents);
  },
  expandFileStorage(node, newCapacity) {
    var prevCapacity = node.contents ? node.contents.length : 0;
    if (prevCapacity >= newCapacity) return;
    // No need to expand, the storage was already large enough.
    // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
    // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
    // avoid overshooting the allocation cap by a very large margin.
    var CAPACITY_DOUBLING_MAX = 1024 * 1024;
    newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0);
    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
    // At minimum allocate 256b for each file when expanding.
    var oldContents = node.contents;
    node.contents = new Uint8Array(newCapacity);
    // Allocate new storage.
    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
  },
  resizeFileStorage(node, newSize) {
    if (node.usedBytes == newSize) return;
    if (newSize == 0) {
      node.contents = null;
      // Fully decommit when requesting a resize to zero.
      node.usedBytes = 0;
    } else {
      var oldContents = node.contents;
      node.contents = new Uint8Array(newSize);
      // Allocate new storage.
      if (oldContents) {
        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
      }
      node.usedBytes = newSize;
    }
  },
  node_ops: {
    getattr(node) {
      var attr = {};
      // device numbers reuse inode numbers.
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.atime);
      attr.mtime = new Date(node.mtime);
      attr.ctime = new Date(node.ctime);
      // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
      //       but this is not required by the standard.
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    },
    setattr(node, attr) {
      for (const key of [ "mode", "atime", "mtime", "ctime" ]) {
        if (attr[key] != null) {
          node[key] = attr[key];
        }
      }
      if (attr.size !== undefined) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    },
    lookup(parent, name) {
      // This error may happen quite a bit. To avoid overhead we reuse it (and
      // suffer a lack of stack info).
      if (!MEMFS.doesNotExistError) {
        MEMFS.doesNotExistError = new FS.ErrnoError(44);
        /** @suppress {checkTypes} */ MEMFS.doesNotExistError.stack = "<generic error, no stack>";
      }
      throw MEMFS.doesNotExistError;
    },
    mknod(parent, name, mode, dev) {
      return MEMFS.createNode(parent, name, mode, dev);
    },
    rename(old_node, new_dir, new_name) {
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {}
      if (new_node) {
        if (FS.isDir(old_node.mode)) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
        FS.hashRemoveNode(new_node);
      }
      // do the internal rewiring
      delete old_node.parent.contents[old_node.name];
      new_dir.contents[new_name] = old_node;
      old_node.name = new_name;
      new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
    },
    unlink(parent, name) {
      delete parent.contents[name];
      parent.ctime = parent.mtime = Date.now();
    },
    rmdir(parent, name) {
      var node = FS.lookupNode(parent, name);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name];
      parent.ctime = parent.mtime = Date.now();
    },
    readdir(node) {
      return [ ".", "..", ...Object.keys(node.contents) ];
    },
    symlink(parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
      node.link = oldpath;
      return node;
    },
    readlink(node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    }
  },
  stream_ops: {
    read(stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= stream.node.usedBytes) return 0;
      var size = Math.min(stream.node.usedBytes - position, length);
      if (size > 8 && contents.subarray) {
        // non-trivial, and typed array
        buffer.set(contents.subarray(position, position + size), offset);
      } else {
        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
      }
      return size;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      // If the buffer is located in main memory (HEAP), and if
      // memory can grow, we can't hold on to references of the
      // memory buffer, as they may get invalidated. That means we
      // need to do copy its contents.
      if (buffer.buffer === HEAP8.buffer) {
        canOwn = false;
      }
      if (!length) return 0;
      var node = stream.node;
      node.mtime = node.ctime = Date.now();
      if (buffer.subarray && (!node.contents || node.contents.subarray)) {
        // This write is from a typed array to a typed array?
        if (canOwn) {
          node.contents = buffer.subarray(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (node.usedBytes === 0 && position === 0) {
          // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
          node.contents = buffer.slice(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (position + length <= node.usedBytes) {
          // Writing to an already allocated and used subrange of the file?
          node.contents.set(buffer.subarray(offset, offset + length), position);
          return length;
        }
      }
      // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
      MEMFS.expandFileStorage(node, position + length);
      if (node.contents.subarray && buffer.subarray) {
        // Use typed array write which is available.
        node.contents.set(buffer.subarray(offset, offset + length), position);
      } else {
        for (var i = 0; i < length; i++) {
          node.contents[position + i] = buffer[offset + i];
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position + length);
      return length;
    },
    llseek(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          position += stream.node.usedBytes;
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    },
    mmap(stream, length, position, prot, flags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream.node.contents;
      // Only make a new copy when MAP_PRIVATE is specified.
      if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
        // We can't emulate MAP_SHARED when the file is not backed by the
        // buffer we're mapping to (e.g. the HEAP buffer).
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        allocated = true;
        ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        if (contents) {
          // Try to avoid unnecessary slices.
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          HEAP8.set(contents, ptr);
        }
      }
      return {
        ptr,
        allocated
      };
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
      // should we check if bytesWritten and length are the same?
      return 0;
    }
  }
};

var FS_modeStringToFlags = str => {
  var flagModes = {
    "r": 0,
    "r+": 2,
    "w": 512 | 64 | 1,
    "w+": 512 | 64 | 2,
    "a": 1024 | 64 | 1,
    "a+": 1024 | 64 | 2
  };
  var flags = flagModes[str];
  if (typeof flags == "undefined") {
    throw new Error(`Unknown file open mode: ${str}`);
  }
  return flags;
};

var FS_getMode = (canRead, canWrite) => {
  var mode = 0;
  if (canRead) mode |= 292 | 73;
  if (canWrite) mode |= 146;
  return mode;
};

var asyncLoad = async url => {
  var arrayBuffer = await readAsync(url);
  return new Uint8Array(arrayBuffer);
};

var FS_createDataFile = (...args) => FS.createDataFile(...args);

var getUniqueRunDependency = id => id;

var preloadPlugins = [];

var FS_handledByPreloadPlugin = async (byteArray, fullname) => {
  // Ensure plugins are ready.
  if (typeof Browser != "undefined") Browser.init();
  for (var plugin of preloadPlugins) {
    if (plugin["canHandle"](fullname)) {
      return plugin["handle"](byteArray, fullname);
    }
  }
  // In no plugin handled this file then return the original/unmodified
  // byteArray.
  return byteArray;
};

var FS_preloadFile = async (parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish) => {
  // TODO we should allow people to just pass in a complete filename instead
  // of parent and name being that we just join them anyways
  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
  var dep = getUniqueRunDependency(`cp ${fullname}`);
  // might have several active requests for the same fullname
  addRunDependency(dep);
  try {
    var byteArray = url;
    if (typeof url == "string") {
      byteArray = await asyncLoad(url);
    }
    byteArray = await FS_handledByPreloadPlugin(byteArray, fullname);
    preFinish?.();
    if (!dontCreateFile) {
      FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
    }
  } finally {
    removeRunDependency(dep);
  }
};

var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
  FS_preloadFile(parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish).then(onload).catch(onerror);
};

var FS = {
  root: null,
  mounts: [],
  devices: {},
  streams: [],
  nextInode: 1,
  nameTable: null,
  currentPath: "/",
  initialized: false,
  ignorePermissions: true,
  filesystems: null,
  syncFSRequests: 0,
  readFiles: {},
  ErrnoError: class {
    name="ErrnoError";
    // We set the `name` property to be able to identify `FS.ErrnoError`
    // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
    // - when using PROXYFS, an error can come from an underlying FS
    // as different FS objects have their own FS.ErrnoError each,
    // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
    // we'll use the reliable test `err.name == "ErrnoError"` instead
    constructor(errno) {
      this.errno = errno;
    }
  },
  FSStream: class {
    shared={};
    get object() {
      return this.node;
    }
    set object(val) {
      this.node = val;
    }
    get isRead() {
      return (this.flags & 2097155) !== 1;
    }
    get isWrite() {
      return (this.flags & 2097155) !== 0;
    }
    get isAppend() {
      return (this.flags & 1024);
    }
    get flags() {
      return this.shared.flags;
    }
    set flags(val) {
      this.shared.flags = val;
    }
    get position() {
      return this.shared.position;
    }
    set position(val) {
      this.shared.position = val;
    }
  },
  FSNode: class {
    node_ops={};
    stream_ops={};
    readMode=292 | 73;
    writeMode=146;
    mounted=null;
    constructor(parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.rdev = rdev;
      this.atime = this.mtime = this.ctime = Date.now();
    }
    get read() {
      return (this.mode & this.readMode) === this.readMode;
    }
    set read(val) {
      val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
    }
    get write() {
      return (this.mode & this.writeMode) === this.writeMode;
    }
    set write(val) {
      val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
    }
    get isFolder() {
      return FS.isDir(this.mode);
    }
    get isDevice() {
      return FS.isChrdev(this.mode);
    }
  },
  lookupPath(path, opts = {}) {
    if (!path) {
      throw new FS.ErrnoError(44);
    }
    opts.follow_mount ??= true;
    if (!PATH.isAbs(path)) {
      path = FS.cwd() + "/" + path;
    }
    // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
    linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {
      // split the absolute path
      var parts = path.split("/").filter(p => !!p);
      // start at the root
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = (i === parts.length - 1);
        if (islast && opts.parent) {
          // stop resolving
          break;
        }
        if (parts[i] === ".") {
          continue;
        }
        if (parts[i] === "..") {
          current_path = PATH.dirname(current_path);
          if (FS.isRoot(current)) {
            path = current_path + "/" + parts.slice(i + 1).join("/");
            // We're making progress here, don't let many consecutive ..'s
            // lead to ELOOP
            nlinks--;
            continue linkloop;
          } else {
            current = current.parent;
          }
          continue;
        }
        current_path = PATH.join2(current_path, parts[i]);
        try {
          current = FS.lookupNode(current, parts[i]);
        } catch (e) {
          // if noent_okay is true, suppress a ENOENT in the last component
          // and return an object with an undefined node. This is needed for
          // resolving symlinks in the path when creating a file.
          if ((e?.errno === 44) && islast && opts.noent_okay) {
            return {
              path: current_path
            };
          }
          throw e;
        }
        // jump to the mount's root node if this is a mountpoint
        if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
          current = current.mounted.root;
        }
        // by default, lookupPath will not follow a symlink if it is the final path component.
        // setting opts.follow = true will override this behavior.
        if (FS.isLink(current.mode) && (!islast || opts.follow)) {
          if (!current.node_ops.readlink) {
            throw new FS.ErrnoError(52);
          }
          var link = current.node_ops.readlink(current);
          if (!PATH.isAbs(link)) {
            link = PATH.dirname(current_path) + "/" + link;
          }
          path = link + "/" + parts.slice(i + 1).join("/");
          continue linkloop;
        }
      }
      return {
        path: current_path,
        node: current
      };
    }
    throw new FS.ErrnoError(32);
  },
  getPath(node) {
    var path;
    while (true) {
      if (FS.isRoot(node)) {
        var mount = node.mount.mountpoint;
        if (!path) return mount;
        return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
      }
      path = path ? `${node.name}/${path}` : node.name;
      node = node.parent;
    }
  },
  hashName(parentid, name) {
    var hash = 0;
    for (var i = 0; i < name.length; i++) {
      hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
    }
    return ((parentid + hash) >>> 0) % FS.nameTable.length;
  },
  hashAddNode(node) {
    var hash = FS.hashName(node.parent.id, node.name);
    node.name_next = FS.nameTable[hash];
    FS.nameTable[hash] = node;
  },
  hashRemoveNode(node) {
    var hash = FS.hashName(node.parent.id, node.name);
    if (FS.nameTable[hash] === node) {
      FS.nameTable[hash] = node.name_next;
    } else {
      var current = FS.nameTable[hash];
      while (current) {
        if (current.name_next === node) {
          current.name_next = node.name_next;
          break;
        }
        current = current.name_next;
      }
    }
  },
  lookupNode(parent, name) {
    var errCode = FS.mayLookup(parent);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    var hash = FS.hashName(parent.id, name);
    for (var node = FS.nameTable[hash]; node; node = node.name_next) {
      var nodeName = node.name;
      if (node.parent.id === parent.id && nodeName === name) {
        return node;
      }
    }
    // if we failed to find it in the cache, call into the VFS
    return FS.lookup(parent, name);
  },
  createNode(parent, name, mode, rdev) {
    var node = new FS.FSNode(parent, name, mode, rdev);
    FS.hashAddNode(node);
    return node;
  },
  destroyNode(node) {
    FS.hashRemoveNode(node);
  },
  isRoot(node) {
    return node === node.parent;
  },
  isMountpoint(node) {
    return !!node.mounted;
  },
  isFile(mode) {
    return (mode & 61440) === 32768;
  },
  isDir(mode) {
    return (mode & 61440) === 16384;
  },
  isLink(mode) {
    return (mode & 61440) === 40960;
  },
  isChrdev(mode) {
    return (mode & 61440) === 8192;
  },
  isBlkdev(mode) {
    return (mode & 61440) === 24576;
  },
  isFIFO(mode) {
    return (mode & 61440) === 4096;
  },
  isSocket(mode) {
    return (mode & 49152) === 49152;
  },
  flagsToPermissionString(flag) {
    var perms = [ "r", "w", "rw" ][flag & 3];
    if ((flag & 512)) {
      perms += "w";
    }
    return perms;
  },
  nodePermissions(node, perms) {
    if (FS.ignorePermissions) {
      return 0;
    }
    // return 0 if any user, group or owner bits are set.
    if (perms.includes("r") && !(node.mode & 292)) {
      return 2;
    } else if (perms.includes("w") && !(node.mode & 146)) {
      return 2;
    } else if (perms.includes("x") && !(node.mode & 73)) {
      return 2;
    }
    return 0;
  },
  mayLookup(dir) {
    if (!FS.isDir(dir.mode)) return 54;
    var errCode = FS.nodePermissions(dir, "x");
    if (errCode) return errCode;
    if (!dir.node_ops.lookup) return 2;
    return 0;
  },
  mayCreate(dir, name) {
    if (!FS.isDir(dir.mode)) {
      return 54;
    }
    try {
      var node = FS.lookupNode(dir, name);
      return 20;
    } catch (e) {}
    return FS.nodePermissions(dir, "wx");
  },
  mayDelete(dir, name, isdir) {
    var node;
    try {
      node = FS.lookupNode(dir, name);
    } catch (e) {
      return e.errno;
    }
    var errCode = FS.nodePermissions(dir, "wx");
    if (errCode) {
      return errCode;
    }
    if (isdir) {
      if (!FS.isDir(node.mode)) {
        return 54;
      }
      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
        return 10;
      }
    } else {
      if (FS.isDir(node.mode)) {
        return 31;
      }
    }
    return 0;
  },
  mayOpen(node, flags) {
    if (!node) {
      return 44;
    }
    if (FS.isLink(node.mode)) {
      return 32;
    } else if (FS.isDir(node.mode)) {
      if (FS.flagsToPermissionString(flags) !== "r" || (flags & (512 | 64))) {
        // TODO: check for O_SEARCH? (== search for dir only)
        return 31;
      }
    }
    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
  },
  checkOpExists(op, err) {
    if (!op) {
      throw new FS.ErrnoError(err);
    }
    return op;
  },
  MAX_OPEN_FDS: 4096,
  nextfd() {
    for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
      if (!FS.streams[fd]) {
        return fd;
      }
    }
    throw new FS.ErrnoError(33);
  },
  getStreamChecked(fd) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    return stream;
  },
  getStream: fd => FS.streams[fd],
  createStream(stream, fd = -1) {
    // clone it, so we can return an instance of FSStream
    stream = Object.assign(new FS.FSStream, stream);
    if (fd == -1) {
      fd = FS.nextfd();
    }
    stream.fd = fd;
    FS.streams[fd] = stream;
    return stream;
  },
  closeStream(fd) {
    FS.streams[fd] = null;
  },
  dupStream(origStream, fd = -1) {
    var stream = FS.createStream(origStream, fd);
    stream.stream_ops?.dup?.(stream);
    return stream;
  },
  doSetAttr(stream, node, attr) {
    var setattr = stream?.stream_ops.setattr;
    var arg = setattr ? stream : node;
    setattr ??= node.node_ops.setattr;
    FS.checkOpExists(setattr, 63);
    setattr(arg, attr);
  },
  chrdev_stream_ops: {
    open(stream) {
      var device = FS.getDevice(stream.node.rdev);
      // override node's stream ops with the device's
      stream.stream_ops = device.stream_ops;
      // forward the open call
      stream.stream_ops.open?.(stream);
    },
    llseek() {
      throw new FS.ErrnoError(70);
    }
  },
  major: dev => ((dev) >> 8),
  minor: dev => ((dev) & 255),
  makedev: (ma, mi) => ((ma) << 8 | (mi)),
  registerDevice(dev, ops) {
    FS.devices[dev] = {
      stream_ops: ops
    };
  },
  getDevice: dev => FS.devices[dev],
  getMounts(mount) {
    var mounts = [];
    var check = [ mount ];
    while (check.length) {
      var m = check.pop();
      mounts.push(m);
      check.push(...m.mounts);
    }
    return mounts;
  },
  syncfs(populate, callback) {
    if (typeof populate == "function") {
      callback = populate;
      populate = false;
    }
    FS.syncFSRequests++;
    if (FS.syncFSRequests > 1) {
      err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
    }
    var mounts = FS.getMounts(FS.root.mount);
    var completed = 0;
    function doCallback(errCode) {
      FS.syncFSRequests--;
      return callback(errCode);
    }
    function done(errCode) {
      if (errCode) {
        if (!done.errored) {
          done.errored = true;
          return doCallback(errCode);
        }
        return;
      }
      if (++completed >= mounts.length) {
        doCallback(null);
      }
    }
    // sync all mounts
    mounts.forEach(mount => {
      if (!mount.type.syncfs) {
        return done(null);
      }
      mount.type.syncfs(mount, populate, done);
    });
  },
  mount(type, opts, mountpoint) {
    var root = mountpoint === "/";
    var pseudo = !mountpoint;
    var node;
    if (root && FS.root) {
      throw new FS.ErrnoError(10);
    } else if (!root && !pseudo) {
      var lookup = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      mountpoint = lookup.path;
      // use the absolute path
      node = lookup.node;
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      if (!FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
    }
    var mount = {
      type,
      opts,
      mountpoint,
      mounts: []
    };
    // create a root node for the fs
    var mountRoot = type.mount(mount);
    mountRoot.mount = mount;
    mount.root = mountRoot;
    if (root) {
      FS.root = mountRoot;
    } else if (node) {
      // set as a mountpoint
      node.mounted = mount;
      // add the new mount to the current mount's children
      if (node.mount) {
        node.mount.mounts.push(mount);
      }
    }
    return mountRoot;
  },
  unmount(mountpoint) {
    var lookup = FS.lookupPath(mountpoint, {
      follow_mount: false
    });
    if (!FS.isMountpoint(lookup.node)) {
      throw new FS.ErrnoError(28);
    }
    // destroy the nodes for this mount, and all its child mounts
    var node = lookup.node;
    var mount = node.mounted;
    var mounts = FS.getMounts(mount);
    Object.keys(FS.nameTable).forEach(hash => {
      var current = FS.nameTable[hash];
      while (current) {
        var next = current.name_next;
        if (mounts.includes(current.mount)) {
          FS.destroyNode(current);
        }
        current = next;
      }
    });
    // no longer a mountpoint
    node.mounted = null;
    // remove this mount from the child mounts
    var idx = node.mount.mounts.indexOf(mount);
    node.mount.mounts.splice(idx, 1);
  },
  lookup(parent, name) {
    return parent.node_ops.lookup(parent, name);
  },
  mknod(path, mode, dev) {
    var lookup = FS.lookupPath(path, {
      parent: true
    });
    var parent = lookup.node;
    var name = PATH.basename(path);
    if (!name) {
      throw new FS.ErrnoError(28);
    }
    if (name === "." || name === "..") {
      throw new FS.ErrnoError(20);
    }
    var errCode = FS.mayCreate(parent, name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.mknod) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.mknod(parent, name, mode, dev);
  },
  statfs(path) {
    return FS.statfsNode(FS.lookupPath(path, {
      follow: true
    }).node);
  },
  statfsStream(stream) {
    // We keep a separate statfsStream function because noderawfs overrides
    // it. In noderawfs, stream.node is sometimes null. Instead, we need to
    // look at stream.path.
    return FS.statfsNode(stream.node);
  },
  statfsNode(node) {
    // NOTE: None of the defaults here are true. We're just returning safe and
    //       sane values. Currently nodefs and rawfs replace these defaults,
    //       other file systems leave them alone.
    var rtn = {
      bsize: 4096,
      frsize: 4096,
      blocks: 1e6,
      bfree: 5e5,
      bavail: 5e5,
      files: FS.nextInode,
      ffree: FS.nextInode - 1,
      fsid: 42,
      flags: 2,
      namelen: 255
    };
    if (node.node_ops.statfs) {
      Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
    }
    return rtn;
  },
  create(path, mode = 438) {
    mode &= 4095;
    mode |= 32768;
    return FS.mknod(path, mode, 0);
  },
  mkdir(path, mode = 511) {
    mode &= 511 | 512;
    mode |= 16384;
    return FS.mknod(path, mode, 0);
  },
  mkdirTree(path, mode) {
    var dirs = path.split("/");
    var d = "";
    for (var dir of dirs) {
      if (!dir) continue;
      if (d || PATH.isAbs(path)) d += "/";
      d += dir;
      try {
        FS.mkdir(d, mode);
      } catch (e) {
        if (e.errno != 20) throw e;
      }
    }
  },
  mkdev(path, mode, dev) {
    if (typeof dev == "undefined") {
      dev = mode;
      mode = 438;
    }
    mode |= 8192;
    return FS.mknod(path, mode, dev);
  },
  symlink(oldpath, newpath) {
    if (!PATH_FS.resolve(oldpath)) {
      throw new FS.ErrnoError(44);
    }
    var lookup = FS.lookupPath(newpath, {
      parent: true
    });
    var parent = lookup.node;
    if (!parent) {
      throw new FS.ErrnoError(44);
    }
    var newname = PATH.basename(newpath);
    var errCode = FS.mayCreate(parent, newname);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.symlink) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.symlink(parent, newname, oldpath);
  },
  rename(old_path, new_path) {
    var old_dirname = PATH.dirname(old_path);
    var new_dirname = PATH.dirname(new_path);
    var old_name = PATH.basename(old_path);
    var new_name = PATH.basename(new_path);
    // parents must exist
    var lookup, old_dir, new_dir;
    // let the errors from non existent directories percolate up
    lookup = FS.lookupPath(old_path, {
      parent: true
    });
    old_dir = lookup.node;
    lookup = FS.lookupPath(new_path, {
      parent: true
    });
    new_dir = lookup.node;
    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
    // need to be part of the same mount
    if (old_dir.mount !== new_dir.mount) {
      throw new FS.ErrnoError(75);
    }
    // source must exist
    var old_node = FS.lookupNode(old_dir, old_name);
    // old path should not be an ancestor of the new path
    var relative = PATH_FS.relative(old_path, new_dirname);
    if (relative.charAt(0) !== ".") {
      throw new FS.ErrnoError(28);
    }
    // new path should not be an ancestor of the old path
    relative = PATH_FS.relative(new_path, old_dirname);
    if (relative.charAt(0) !== ".") {
      throw new FS.ErrnoError(55);
    }
    // see if the new path already exists
    var new_node;
    try {
      new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    // early out if nothing needs to change
    if (old_node === new_node) {
      return;
    }
    // we'll need to delete the old entry
    var isdir = FS.isDir(old_node.mode);
    var errCode = FS.mayDelete(old_dir, old_name, isdir);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    // need delete permissions if we'll be overwriting.
    // need create permissions if new doesn't already exist.
    errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!old_dir.node_ops.rename) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
      throw new FS.ErrnoError(10);
    }
    // if we are going to change the parent, check write permissions
    if (new_dir !== old_dir) {
      errCode = FS.nodePermissions(old_dir, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    // remove the node from the lookup hash
    FS.hashRemoveNode(old_node);
    // do the underlying fs rename
    try {
      old_dir.node_ops.rename(old_node, new_dir, new_name);
      // update old node (we do this here to avoid each backend
      // needing to)
      old_node.parent = new_dir;
    } catch (e) {
      throw e;
    } finally {
      // add the node back to the hash (in case node_ops.rename
      // changed its name)
      FS.hashAddNode(old_node);
    }
  },
  rmdir(path) {
    var lookup = FS.lookupPath(path, {
      parent: true
    });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, true);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.rmdir) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    parent.node_ops.rmdir(parent, name);
    FS.destroyNode(node);
  },
  readdir(path) {
    var lookup = FS.lookupPath(path, {
      follow: true
    });
    var node = lookup.node;
    var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
    return readdir(node);
  },
  unlink(path) {
    var lookup = FS.lookupPath(path, {
      parent: true
    });
    var parent = lookup.node;
    if (!parent) {
      throw new FS.ErrnoError(44);
    }
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, false);
    if (errCode) {
      // According to POSIX, we should map EISDIR to EPERM, but
      // we instead do what Linux does (and we must, as we use
      // the musl linux libc).
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.unlink) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    parent.node_ops.unlink(parent, name);
    FS.destroyNode(node);
  },
  readlink(path) {
    var lookup = FS.lookupPath(path);
    var link = lookup.node;
    if (!link) {
      throw new FS.ErrnoError(44);
    }
    if (!link.node_ops.readlink) {
      throw new FS.ErrnoError(28);
    }
    return link.node_ops.readlink(link);
  },
  stat(path, dontFollow) {
    var lookup = FS.lookupPath(path, {
      follow: !dontFollow
    });
    var node = lookup.node;
    var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
    return getattr(node);
  },
  fstat(fd) {
    var stream = FS.getStreamChecked(fd);
    var node = stream.node;
    var getattr = stream.stream_ops.getattr;
    var arg = getattr ? stream : node;
    getattr ??= node.node_ops.getattr;
    FS.checkOpExists(getattr, 63);
    return getattr(arg);
  },
  lstat(path) {
    return FS.stat(path, true);
  },
  doChmod(stream, node, mode, dontFollow) {
    FS.doSetAttr(stream, node, {
      mode: (mode & 4095) | (node.mode & ~4095),
      ctime: Date.now(),
      dontFollow
    });
  },
  chmod(path, mode, dontFollow) {
    var node;
    if (typeof path == "string") {
      var lookup = FS.lookupPath(path, {
        follow: !dontFollow
      });
      node = lookup.node;
    } else {
      node = path;
    }
    FS.doChmod(null, node, mode, dontFollow);
  },
  lchmod(path, mode) {
    FS.chmod(path, mode, true);
  },
  fchmod(fd, mode) {
    var stream = FS.getStreamChecked(fd);
    FS.doChmod(stream, stream.node, mode, false);
  },
  doChown(stream, node, dontFollow) {
    FS.doSetAttr(stream, node, {
      timestamp: Date.now(),
      dontFollow
    });
  },
  chown(path, uid, gid, dontFollow) {
    var node;
    if (typeof path == "string") {
      var lookup = FS.lookupPath(path, {
        follow: !dontFollow
      });
      node = lookup.node;
    } else {
      node = path;
    }
    FS.doChown(null, node, dontFollow);
  },
  lchown(path, uid, gid) {
    FS.chown(path, uid, gid, true);
  },
  fchown(fd, uid, gid) {
    var stream = FS.getStreamChecked(fd);
    FS.doChown(stream, stream.node, false);
  },
  doTruncate(stream, node, len) {
    if (FS.isDir(node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!FS.isFile(node.mode)) {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.nodePermissions(node, "w");
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    FS.doSetAttr(stream, node, {
      size: len,
      timestamp: Date.now()
    });
  },
  truncate(path, len) {
    if (len < 0) {
      throw new FS.ErrnoError(28);
    }
    var node;
    if (typeof path == "string") {
      var lookup = FS.lookupPath(path, {
        follow: true
      });
      node = lookup.node;
    } else {
      node = path;
    }
    FS.doTruncate(null, node, len);
  },
  ftruncate(fd, len) {
    var stream = FS.getStreamChecked(fd);
    if (len < 0 || (stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(28);
    }
    FS.doTruncate(stream, stream.node, len);
  },
  utime(path, atime, mtime) {
    var lookup = FS.lookupPath(path, {
      follow: true
    });
    var node = lookup.node;
    var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
    setattr(node, {
      atime,
      mtime
    });
  },
  open(path, flags, mode = 438) {
    if (path === "") {
      throw new FS.ErrnoError(44);
    }
    flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
    if ((flags & 64)) {
      mode = (mode & 4095) | 32768;
    } else {
      mode = 0;
    }
    var node;
    var isDirPath;
    if (typeof path == "object") {
      node = path;
    } else {
      isDirPath = path.endsWith("/");
      // noent_okay makes it so that if the final component of the path
      // doesn't exist, lookupPath returns `node: undefined`. `path` will be
      // updated to point to the target of all symlinks.
      var lookup = FS.lookupPath(path, {
        follow: !(flags & 131072),
        noent_okay: true
      });
      node = lookup.node;
      path = lookup.path;
    }
    // perhaps we need to create the node
    var created = false;
    if ((flags & 64)) {
      if (node) {
        // if O_CREAT and O_EXCL are set, error out if the node already exists
        if ((flags & 128)) {
          throw new FS.ErrnoError(20);
        }
      } else if (isDirPath) {
        throw new FS.ErrnoError(31);
      } else {
        // node doesn't exist, try to create it
        // Ignore the permission bits here to ensure we can `open` this new
        // file below. We use chmod below the apply the permissions once the
        // file is open.
        node = FS.mknod(path, mode | 511, 0);
        created = true;
      }
    }
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    // can't truncate a device
    if (FS.isChrdev(node.mode)) {
      flags &= ~512;
    }
    // if asked only for a directory, then this must be one
    if ((flags & 65536) && !FS.isDir(node.mode)) {
      throw new FS.ErrnoError(54);
    }
    // check permissions, if this is not a file we just created now (it is ok to
    // create and write to a file with read-only permissions; it is read-only
    // for later use)
    if (!created) {
      var errCode = FS.mayOpen(node, flags);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    // do truncation if necessary
    if ((flags & 512) && !created) {
      FS.truncate(node, 0);
    }
    // we've already handled these, don't pass down to the underlying vfs
    flags &= ~(128 | 512 | 131072);
    // register the stream with the filesystem
    var stream = FS.createStream({
      node,
      path: FS.getPath(node),
      // we want the absolute path to the node
      flags,
      seekable: true,
      position: 0,
      stream_ops: node.stream_ops,
      // used by the file family libc calls (fopen, fwrite, ferror, etc.)
      ungotten: [],
      error: false
    });
    // call the new stream's open function
    if (stream.stream_ops.open) {
      stream.stream_ops.open(stream);
    }
    if (created) {
      FS.chmod(node, mode & 511);
    }
    if (Module["logReadFiles"] && !(flags & 1)) {
      if (!(path in FS.readFiles)) {
        FS.readFiles[path] = 1;
      }
    }
    return stream;
  },
  close(stream) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (stream.getdents) stream.getdents = null;
    // free readdir state
    try {
      if (stream.stream_ops.close) {
        stream.stream_ops.close(stream);
      }
    } catch (e) {
      throw e;
    } finally {
      FS.closeStream(stream.fd);
    }
    stream.fd = null;
  },
  isClosed(stream) {
    return stream.fd === null;
  },
  llseek(stream, offset, whence) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (!stream.seekable || !stream.stream_ops.llseek) {
      throw new FS.ErrnoError(70);
    }
    if (whence != 0 && whence != 1 && whence != 2) {
      throw new FS.ErrnoError(28);
    }
    stream.position = stream.stream_ops.llseek(stream, offset, whence);
    stream.ungotten = [];
    return stream.position;
  },
  read(stream, buffer, offset, length, position) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.read) {
      throw new FS.ErrnoError(28);
    }
    var seeking = typeof position != "undefined";
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
    if (!seeking) stream.position += bytesRead;
    return bytesRead;
  },
  write(stream, buffer, offset, length, position, canOwn) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.write) {
      throw new FS.ErrnoError(28);
    }
    if (stream.seekable && stream.flags & 1024) {
      // seek to the end before writing in append mode
      FS.llseek(stream, 0, 2);
    }
    var seeking = typeof position != "undefined";
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
    if (!seeking) stream.position += bytesWritten;
    return bytesWritten;
  },
  mmap(stream, length, position, prot, flags) {
    // User requests writing to file (prot & PROT_WRITE != 0).
    // Checking if we have permissions to write to the file unless
    // MAP_PRIVATE flag is set. According to POSIX spec it is possible
    // to write to file opened in read-only mode with MAP_PRIVATE flag,
    // as all modifications will be visible only in the memory of
    // the current process.
    if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
      throw new FS.ErrnoError(2);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(2);
    }
    if (!stream.stream_ops.mmap) {
      throw new FS.ErrnoError(43);
    }
    if (!length) {
      throw new FS.ErrnoError(28);
    }
    return stream.stream_ops.mmap(stream, length, position, prot, flags);
  },
  msync(stream, buffer, offset, length, mmapFlags) {
    if (!stream.stream_ops.msync) {
      return 0;
    }
    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
  },
  ioctl(stream, cmd, arg) {
    if (!stream.stream_ops.ioctl) {
      throw new FS.ErrnoError(59);
    }
    return stream.stream_ops.ioctl(stream, cmd, arg);
  },
  readFile(path, opts = {}) {
    opts.flags = opts.flags || 0;
    opts.encoding = opts.encoding || "binary";
    if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
      throw new Error(`Invalid encoding type "${opts.encoding}"`);
    }
    var stream = FS.open(path, opts.flags);
    var stat = FS.stat(path);
    var length = stat.size;
    var buf = new Uint8Array(length);
    FS.read(stream, buf, 0, length, 0);
    if (opts.encoding === "utf8") {
      buf = UTF8ArrayToString(buf);
    }
    FS.close(stream);
    return buf;
  },
  writeFile(path, data, opts = {}) {
    opts.flags = opts.flags || 577;
    var stream = FS.open(path, opts.flags, opts.mode);
    if (typeof data == "string") {
      data = new Uint8Array(intArrayFromString(data, true));
    }
    if (ArrayBuffer.isView(data)) {
      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
    } else {
      throw new Error("Unsupported data type");
    }
    FS.close(stream);
  },
  cwd: () => FS.currentPath,
  chdir(path) {
    var lookup = FS.lookupPath(path, {
      follow: true
    });
    if (lookup.node === null) {
      throw new FS.ErrnoError(44);
    }
    if (!FS.isDir(lookup.node.mode)) {
      throw new FS.ErrnoError(54);
    }
    var errCode = FS.nodePermissions(lookup.node, "x");
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    FS.currentPath = lookup.path;
  },
  createDefaultDirectories() {
    FS.mkdir("/tmp");
    FS.mkdir("/home");
    FS.mkdir("/home/web_user");
  },
  createDefaultDevices() {
    // create /dev
    FS.mkdir("/dev");
    // setup /dev/null
    FS.registerDevice(FS.makedev(1, 3), {
      read: () => 0,
      write: (stream, buffer, offset, length, pos) => length,
      llseek: () => 0
    });
    FS.mkdev("/dev/null", FS.makedev(1, 3));
    // setup /dev/tty and /dev/tty1
    // stderr needs to print output using err() rather than out()
    // so we register a second tty just for it.
    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
    FS.mkdev("/dev/tty", FS.makedev(5, 0));
    FS.mkdev("/dev/tty1", FS.makedev(6, 0));
    // setup /dev/[u]random
    // use a buffer to avoid overhead of individual crypto calls per byte
    var randomBuffer = new Uint8Array(1024), randomLeft = 0;
    var randomByte = () => {
      if (randomLeft === 0) {
        randomFill(randomBuffer);
        randomLeft = randomBuffer.byteLength;
      }
      return randomBuffer[--randomLeft];
    };
    FS.createDevice("/dev", "random", randomByte);
    FS.createDevice("/dev", "urandom", randomByte);
    // we're not going to emulate the actual shm device,
    // just create the tmp dirs that reside in it commonly
    FS.mkdir("/dev/shm");
    FS.mkdir("/dev/shm/tmp");
  },
  createSpecialDirectories() {
    // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
    // name of the stream for fd 6 (see test_unistd_ttyname)
    FS.mkdir("/proc");
    var proc_self = FS.mkdir("/proc/self");
    FS.mkdir("/proc/self/fd");
    FS.mount({
      mount() {
        var node = FS.createNode(proc_self, "fd", 16895, 73);
        node.stream_ops = {
          llseek: MEMFS.stream_ops.llseek
        };
        node.node_ops = {
          lookup(parent, name) {
            var fd = +name;
            var stream = FS.getStreamChecked(fd);
            var ret = {
              parent: null,
              mount: {
                mountpoint: "fake"
              },
              node_ops: {
                readlink: () => stream.path
              },
              id: fd + 1
            };
            ret.parent = ret;
            // make it look like a simple root node
            return ret;
          },
          readdir() {
            return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
          }
        };
        return node;
      }
    }, {}, "/proc/self/fd");
  },
  createStandardStreams(input, output, error) {
    // TODO deprecate the old functionality of a single
    // input / output callback and that utilizes FS.createDevice
    // and instead require a unique set of stream ops
    // by default, we symlink the standard streams to the
    // default tty devices. however, if the standard streams
    // have been overwritten we create a unique device for
    // them instead.
    if (input) {
      FS.createDevice("/dev", "stdin", input);
    } else {
      FS.symlink("/dev/tty", "/dev/stdin");
    }
    if (output) {
      FS.createDevice("/dev", "stdout", null, output);
    } else {
      FS.symlink("/dev/tty", "/dev/stdout");
    }
    if (error) {
      FS.createDevice("/dev", "stderr", null, error);
    } else {
      FS.symlink("/dev/tty1", "/dev/stderr");
    }
    // open default streams for the stdin, stdout and stderr devices
    var stdin = FS.open("/dev/stdin", 0);
    var stdout = FS.open("/dev/stdout", 1);
    var stderr = FS.open("/dev/stderr", 1);
  },
  staticInit() {
    FS.nameTable = new Array(4096);
    FS.mount(MEMFS, {}, "/");
    FS.createDefaultDirectories();
    FS.createDefaultDevices();
    FS.createSpecialDirectories();
    FS.filesystems = {
      "MEMFS": MEMFS
    };
  },
  init(input, output, error) {
    FS.initialized = true;
    // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
    input ??= Module["stdin"];
    output ??= Module["stdout"];
    error ??= Module["stderr"];
    FS.createStandardStreams(input, output, error);
  },
  quit() {
    FS.initialized = false;
    // force-flush all streams, so we get musl std streams printed out
    // close all of our streams
    for (var stream of FS.streams) {
      if (stream) {
        FS.close(stream);
      }
    }
  },
  findObject(path, dontResolveLastLink) {
    var ret = FS.analyzePath(path, dontResolveLastLink);
    if (!ret.exists) {
      return null;
    }
    return ret.object;
  },
  analyzePath(path, dontResolveLastLink) {
    // operate from within the context of the symlink's target
    try {
      var lookup = FS.lookupPath(path, {
        follow: !dontResolveLastLink
      });
      path = lookup.path;
    } catch (e) {}
    var ret = {
      isRoot: false,
      exists: false,
      error: 0,
      name: null,
      path: null,
      object: null,
      parentExists: false,
      parentPath: null,
      parentObject: null
    };
    try {
      var lookup = FS.lookupPath(path, {
        parent: true
      });
      ret.parentExists = true;
      ret.parentPath = lookup.path;
      ret.parentObject = lookup.node;
      ret.name = PATH.basename(path);
      lookup = FS.lookupPath(path, {
        follow: !dontResolveLastLink
      });
      ret.exists = true;
      ret.path = lookup.path;
      ret.object = lookup.node;
      ret.name = lookup.node.name;
      ret.isRoot = lookup.path === "/";
    } catch (e) {
      ret.error = e.errno;
    }
    return ret;
  },
  createPath(parent, path, canRead, canWrite) {
    parent = typeof parent == "string" ? parent : FS.getPath(parent);
    var parts = path.split("/").reverse();
    while (parts.length) {
      var part = parts.pop();
      if (!part) continue;
      var current = PATH.join2(parent, part);
      try {
        FS.mkdir(current);
      } catch (e) {
        if (e.errno != 20) throw e;
      }
      parent = current;
    }
    return current;
  },
  createFile(parent, name, properties, canRead, canWrite) {
    var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
    var mode = FS_getMode(canRead, canWrite);
    return FS.create(path, mode);
  },
  createDataFile(parent, name, data, canRead, canWrite, canOwn) {
    var path = name;
    if (parent) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      path = name ? PATH.join2(parent, name) : parent;
    }
    var mode = FS_getMode(canRead, canWrite);
    var node = FS.create(path, mode);
    if (data) {
      if (typeof data == "string") {
        var arr = new Array(data.length);
        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
        data = arr;
      }
      // make sure we can write to the file
      FS.chmod(node, mode | 146);
      var stream = FS.open(node, 577);
      FS.write(stream, data, 0, data.length, 0, canOwn);
      FS.close(stream);
      FS.chmod(node, mode);
    }
  },
  createDevice(parent, name, input, output) {
    var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
    var mode = FS_getMode(!!input, !!output);
    FS.createDevice.major ??= 64;
    var dev = FS.makedev(FS.createDevice.major++, 0);
    // Create a fake device that a set of stream ops to emulate
    // the old behavior.
    FS.registerDevice(dev, {
      open(stream) {
        stream.seekable = false;
      },
      close(stream) {
        // flush any pending line data
        if (output?.buffer?.length) {
          output(10);
        }
      },
      read(stream, buffer, offset, length, pos) {
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === undefined && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === undefined) break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.atime = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        for (var i = 0; i < length; i++) {
          try {
            output(buffer[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length) {
          stream.node.mtime = stream.node.ctime = Date.now();
        }
        return i;
      }
    });
    return FS.mkdev(path, mode, dev);
  },
  forceLoadFile(obj) {
    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
    if (typeof XMLHttpRequest != "undefined") {
      throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
    } else {
      // Command-line.
      try {
        obj.contents = readBinary(obj.url);
        obj.usedBytes = obj.contents.length;
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
    }
  },
  createLazyFile(parent, name, url, canRead, canWrite) {
    // Lazy chunked Uint8Array (implements get and length from Uint8Array).
    // Actual getting is abstracted away for eventual reuse.
    class LazyUint8Array {
      lengthKnown=false;
      chunks=[];
      // Loaded chunks. Index is the chunk number
      get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return undefined;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = (idx / this.chunkSize) | 0;
        return this.getter(chunkNum)[chunkOffset];
      }
      setDataGetter(getter) {
        this.getter = getter;
      }
      cacheLength() {
        // Find length
        var xhr = new XMLHttpRequest;
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        // Chunk size in bytes
        if (!hasByteServing) chunkSize = datalength;
        // Function to get a range from the remote URL.
        var doXHR = (from, to) => {
          if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
          // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
          var xhr = new XMLHttpRequest;
          xhr.open("GET", url, false);
          if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
          // Some hints to the browser that we want binary data.
          xhr.responseType = "arraybuffer";
          if (xhr.overrideMimeType) {
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          if (xhr.response !== undefined) {
            return new Uint8Array(/** @type{Array<number>} */ (xhr.response || []));
          }
          return intArrayFromString(xhr.responseText || "", true);
        };
        var lazyArray = this;
        lazyArray.setDataGetter(chunkNum => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          // including this byte
          end = Math.min(end, datalength - 1);
          // if datalength-1 is selected, this is the last block
          if (typeof lazyArray.chunks[chunkNum] == "undefined") {
            lazyArray.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
          return lazyArray.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
          chunkSize = datalength = 1;
          // this will force getter(0)/doXHR do download the whole file
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      }
      get length() {
        if (!this.lengthKnown) {
          this.cacheLength();
        }
        return this._length;
      }
      get chunkSize() {
        if (!this.lengthKnown) {
          this.cacheLength();
        }
        return this._chunkSize;
      }
    }
    if (typeof XMLHttpRequest != "undefined") {
      if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
      var lazyArray = new LazyUint8Array;
      var properties = {
        isDevice: false,
        contents: lazyArray
      };
    } else {
      var properties = {
        isDevice: false,
        url
      };
    }
    var node = FS.createFile(parent, name, properties, canRead, canWrite);
    // This is a total hack, but I want to get this lazy file code out of the
    // core of MEMFS. If we want to keep this lazy file concept I feel it should
    // be its own thin LAZYFS proxying calls to MEMFS.
    if (properties.contents) {
      node.contents = properties.contents;
    } else if (properties.url) {
      node.contents = null;
      node.url = properties.url;
    }
    // Add a function that defers querying the file size until it is asked the first time.
    Object.defineProperties(node, {
      usedBytes: {
        get: function() {
          return this.contents.length;
        }
      }
    });
    // override each stream op with one that tries to force load the lazy file first
    var stream_ops = {};
    var keys = Object.keys(node.stream_ops);
    keys.forEach(key => {
      var fn = node.stream_ops[key];
      stream_ops[key] = (...args) => {
        FS.forceLoadFile(node);
        return fn(...args);
      };
    });
    function writeChunks(stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= contents.length) return 0;
      var size = Math.min(contents.length - position, length);
      if (contents.slice) {
        // normal array
        for (var i = 0; i < size; i++) {
          buffer[offset + i] = contents[position + i];
        }
      } else {
        for (var i = 0; i < size; i++) {
          // LazyUint8Array from sync binary XHR
          buffer[offset + i] = contents.get(position + i);
        }
      }
      return size;
    }
    // use a custom read function
    stream_ops.read = (stream, buffer, offset, length, position) => {
      FS.forceLoadFile(node);
      return writeChunks(stream, buffer, offset, length, position);
    };
    // use a custom mmap function
    stream_ops.mmap = (stream, length, position, prot, flags) => {
      FS.forceLoadFile(node);
      var ptr = mmapAlloc(length);
      if (!ptr) {
        throw new FS.ErrnoError(48);
      }
      writeChunks(stream, HEAP8, ptr, length, position);
      return {
        ptr,
        allocated: true
      };
    };
    node.stream_ops = stream_ops;
    return node;
  }
};

/**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index.
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */ var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : "";

var SYSCALLS = {
  DEFAULT_POLLMASK: 5,
  calculateAt(dirfd, path, allowEmpty) {
    if (PATH.isAbs(path)) {
      return path;
    }
    // relative path
    var dir;
    if (dirfd === -100) {
      dir = FS.cwd();
    } else {
      var dirstream = SYSCALLS.getStreamFromFD(dirfd);
      dir = dirstream.path;
    }
    if (path.length == 0) {
      if (!allowEmpty) {
        throw new FS.ErrnoError(44);
      }
      return dir;
    }
    return dir + "/" + path;
  },
  writeStat(buf, stat) {
    HEAPU32[((buf) >> 2)] = stat.dev;
    HEAPU32[(((buf) + (4)) >> 2)] = stat.mode;
    HEAPU32[(((buf) + (8)) >> 2)] = stat.nlink;
    HEAPU32[(((buf) + (12)) >> 2)] = stat.uid;
    HEAPU32[(((buf) + (16)) >> 2)] = stat.gid;
    HEAPU32[(((buf) + (20)) >> 2)] = stat.rdev;
    HEAP64[(((buf) + (24)) >> 3)] = BigInt(stat.size);
    HEAP32[(((buf) + (32)) >> 2)] = 4096;
    HEAP32[(((buf) + (36)) >> 2)] = stat.blocks;
    var atime = stat.atime.getTime();
    var mtime = stat.mtime.getTime();
    var ctime = stat.ctime.getTime();
    HEAP64[(((buf) + (40)) >> 3)] = BigInt(Math.floor(atime / 1e3));
    HEAPU32[(((buf) + (48)) >> 2)] = (atime % 1e3) * 1e3 * 1e3;
    HEAP64[(((buf) + (56)) >> 3)] = BigInt(Math.floor(mtime / 1e3));
    HEAPU32[(((buf) + (64)) >> 2)] = (mtime % 1e3) * 1e3 * 1e3;
    HEAP64[(((buf) + (72)) >> 3)] = BigInt(Math.floor(ctime / 1e3));
    HEAPU32[(((buf) + (80)) >> 2)] = (ctime % 1e3) * 1e3 * 1e3;
    HEAP64[(((buf) + (88)) >> 3)] = BigInt(stat.ino);
    return 0;
  },
  writeStatFs(buf, stats) {
    HEAPU32[(((buf) + (4)) >> 2)] = stats.bsize;
    HEAPU32[(((buf) + (60)) >> 2)] = stats.bsize;
    HEAP64[(((buf) + (8)) >> 3)] = BigInt(stats.blocks);
    HEAP64[(((buf) + (16)) >> 3)] = BigInt(stats.bfree);
    HEAP64[(((buf) + (24)) >> 3)] = BigInt(stats.bavail);
    HEAP64[(((buf) + (32)) >> 3)] = BigInt(stats.files);
    HEAP64[(((buf) + (40)) >> 3)] = BigInt(stats.ffree);
    HEAPU32[(((buf) + (48)) >> 2)] = stats.fsid;
    HEAPU32[(((buf) + (64)) >> 2)] = stats.flags;
    // ST_NOSUID
    HEAPU32[(((buf) + (56)) >> 2)] = stats.namelen;
  },
  doMsync(addr, stream, len, flags, offset) {
    if (!FS.isFile(stream.node.mode)) {
      throw new FS.ErrnoError(43);
    }
    if (flags & 2) {
      // MAP_PRIVATE calls need not to be synced back to underlying fs
      return 0;
    }
    var buffer = HEAPU8.slice(addr, addr + len);
    FS.msync(stream, buffer, offset, len, flags);
  },
  getStreamFromFD(fd) {
    var stream = FS.getStreamChecked(fd);
    return stream;
  },
  varargs: undefined,
  getStr(ptr) {
    var ret = UTF8ToString(ptr);
    return ret;
  }
};

function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (cmd) {
     case 0:
      {
        var arg = syscallGetVarargI();
        if (arg < 0) {
          return -28;
        }
        while (FS.streams[arg]) {
          arg++;
        }
        var newStream;
        newStream = FS.dupStream(stream, arg);
        return newStream.fd;
      }

     case 1:
     case 2:
      return 0;

     // FD_CLOEXEC makes no sense for a single process.
      case 3:
      return stream.flags;

     case 4:
      {
        var arg = syscallGetVarargI();
        stream.flags |= arg;
        return 0;
      }

     case 12:
      {
        var arg = syscallGetVarargP();
        var offset = 0;
        // We're always unlocked.
        HEAP16[(((arg) + (offset)) >> 1)] = 2;
        return 0;
      }

     case 13:
     case 14:
      // Pretend that the locking is successful. These are process-level locks,
      // and Emscripten programs are a single process. If we supported linking a
      // filesystem between programs, we'd need to do more here.
      // See https://github.com/emscripten-core/emscripten/issues/23697
      return 0;
    }
    return -28;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return -e.errno;
  }
}

function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (op) {
     case 21509:
      {
        if (!stream.tty) return -59;
        return 0;
      }

     case 21505:
      {
        if (!stream.tty) return -59;
        if (stream.tty.ops.ioctl_tcgets) {
          var termios = stream.tty.ops.ioctl_tcgets(stream);
          var argp = syscallGetVarargP();
          HEAP32[((argp) >> 2)] = termios.c_iflag || 0;
          HEAP32[(((argp) + (4)) >> 2)] = termios.c_oflag || 0;
          HEAP32[(((argp) + (8)) >> 2)] = termios.c_cflag || 0;
          HEAP32[(((argp) + (12)) >> 2)] = termios.c_lflag || 0;
          for (var i = 0; i < 32; i++) {
            HEAP8[(argp + i) + (17)] = termios.c_cc[i] || 0;
          }
          return 0;
        }
        return 0;
      }

     case 21510:
     case 21511:
     case 21512:
      {
        if (!stream.tty) return -59;
        return 0;
      }

     case 21506:
     case 21507:
     case 21508:
      {
        if (!stream.tty) return -59;
        if (stream.tty.ops.ioctl_tcsets) {
          var argp = syscallGetVarargP();
          var c_iflag = HEAP32[((argp) >> 2)];
          var c_oflag = HEAP32[(((argp) + (4)) >> 2)];
          var c_cflag = HEAP32[(((argp) + (8)) >> 2)];
          var c_lflag = HEAP32[(((argp) + (12)) >> 2)];
          var c_cc = [];
          for (var i = 0; i < 32; i++) {
            c_cc.push(HEAP8[(argp + i) + (17)]);
          }
          return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
            c_iflag,
            c_oflag,
            c_cflag,
            c_lflag,
            c_cc
          });
        }
        return 0;
      }

     case 21519:
      {
        if (!stream.tty) return -59;
        var argp = syscallGetVarargP();
        HEAP32[((argp) >> 2)] = 0;
        return 0;
      }

     case 21520:
      {
        if (!stream.tty) return -59;
        return -28;
      }

     case 21537:
     case 21531:
      {
        var argp = syscallGetVarargP();
        return FS.ioctl(stream, op, argp);
      }

     case 21523:
      {
        // TODO: in theory we should write to the winsize struct that gets
        // passed in, but for now musl doesn't read anything on it
        if (!stream.tty) return -59;
        if (stream.tty.ops.ioctl_tiocgwinsz) {
          var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
          var argp = syscallGetVarargP();
          HEAP16[((argp) >> 1)] = winsize[0];
          HEAP16[(((argp) + (2)) >> 1)] = winsize[1];
        }
        return 0;
      }

     case 21524:
      {
        // TODO: technically, this ioctl call should change the window size.
        // but, since emscripten doesn't have any concept of a terminal window
        // yet, we'll just silently throw it away as we do TIOCGWINSZ
        if (!stream.tty) return -59;
        return 0;
      }

     case 21515:
      {
        if (!stream.tty) return -59;
        return 0;
      }

     default:
      return -28;
    }
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return -e.errno;
  }
}

function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    var mode = varargs ? syscallGetVarargI() : 0;
    return FS.open(path, flags, mode).fd;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return -e.errno;
  }
}

function ___syscall_stat64(path, buf) {
  try {
    path = SYSCALLS.getStr(path);
    return SYSCALLS.writeStat(buf, FS.stat(path));
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return -e.errno;
  }
}

var __abort_js = () => abort("");

var runtimeKeepaliveCounter = 0;

var __emscripten_runtime_keepalive_clear = () => {
  noExitRuntime = false;
  runtimeKeepaliveCounter = 0;
};

var isLeapYear = year => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);

var MONTH_DAYS_LEAP_CUMULATIVE = [ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 ];

var MONTH_DAYS_REGULAR_CUMULATIVE = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ];

var ydayFromDate = date => {
  var leap = isLeapYear(date.getFullYear());
  var monthDaysCumulative = (leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE);
  var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
  // -1 since it's days since Jan 1
  return yday;
};

var INT53_MAX = 9007199254740992;

var INT53_MIN = -9007199254740992;

var bigintToI53Checked = num => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);

function __localtime_js(time, tmPtr) {
  time = bigintToI53Checked(time);
  var date = new Date(time * 1e3);
  HEAP32[((tmPtr) >> 2)] = date.getSeconds();
  HEAP32[(((tmPtr) + (4)) >> 2)] = date.getMinutes();
  HEAP32[(((tmPtr) + (8)) >> 2)] = date.getHours();
  HEAP32[(((tmPtr) + (12)) >> 2)] = date.getDate();
  HEAP32[(((tmPtr) + (16)) >> 2)] = date.getMonth();
  HEAP32[(((tmPtr) + (20)) >> 2)] = date.getFullYear() - 1900;
  HEAP32[(((tmPtr) + (24)) >> 2)] = date.getDay();
  var yday = ydayFromDate(date) | 0;
  HEAP32[(((tmPtr) + (28)) >> 2)] = yday;
  HEAP32[(((tmPtr) + (36)) >> 2)] = -(date.getTimezoneOffset() * 60);
  // Attention: DST is in December in South, and some regions don't have DST at all.
  var start = new Date(date.getFullYear(), 0, 1);
  var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
  var winterOffset = start.getTimezoneOffset();
  var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
  HEAP32[(((tmPtr) + (32)) >> 2)] = dst;
}

var timers = {};

var handleException = e => {
  // Certain exception types we do not treat as errors since they are used for
  // internal control flow.
  // 1. ExitStatus, which is thrown by exit()
  // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
  //    that wish to return to JS event loop.
  if (e instanceof ExitStatus || e == "unwind") {
    return EXITSTATUS;
  }
  quit_(1, e);
};

var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;

var _proc_exit = code => {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    Module["onExit"]?.(code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
};

/** @suppress {duplicate } */ /** @param {boolean|number=} implicit */ var exitJS = (status, implicit) => {
  EXITSTATUS = status;
  _proc_exit(status);
};

var _exit = exitJS;

var maybeExit = () => {
  if (!keepRuntimeAlive()) {
    try {
      _exit(EXITSTATUS);
    } catch (e) {
      handleException(e);
    }
  }
};

var callUserCallback = func => {
  if (ABORT) {
    return;
  }
  try {
    func();
    maybeExit();
  } catch (e) {
    handleException(e);
  }
};

var _emscripten_get_now = () => performance.now();

var __setitimer_js = (which, timeout_ms) => {
  // First, clear any existing timer.
  if (timers[which]) {
    clearTimeout(timers[which].id);
    delete timers[which];
  }
  // A timeout of zero simply cancels the current timeout so we have nothing
  // more to do.
  if (!timeout_ms) return 0;
  var id = setTimeout(() => {
    delete timers[which];
    callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
  }, timeout_ms);
  timers[which] = {
    id,
    timeout_ms
  };
  return 0;
};

var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);

var __tzset_js = (timezone, daylight, std_name, dst_name) => {
  // TODO: Use (malleable) environment variables instead of system settings.
  var currentYear = (new Date).getFullYear();
  var winter = new Date(currentYear, 0, 1);
  var summer = new Date(currentYear, 6, 1);
  var winterOffset = winter.getTimezoneOffset();
  var summerOffset = summer.getTimezoneOffset();
  // Local standard timezone offset. Local standard time is not adjusted for
  // daylight savings.  This code uses the fact that getTimezoneOffset returns
  // a greater value during Standard Time versus Daylight Saving Time (DST).
  // Thus it determines the expected output during Standard Time, and it
  // compares whether the output of the given date the same (Standard) or less
  // (DST).
  var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  // timezone is specified as seconds west of UTC ("The external variable
  // `timezone` shall be set to the difference, in seconds, between
  // Coordinated Universal Time (UTC) and local standard time."), the same
  // as returned by stdTimezoneOffset.
  // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
  HEAPU32[((timezone) >> 2)] = stdTimezoneOffset * 60;
  HEAP32[((daylight) >> 2)] = Number(winterOffset != summerOffset);
  var extractZone = timezoneOffset => {
    // Why inverse sign?
    // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
    var sign = timezoneOffset >= 0 ? "-" : "+";
    var absOffset = Math.abs(timezoneOffset);
    var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
    var minutes = String(absOffset % 60).padStart(2, "0");
    return `UTC${sign}${hours}${minutes}`;
  };
  var winterName = extractZone(winterOffset);
  var summerName = extractZone(summerOffset);
  if (summerOffset < winterOffset) {
    // Northern hemisphere
    stringToUTF8(winterName, std_name, 17);
    stringToUTF8(summerName, dst_name, 17);
  } else {
    stringToUTF8(winterName, dst_name, 17);
    stringToUTF8(summerName, std_name, 17);
  }
};

var _emscripten_date_now = () => Date.now();

var nowIsMonotonic = 1;

var checkWasiClock = clock_id => clock_id >= 0 && clock_id <= 3;

function _clock_time_get(clk_id, ignored_precision, ptime) {
  ignored_precision = bigintToI53Checked(ignored_precision);
  if (!checkWasiClock(clk_id)) {
    return 28;
  }
  var now;
  // all wasi clocks but realtime are monotonic
  if (clk_id === 0) {
    now = _emscripten_date_now();
  } else if (nowIsMonotonic) {
    now = _emscripten_get_now();
  } else {
    return 52;
  }
  // "now" is in ms, and wasi times are in ns.
  var nsec = Math.round(now * 1e3 * 1e3);
  HEAP64[((ptime) >> 3)] = BigInt(nsec);
  return 0;
}

var getHeapMax = () => // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
// for any code that deals with heap sizes, which would require special
// casing all heap size related code to treat 0 specially.
2147483648;

var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;

var growMemory = size => {
  var oldHeapSize = wasmMemory.buffer.byteLength;
  var pages = ((size - oldHeapSize + 65535) / 65536) | 0;
  try {
    // round size grow request up to wasm page size (fixed 64KB per spec)
    wasmMemory.grow(pages);
    // .grow() takes a delta compared to the previous size
    updateMemoryViews();
    return 1;
  } catch (e) {}
};

var _emscripten_resize_heap = requestedSize => {
  var oldSize = HEAPU8.length;
  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
  requestedSize >>>= 0;
  // With multithreaded builds, races can happen (another thread might increase the size
  // in between), so return a failure, and let the caller retry.
  // Memory resize rules:
  // 1.  Always increase heap size to at least the requested size, rounded up
  //     to next page multiple.
  // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
  //     geometrically: increase the heap size according to
  //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
  //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
  // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
  //     linearly: increase the heap size by at least
  //     MEMORY_GROWTH_LINEAR_STEP bytes.
  // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
  //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
  // 4.  If we were unable to allocate as much memory, it may be due to
  //     over-eager decision to excessively reserve due to (3) above.
  //     Hence if an allocation fails, cut down on the amount of excess
  //     growth, in an attempt to succeed to perform a smaller allocation.
  // A limit is set for how much we can grow. We should not exceed that
  // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
  var maxHeapSize = getHeapMax();
  if (requestedSize > maxHeapSize) {
    return false;
  }
  // Loop through potential heap size increases. If we attempt a too eager
  // reservation that fails, cut down on the attempted size and reserve a
  // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
    // ensure geometric growth
    // but limit overreserving (default to capping at +96MB overgrowth at most)
    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
    var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
    var replacement = growMemory(newSize);
    if (replacement) {
      return true;
    }
  }
  return false;
};

function _fd_close(fd) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.close(stream);
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

function _fd_fdstat_get(fd, pbuf) {
  try {
    var rightsBase = 0;
    var rightsInheriting = 0;
    var flags = 0;
    {
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
    }
    HEAP8[pbuf] = type;
    HEAP16[(((pbuf) + (2)) >> 1)] = flags;
    HEAP64[(((pbuf) + (8)) >> 3)] = BigInt(rightsBase);
    HEAP64[(((pbuf) + (16)) >> 3)] = BigInt(rightsInheriting);
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

/** @param {number=} offset */ var doReadv = (stream, iov, iovcnt, offset) => {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
    var ptr = HEAPU32[((iov) >> 2)];
    var len = HEAPU32[(((iov) + (4)) >> 2)];
    iov += 8;
    var curr = FS.read(stream, HEAP8, ptr, len, offset);
    if (curr < 0) return -1;
    ret += curr;
    if (curr < len) break;
    // nothing more to read
    if (typeof offset != "undefined") {
      offset += curr;
    }
  }
  return ret;
};

function _fd_read(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = doReadv(stream, iov, iovcnt);
    HEAPU32[((pnum) >> 2)] = num;
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

function _fd_seek(fd, offset, whence, newOffset) {
  offset = bigintToI53Checked(offset);
  try {
    if (isNaN(offset)) return 61;
    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.llseek(stream, offset, whence);
    HEAP64[((newOffset) >> 3)] = BigInt(stream.position);
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
    // reset readdir state
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

/** @param {number=} offset */ var doWritev = (stream, iov, iovcnt, offset) => {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
    var ptr = HEAPU32[((iov) >> 2)];
    var len = HEAPU32[(((iov) + (4)) >> 2)];
    iov += 8;
    var curr = FS.write(stream, HEAP8, ptr, len, offset);
    if (curr < 0) return -1;
    ret += curr;
    if (curr < len) {
      // No more space to write.
      break;
    }
    if (typeof offset != "undefined") {
      offset += curr;
    }
  }
  return ret;
};

function _fd_write(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = doWritev(stream, iov, iovcnt);
    HEAPU32[((pnum) >> 2)] = num;
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

var stackAlloc = sz => __emscripten_stack_alloc(sz);

var stringToUTF8OnStack = str => {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8(str, ret, size);
  return ret;
};

var FS_readFile = (...args) => FS.readFile(...args);

var FS_writeFile = (...args) => FS.writeFile(...args);

// Precreate a reverse lookup table from chars
// "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" back to
// bytes to make decoding fast.
for (var base64ReverseLookup = new Uint8Array(123), i = 25; i >= 0; --i) {
  base64ReverseLookup[48 + i] = 52 + i;
  // '0-9'
  base64ReverseLookup[65 + i] = i;
  // 'A-Z'
  base64ReverseLookup[97 + i] = 26 + i;
}

base64ReverseLookup[43] = 62;

// '+'
base64ReverseLookup[47] = 63;

FS.createPreloadedFile = FS_createPreloadedFile;

FS.preloadFile = FS_preloadFile;

FS.staticInit();

// End JS library code
// include: postlibrary.js
// This file is included after the automatically-generated JS library code
// but before the wasm module is created.
{
  // Begin ATMODULES hooks
  if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];
  if (Module["preloadPlugins"]) preloadPlugins = Module["preloadPlugins"];
  if (Module["print"]) out = Module["print"];
  if (Module["printErr"]) err = Module["printErr"];
  if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
  // End ATMODULES hooks
  if (Module["arguments"]) arguments_ = Module["arguments"];
  if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
}

// Begin runtime exports
Module["callMain"] = callMain;

Module["FS_readFile"] = FS_readFile;

Module["FS_writeFile"] = FS_writeFile;

// End runtime exports
// Begin JS library exports
// End JS library exports
// end include: postlibrary.js
// Imports from the Wasm binary.
var _main, __emscripten_timeout, __emscripten_stack_alloc;

function assignWasmExports(wasmExports) {
  Module["_main"] = _main = wasmExports["v"];
  __emscripten_timeout = wasmExports["w"];
  __emscripten_stack_alloc = wasmExports["x"];
}

var wasmImports = {
  /** @export */ b: ___syscall_fcntl64,
  /** @export */ s: ___syscall_ioctl,
  /** @export */ r: ___syscall_openat,
  /** @export */ q: ___syscall_stat64,
  /** @export */ j: __abort_js,
  /** @export */ i: __emscripten_runtime_keepalive_clear,
  /** @export */ h: __localtime_js,
  /** @export */ g: __setitimer_js,
  /** @export */ f: __tzset_js,
  /** @export */ p: _clock_time_get,
  /** @export */ e: _emscripten_date_now,
  /** @export */ d: _emscripten_resize_heap,
  /** @export */ c: _exit,
  /** @export */ a: _fd_close,
  /** @export */ o: _fd_fdstat_get,
  /** @export */ n: _fd_read,
  /** @export */ m: _fd_seek,
  /** @export */ l: _fd_write,
  /** @export */ k: _proc_exit
};

var wasmExports = await createWasm();

// include: postamble.js
// === Auto-generated postamble setup entry stuff ===
function callMain(args = []) {
  var entryFunction = _main;
  args.unshift(thisProgram);
  var argc = args.length;
  var argv = stackAlloc((argc + 1) * 4);
  var argv_ptr = argv;
  args.forEach(arg => {
    HEAPU32[((argv_ptr) >> 2)] = stringToUTF8OnStack(arg);
    argv_ptr += 4;
  });
  HEAPU32[((argv_ptr) >> 2)] = 0;
  try {
    var ret = entryFunction(argc, argv);
    // if we're not running an evented main loop, it's time to exit
    exitJS(ret, /* implicit = */ true);
    return ret;
  } catch (e) {
    return handleException(e);
  }
}

function run(args = arguments_) {
  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }
  preRun();
  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }
  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    Module["calledRun"] = true;
    if (ABORT) return;
    initRuntime();
    preMain();
    readyPromiseResolve?.(Module);
    Module["onRuntimeInitialized"]?.();
    var noInitialRun = Module["noInitialRun"] || true;
    if (!noInitialRun) callMain(args);
    postRun();
  }
  if (Module["setStatus"]) {
    Module["setStatus"]("Running...");
    setTimeout(() => {
      setTimeout(() => Module["setStatus"](""), 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}

function preInit() {
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
    while (Module["preInit"].length > 0) {
      Module["preInit"].shift()();
    }
  }
}

preInit();

run();

// end include: postamble.js
// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.
if (runtimeInitialized) {
  moduleRtn = Module;
} else {
  // Set up the promise that indicates the Module is initialized
  moduleRtn = new Promise((resolve, reject) => {
    readyPromiseResolve = resolve;
    readyPromiseReject = reject;
  });
}


  return moduleRtn;
}

// Export using a UMD style export, or ES6 exports if selected
export default Module;

