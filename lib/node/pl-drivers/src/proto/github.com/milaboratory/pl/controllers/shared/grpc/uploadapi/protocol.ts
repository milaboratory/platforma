// @generated by protobuf-ts 2.9.4 with parameter client_generic,optimize_speed,generate_dependencies,force_server_none
// @generated from protobuf file "github.com/milaboratory/pl/controllers/shared/grpc/uploadapi/protocol.proto" (package "MiLaboratories.Controller.Shared", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi
 */
export interface uploadapi {}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.Init
 */
export interface uploadapi_Init {}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.Init.Request
 */
export interface uploadapi_Init_Request {
  /**
   * Id of upload resource
   *
   * @generated from protobuf field: uint64 resource_id = 1;
   */
  resourceId: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.Init.Response
 */
export interface uploadapi_Init_Response {
  /**
   * Number of parts in this upload.
   * For parallel upload support, client can generate any number of part upload URLs
   * at the moment and upload them in parallel.
   * <parts_count> keeps the number of chunks supported by this upload.
   * The parts count is calculated from the planned size of the upload, controller
   * configuration and underlying storage restrictions.
   *
   * @generated from protobuf field: uint64 parts_count = 1;
   */
  partsCount: bigint;
  /**
   * List of IDs of parts that were already uploaded by client.
   * Helps client to recover upload and skip already done parts
   * after being interrupted in the middle of the upload
   * (say, because of the restart).
   * Parts enumeration starts from 1.
   *
   * @generated from protobuf field: repeated uint64 uploaded_parts = 2;
   */
  uploadedParts: bigint[];
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.UpdateProgress
 */
export interface uploadapi_UpdateProgress {}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.UpdateProgress.Request
 */
export interface uploadapi_UpdateProgress_Request {
  /**
   * Id of upload resource
   *
   * @generated from protobuf field: uint64 resource_id = 1;
   */
  resourceId: bigint;
  /**
   * Amount of bytes, uploaded since the earlier call to UpdateProgress.
   * This value is just blindly added to the 'bytes_processed' of progress report,
   * so other clients can see the upload progress.
   * If client uploads the data in several streams (several chunks in parallel), it
   * can safely send progress updates individually for each of the streams, just counting
   * bytes uploaded by particular stream.
   *
   * Negative value can be used to report about upload retry: when upload was interrupted,
   * part of the uploaded data is lost and require re-upload.
   *
   * @generated from protobuf field: int64 bytes_processed = 2;
   */
  bytesProcessed: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.UpdateProgress.Response
 */
export interface uploadapi_UpdateProgress_Response {}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL
 */
export interface uploadapi_GetPartURL {}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL.Request
 */
export interface uploadapi_GetPartURL_Request {
  /**
   * Id of upload resource
   *
   * @generated from protobuf field: uint64 resource_id = 1;
   */
  resourceId: bigint;
  /**
   * Part to be uploaded. It is responsibility of the Client to watch after already uploaded parts:
   * - client can request an URL for the same part twice (request -> request) without errors;
   * - client can request an URL for alrady uploaded part (request -> upload -> request) without errors.
   *
   * Parts enumeration starts from 1.
   *
   * @generated from protobuf field: uint64 part_number = 2;
   */
  partNumber: bigint;
  /**
   * Size of the part uploaded by client earlier. Allows controller to count upload progress
   * based on client's input.
   * Client is free to never sent this value (send zeroes in each request).
   *
   * @generated from protobuf field: uint64 uploaded_part_size = 3;
   */
  uploadedPartSize: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL.HTTPHeader
 */
export interface uploadapi_GetPartURL_HTTPHeader {
  /**
   * @generated from protobuf field: string Name = 1 [json_name = "Name"];
   */
  name: string;
  /**
   * @generated from protobuf field: string Value = 2 [json_name = "Value"];
   */
  value: string;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL.Response
 */
export interface uploadapi_GetPartURL_Response {
  /**
   * URL for chunk upload
   *
   * @generated from protobuf field: string upload_url = 1;
   */
  uploadUrl: string;
  /**
   * HTTP method to use for chunk upload, say 'PUT' or 'POST'.
   *
   * @generated from protobuf field: string method = 2;
   */
  method: string;
  /**
   * List of headers with their values, MANDATORY to be sent by the client for the upload.
   * The destination service (the one, that will handle upload request for specific part)
   * may reject the request if it would not keep the given headers.
   *
   * @generated from protobuf field: repeated MiLaboratories.Controller.Shared.uploadapi.GetPartURL.HTTPHeader headers = 3;
   */
  headers: uploadapi_GetPartURL_HTTPHeader[];
  /**
   * The number of the _first_ byte in the chunk.
   * Absolute position from the start of the file ( file.seek(<chunk_start>, SEEK_START) ).
   * The client is expected to send [<chunk_start>; <chunk_end>) range.
   *
   * @generated from protobuf field: uint64 chunk_start = 4;
   */
  chunkStart: bigint;
  /**
   * The number of the byte _after_ the last to be sent in the chunk.
   * Absolute position from the start of the file.
   * The client is expected to send [<chunk_start>; <chunk_end>) range.
   *
   * @generated from protobuf field: uint64 chunk_end = 5;
   */
  chunkEnd: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.Finalize
 */
export interface uploadapi_Finalize {}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.Finalize.Request
 */
export interface uploadapi_Finalize_Request {
  /**
   * @generated from protobuf field: uint64 resource_id = 1;
   */
  resourceId: bigint;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.uploadapi.Finalize.Response
 */
export interface uploadapi_Finalize_Response {}
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi$Type extends MessageType<uploadapi> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi', []);
  }
  create(value?: PartialMessage<uploadapi>): uploadapi {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi
  ): uploadapi {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi
 */
export const uploadapi = new uploadapi$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_Init$Type extends MessageType<uploadapi_Init> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.Init', []);
  }
  create(value?: PartialMessage<uploadapi_Init>): uploadapi_Init {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi_Init>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_Init
  ): uploadapi_Init {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi_Init,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.Init
 */
export const uploadapi_Init = new uploadapi_Init$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_Init_Request$Type extends MessageType<uploadapi_Init_Request> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.Init.Request', [
      {
        no: 1,
        name: 'resource_id',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_Init_Request>
  ): uploadapi_Init_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.resourceId = 0n;
    if (value !== undefined)
      reflectionMergePartial<uploadapi_Init_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_Init_Request
  ): uploadapi_Init_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 resource_id */ 1:
          message.resourceId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_Init_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* uint64 resource_id = 1; */
    if (message.resourceId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.resourceId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.Init.Request
 */
export const uploadapi_Init_Request = new uploadapi_Init_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_Init_Response$Type extends MessageType<uploadapi_Init_Response> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.Init.Response', [
      {
        no: 1,
        name: 'parts_count',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: 'uploaded_parts',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_Init_Response>
  ): uploadapi_Init_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.partsCount = 0n;
    message.uploadedParts = [];
    if (value !== undefined)
      reflectionMergePartial<uploadapi_Init_Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_Init_Response
  ): uploadapi_Init_Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 parts_count */ 1:
          message.partsCount = reader.uint64().toBigInt();
          break;
        case /* repeated uint64 uploaded_parts */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.uploadedParts.push(reader.uint64().toBigInt());
          else message.uploadedParts.push(reader.uint64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_Init_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* uint64 parts_count = 1; */
    if (message.partsCount !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.partsCount);
    /* repeated uint64 uploaded_parts = 2; */
    if (message.uploadedParts.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.uploadedParts.length; i++)
        writer.uint64(message.uploadedParts[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.Init.Response
 */
export const uploadapi_Init_Response = new uploadapi_Init_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_UpdateProgress$Type extends MessageType<uploadapi_UpdateProgress> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.UpdateProgress', []);
  }
  create(
    value?: PartialMessage<uploadapi_UpdateProgress>
  ): uploadapi_UpdateProgress {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi_UpdateProgress>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_UpdateProgress
  ): uploadapi_UpdateProgress {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi_UpdateProgress,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.UpdateProgress
 */
export const uploadapi_UpdateProgress = new uploadapi_UpdateProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_UpdateProgress_Request$Type extends MessageType<uploadapi_UpdateProgress_Request> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.UpdateProgress.Request', [
      {
        no: 1,
        name: 'resource_id',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: 'bytes_processed',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_UpdateProgress_Request>
  ): uploadapi_UpdateProgress_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.resourceId = 0n;
    message.bytesProcessed = 0n;
    if (value !== undefined)
      reflectionMergePartial<uploadapi_UpdateProgress_Request>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_UpdateProgress_Request
  ): uploadapi_UpdateProgress_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 resource_id */ 1:
          message.resourceId = reader.uint64().toBigInt();
          break;
        case /* int64 bytes_processed */ 2:
          message.bytesProcessed = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_UpdateProgress_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* uint64 resource_id = 1; */
    if (message.resourceId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.resourceId);
    /* int64 bytes_processed = 2; */
    if (message.bytesProcessed !== 0n)
      writer.tag(2, WireType.Varint).int64(message.bytesProcessed);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.UpdateProgress.Request
 */
export const uploadapi_UpdateProgress_Request =
  new uploadapi_UpdateProgress_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_UpdateProgress_Response$Type extends MessageType<uploadapi_UpdateProgress_Response> {
  constructor() {
    super(
      'MiLaboratories.Controller.Shared.uploadapi.UpdateProgress.Response',
      []
    );
  }
  create(
    value?: PartialMessage<uploadapi_UpdateProgress_Response>
  ): uploadapi_UpdateProgress_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi_UpdateProgress_Response>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_UpdateProgress_Response
  ): uploadapi_UpdateProgress_Response {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi_UpdateProgress_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.UpdateProgress.Response
 */
export const uploadapi_UpdateProgress_Response =
  new uploadapi_UpdateProgress_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_GetPartURL$Type extends MessageType<uploadapi_GetPartURL> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.GetPartURL', []);
  }
  create(value?: PartialMessage<uploadapi_GetPartURL>): uploadapi_GetPartURL {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi_GetPartURL>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_GetPartURL
  ): uploadapi_GetPartURL {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi_GetPartURL,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL
 */
export const uploadapi_GetPartURL = new uploadapi_GetPartURL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_GetPartURL_Request$Type extends MessageType<uploadapi_GetPartURL_Request> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.GetPartURL.Request', [
      {
        no: 1,
        name: 'resource_id',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: 'part_number',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: 'uploaded_part_size',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_GetPartURL_Request>
  ): uploadapi_GetPartURL_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.resourceId = 0n;
    message.partNumber = 0n;
    message.uploadedPartSize = 0n;
    if (value !== undefined)
      reflectionMergePartial<uploadapi_GetPartURL_Request>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_GetPartURL_Request
  ): uploadapi_GetPartURL_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 resource_id */ 1:
          message.resourceId = reader.uint64().toBigInt();
          break;
        case /* uint64 part_number */ 2:
          message.partNumber = reader.uint64().toBigInt();
          break;
        case /* uint64 uploaded_part_size */ 3:
          message.uploadedPartSize = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_GetPartURL_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* uint64 resource_id = 1; */
    if (message.resourceId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.resourceId);
    /* uint64 part_number = 2; */
    if (message.partNumber !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.partNumber);
    /* uint64 uploaded_part_size = 3; */
    if (message.uploadedPartSize !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.uploadedPartSize);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL.Request
 */
export const uploadapi_GetPartURL_Request =
  new uploadapi_GetPartURL_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_GetPartURL_HTTPHeader$Type extends MessageType<uploadapi_GetPartURL_HTTPHeader> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.GetPartURL.HTTPHeader', [
      {
        no: 1,
        name: 'Name',
        kind: 'scalar',
        jsonName: 'Name',
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: 'Value',
        kind: 'scalar',
        jsonName: 'Value',
        T: 9 /*ScalarType.STRING*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_GetPartURL_HTTPHeader>
  ): uploadapi_GetPartURL_HTTPHeader {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.value = '';
    if (value !== undefined)
      reflectionMergePartial<uploadapi_GetPartURL_HTTPHeader>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_GetPartURL_HTTPHeader
  ): uploadapi_GetPartURL_HTTPHeader {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string Name = 1 [json_name = "Name"];*/ 1:
          message.name = reader.string();
          break;
        case /* string Value = 2 [json_name = "Value"];*/ 2:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_GetPartURL_HTTPHeader,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string Name = 1 [json_name = "Name"]; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string Value = 2 [json_name = "Value"]; */
    if (message.value !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL.HTTPHeader
 */
export const uploadapi_GetPartURL_HTTPHeader =
  new uploadapi_GetPartURL_HTTPHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_GetPartURL_Response$Type extends MessageType<uploadapi_GetPartURL_Response> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.GetPartURL.Response', [
      { no: 1, name: 'upload_url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'method', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'headers',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => uploadapi_GetPartURL_HTTPHeader
      },
      {
        no: 4,
        name: 'chunk_start',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: 'chunk_end',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_GetPartURL_Response>
  ): uploadapi_GetPartURL_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uploadUrl = '';
    message.method = '';
    message.headers = [];
    message.chunkStart = 0n;
    message.chunkEnd = 0n;
    if (value !== undefined)
      reflectionMergePartial<uploadapi_GetPartURL_Response>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_GetPartURL_Response
  ): uploadapi_GetPartURL_Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string upload_url */ 1:
          message.uploadUrl = reader.string();
          break;
        case /* string method */ 2:
          message.method = reader.string();
          break;
        case /* repeated MiLaboratories.Controller.Shared.uploadapi.GetPartURL.HTTPHeader headers */ 3:
          message.headers.push(
            uploadapi_GetPartURL_HTTPHeader.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* uint64 chunk_start */ 4:
          message.chunkStart = reader.uint64().toBigInt();
          break;
        case /* uint64 chunk_end */ 5:
          message.chunkEnd = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_GetPartURL_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string upload_url = 1; */
    if (message.uploadUrl !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.uploadUrl);
    /* string method = 2; */
    if (message.method !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.method);
    /* repeated MiLaboratories.Controller.Shared.uploadapi.GetPartURL.HTTPHeader headers = 3; */
    for (let i = 0; i < message.headers.length; i++)
      uploadapi_GetPartURL_HTTPHeader
        .internalBinaryWrite(
          message.headers[i],
          writer.tag(3, WireType.LengthDelimited).fork(),
          options
        )
        .join();
    /* uint64 chunk_start = 4; */
    if (message.chunkStart !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.chunkStart);
    /* uint64 chunk_end = 5; */
    if (message.chunkEnd !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.chunkEnd);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.GetPartURL.Response
 */
export const uploadapi_GetPartURL_Response =
  new uploadapi_GetPartURL_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_Finalize$Type extends MessageType<uploadapi_Finalize> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.Finalize', []);
  }
  create(value?: PartialMessage<uploadapi_Finalize>): uploadapi_Finalize {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi_Finalize>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_Finalize
  ): uploadapi_Finalize {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi_Finalize,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.Finalize
 */
export const uploadapi_Finalize = new uploadapi_Finalize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_Finalize_Request$Type extends MessageType<uploadapi_Finalize_Request> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.Finalize.Request', [
      {
        no: 1,
        name: 'resource_id',
        kind: 'scalar',
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ]);
  }
  create(
    value?: PartialMessage<uploadapi_Finalize_Request>
  ): uploadapi_Finalize_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.resourceId = 0n;
    if (value !== undefined)
      reflectionMergePartial<uploadapi_Finalize_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_Finalize_Request
  ): uploadapi_Finalize_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 resource_id */ 1:
          message.resourceId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uploadapi_Finalize_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* uint64 resource_id = 1; */
    if (message.resourceId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.resourceId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.Finalize.Request
 */
export const uploadapi_Finalize_Request = new uploadapi_Finalize_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uploadapi_Finalize_Response$Type extends MessageType<uploadapi_Finalize_Response> {
  constructor() {
    super('MiLaboratories.Controller.Shared.uploadapi.Finalize.Response', []);
  }
  create(
    value?: PartialMessage<uploadapi_Finalize_Response>
  ): uploadapi_Finalize_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<uploadapi_Finalize_Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uploadapi_Finalize_Response
  ): uploadapi_Finalize_Response {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: uploadapi_Finalize_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.uploadapi.Finalize.Response
 */
export const uploadapi_Finalize_Response =
  new uploadapi_Finalize_Response$Type();
/**
 * @generated ServiceType for protobuf service MiLaboratories.Controller.Shared.Upload
 */
export const Upload = new ServiceType(
  'MiLaboratories.Controller.Shared.Upload',
  [
    {
      name: 'Init',
      options: {},
      I: uploadapi_Init_Request,
      O: uploadapi_Init_Response
    },
    {
      name: 'GetPartURL',
      options: {},
      I: uploadapi_GetPartURL_Request,
      O: uploadapi_GetPartURL_Response
    },
    {
      name: 'UpdateProgress',
      options: {},
      I: uploadapi_UpdateProgress_Request,
      O: uploadapi_UpdateProgress_Response
    },
    {
      name: 'Finalize',
      options: {},
      I: uploadapi_Finalize_Request,
      O: uploadapi_Finalize_Response
    }
  ]
);
