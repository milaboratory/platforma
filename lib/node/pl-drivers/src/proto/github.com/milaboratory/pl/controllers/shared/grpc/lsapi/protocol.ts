// @generated by protobuf-ts 2.11.0 with parameter client_generic,optimize_speed,generate_dependencies,force_server_none
// @generated from protobuf file "github.com/milaboratory/pl/controllers/shared/grpc/lsapi/protocol.proto" (package "MiLaboratories.Controller.Shared", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../../../../../google/protobuf/timestamp";
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.LsAPI
 */
export interface LsAPI {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.LsAPI.ListItem
 */
export interface LsAPI_ListItem {
    /**
     * name of the item in storage, without any prefixes
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * size of item in bytes
     * is always zero for directories (is_dir = true)
     *
     * @generated from protobuf field: uint64 size = 2
     */
    size: bigint;
    /**
     * is_dir is true for item, that can have subitems.
     *
     * @generated from protobuf field: bool is_dir = 3
     */
    isDir: boolean;
    /**
     * full_name is the name of item absolute to storage root.
     * it is <directory> + <name>
     * The <delimiter>, used in names, is storage-specific and is NOT guaranteed to be '/'.
     *
     * @generated from protobuf field: string full_name = 10
     */
    fullName: string;
    /**
     * directory, the item is located in. The value here is always a prefix of name:
     * name.HasPrefix(directory) is always true.
     *
     * @generated from protobuf field: string directory = 11
     */
    directory: string;
    /**
     * last_modified keeps the item last modification timestamp
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_modified = 12
     */
    lastModified?: Timestamp;
    /**
     * version of item in storage.
     * When storage supports versioning or provides checksums for the data stored,
     * the <version> field keeps that data.
     * If not - it keeps the any simple combination of item attributes, that helps to
     * detect if the contents of item has changed, e.g. <size>+<mtime>.
     * Anyway, client should not try to interpret this field, but should provide it to the Platform
     * in operations with given item (like BlobImportInternal) to help Platform with deduplication.
     *
     * @generated from protobuf field: string version = 13
     */
    version: string;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.LsAPI.List
 */
export interface LsAPI_List {
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.LsAPI.List.Request
 */
export interface LsAPI_List_Request {
    /**
     * resource_id of 'LS/<Storage>' resource
     *
     * @generated from protobuf field: uint64 resource_id = 1
     */
    resourceId: bigint;
    /**
     * location to list, absolute to storage root. Only items, that have <full_name> starting
     * from <location> are included into list response.
     *
     * @generated from protobuf field: string location = 2
     */
    location: string;
}
/**
 * @generated from protobuf message MiLaboratories.Controller.Shared.LsAPI.List.Response
 */
export interface LsAPI_List_Response {
    /**
     * List of the full (absolute to storage root) names of items from storage.
     * E.g., for 'fs' storage each name will consist of names of all directories, where the
     * item is located, and the item name itself.
     * The delimiter, used in names, is storage-specific and is NOT guaranteed to be '/'.
     *
     * @generated from protobuf field: repeated MiLaboratories.Controller.Shared.LsAPI.ListItem items = 1
     */
    items: LsAPI_ListItem[];
    /**
     * delimiter is path separator, used in this storage. Client can use it to parse item names into parts,
     * to extract directory names.
     *
     * @generated from protobuf field: string delimiter = 2
     */
    delimiter: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class LsAPI$Type extends MessageType<LsAPI> {
    constructor() {
        super("MiLaboratories.Controller.Shared.LsAPI", []);
    }
    create(value?: PartialMessage<LsAPI>): LsAPI {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LsAPI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LsAPI): LsAPI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LsAPI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.LsAPI
 */
export const LsAPI = new LsAPI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LsAPI_ListItem$Type extends MessageType<LsAPI_ListItem> {
    constructor() {
        super("MiLaboratories.Controller.Shared.LsAPI.ListItem", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "is_dir", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "full_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "directory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "last_modified", kind: "message", T: () => Timestamp },
            { no: 13, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LsAPI_ListItem>): LsAPI_ListItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.size = 0n;
        message.isDir = false;
        message.fullName = "";
        message.directory = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<LsAPI_ListItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LsAPI_ListItem): LsAPI_ListItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint64 size */ 2:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* bool is_dir */ 3:
                    message.isDir = reader.bool();
                    break;
                case /* string full_name */ 10:
                    message.fullName = reader.string();
                    break;
                case /* string directory */ 11:
                    message.directory = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_modified */ 12:
                    message.lastModified = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastModified);
                    break;
                case /* string version */ 13:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LsAPI_ListItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint64 size = 2; */
        if (message.size !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.size);
        /* bool is_dir = 3; */
        if (message.isDir !== false)
            writer.tag(3, WireType.Varint).bool(message.isDir);
        /* string full_name = 10; */
        if (message.fullName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.fullName);
        /* string directory = 11; */
        if (message.directory !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.directory);
        /* google.protobuf.Timestamp last_modified = 12; */
        if (message.lastModified)
            Timestamp.internalBinaryWrite(message.lastModified, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string version = 13; */
        if (message.version !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.LsAPI.ListItem
 */
export const LsAPI_ListItem = new LsAPI_ListItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LsAPI_List$Type extends MessageType<LsAPI_List> {
    constructor() {
        super("MiLaboratories.Controller.Shared.LsAPI.List", []);
    }
    create(value?: PartialMessage<LsAPI_List>): LsAPI_List {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LsAPI_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LsAPI_List): LsAPI_List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LsAPI_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.LsAPI.List
 */
export const LsAPI_List = new LsAPI_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LsAPI_List_Request$Type extends MessageType<LsAPI_List_Request> {
    constructor() {
        super("MiLaboratories.Controller.Shared.LsAPI.List.Request", [
            { no: 1, name: "resource_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LsAPI_List_Request>): LsAPI_List_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceId = 0n;
        message.location = "";
        if (value !== undefined)
            reflectionMergePartial<LsAPI_List_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LsAPI_List_Request): LsAPI_List_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 resource_id */ 1:
                    message.resourceId = reader.uint64().toBigInt();
                    break;
                case /* string location */ 2:
                    message.location = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LsAPI_List_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 resource_id = 1; */
        if (message.resourceId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.resourceId);
        /* string location = 2; */
        if (message.location !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.location);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.LsAPI.List.Request
 */
export const LsAPI_List_Request = new LsAPI_List_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LsAPI_List_Response$Type extends MessageType<LsAPI_List_Response> {
    constructor() {
        super("MiLaboratories.Controller.Shared.LsAPI.List.Response", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LsAPI_ListItem },
            { no: 2, name: "delimiter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LsAPI_List_Response>): LsAPI_List_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        message.delimiter = "";
        if (value !== undefined)
            reflectionMergePartial<LsAPI_List_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LsAPI_List_Response): LsAPI_List_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated MiLaboratories.Controller.Shared.LsAPI.ListItem items */ 1:
                    message.items.push(LsAPI_ListItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string delimiter */ 2:
                    message.delimiter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LsAPI_List_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated MiLaboratories.Controller.Shared.LsAPI.ListItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            LsAPI_ListItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string delimiter = 2; */
        if (message.delimiter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.delimiter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MiLaboratories.Controller.Shared.LsAPI.List.Response
 */
export const LsAPI_List_Response = new LsAPI_List_Response$Type();
/**
 * @generated ServiceType for protobuf service MiLaboratories.Controller.Shared.LS
 */
export const LS = new ServiceType("MiLaboratories.Controller.Shared.LS", [
    { name: "List", options: {}, I: LsAPI_List_Request, O: LsAPI_List_Response }
]);
