import { z } from 'zod';
import { InferSnapshot, rsSchema } from '@milaboratories/pl-tree';

//
// download
//
/** ResourceSnapshot that can be passed to OnDemandBlob */
export const OnDemandBlobResourceSnapshot = rsSchema({
  kv: {
    'ctl/file/blobInfo': z.object({
      sizeBytes: z.coerce.number()
    })
  }
});

export type OnDemandBlobResourceSnapshot = InferSnapshot<typeof OnDemandBlobResourceSnapshot>;

export function getSize(bs: OnDemandBlobResourceSnapshot): number {
  return bs.kv['ctl/file/blobInfo'].sizeBytes;
}

//
// upload
//

export const ImportFileHandleUploadData = z.object({
  /** Local file path, to take data for upload */
  localPath: z.string(),
  /** Path signature, to check this data was generated by us */
  pathSignature: z.string(),
  /** File size in bytes */
  sizeBytes: z.string(),
  /** Modification time unix timestamp in seconds */
  modificationTime: z.string()
});
export type ImportFileHandleUploadData = z.infer<typeof ImportFileHandleUploadData>;

export const ImportFileHandleIndexData = z.object({
  /** Pl storage id */
  storageId: z.string(),
  /** Path inside storage */
  path: z.string()
});
export type ImportFileHandleIndexData = z.infer<typeof ImportFileHandleIndexData>;

export const ImportFileHandleData = z.union([
  ImportFileHandleUploadData,
  ImportFileHandleIndexData
]);
export type ImportFileHandleData = z.infer<typeof ImportFileHandleData>;

/** Options from BlobUpload resource that have to be passed to getProgress. */

/** ResourceSnapshot that can be passed to GetProgressID */
export const UploadResourceSnapshot = rsSchema({
  data: ImportFileHandleUploadData,
  fields: {
    blob: false
  }
});

export const IndexResourceSnapshot = rsSchema({
  fields: {
    incarnation: false
  }
});

export type UploadResourceSnapshot = InferSnapshot<typeof UploadResourceSnapshot>;
export type IndexResourceSnapshot = InferSnapshot<typeof IndexResourceSnapshot>;

export type ImportResourceSnapshot = UploadResourceSnapshot | IndexResourceSnapshot;

//
// ls
//

/** Defines which storages from pl are available via local paths */
export type LocalStorageProjection = {
  /** Pl storage id */
  readonly storageId: string;

  /**
   * Local path, the storage is mounted at.
   *
   * Empty string means that this storage accepts absolute paths, and operates inside the same OS.
   * This matches the behaviour how pl interprets FS storage config.
   * */
  readonly localPath: string;
};

/** Allows to add parts of local FS as virtual storages, presenting homogeneous API to UI */
export type VirtualLocalStorageSpec = {
  /** Virtual storage ID, must not intersect with other storage ids */
  readonly name: string;

  /** Local path to "chroot" the API in */
  readonly root: string;

  /** Used as hint to UI controls to, set as initial path during browsing */
  readonly initialPath: string;
};
