//
// This file is NOT autogenerated!
//
// After generating new clients from openapi specifications, add client types here.
//

import type { paths as PlApiPaths } from './plapi';
import { default as createOpenApiClient, type Middleware, type Client } from 'openapi-fetch';
import { Dispatcher, fetch as undiciFetch } from 'undici';
import { RESTError, rethrowMeaningfulError } from '../core/errors';
import { Code } from '../proto-grpc/google/rpc/code';

export { PlApiPaths };
export type PlRestClientType = Client<PlApiPaths>;

export type RestClientConfig = {
  hostAndPort: string;
  ssl: boolean;
  dispatcher: Dispatcher;
  middlewares: Middleware[];
}

export function createClient<Paths extends {}>(opts: RestClientConfig): Client<Paths> {
  const scheme = opts.ssl ? 'https://' : 'http://';
  const client = createOpenApiClient<Paths>({
    baseUrl: `${scheme}${opts.hostAndPort}`,
    fetch: (input: Request): Promise<Response> => {
      // If body has already been consumed, clone the request
      const request = input.bodyUsed ? input.clone() : input;

      return undiciFetch(request.url, {
        body: request.body,
        cache: request.cache,
        credentials: request.credentials,
        dispatcher: opts.dispatcher,
        duplex: request.duplex,
        headers: request.headers,
        integrity: request.integrity,
        keepalive: request.keepalive,
        method: request.method,
        mode: request.mode,
        redirect: request.redirect,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        signal: request.signal,
      });
    },
  });
  client.use(errorHandlerMiddleware(), ...opts.middlewares);
  return client;
}

export type ErrorResponse = {
  code: Code,
  message: string,
  details: any[],
}
export async function parseResponseError(response: Response): Promise<{
  error?: ErrorResponse | string,
  origBody?: string,
}>{
  if (response.status < 400) {
    return {};
  }

  let error: any = await response.clone().text();
  const origBody = error;
  try {
    error = JSON.parse(error) as ErrorResponse;
  } catch {
  }
  return {
    error: error,
    origBody
  };
}

/**
 * Parses all API responses and thrown error in case of error response.
 * Allows all callers to not bother about .error response field checking.
 */
function errorHandlerMiddleware(): Middleware {
  return {
    onResponse: async ({ request: _request, response, options: _options }) => {
      const respErr = await parseResponseError(response);
      if (!respErr.error) {
        const { body, ...resOptions } = response;
        return new Response(body, { ...resOptions, status: response.status });
      }

      if (typeof respErr.error === 'string') {
        throw new Error(respErr.error);
      }

      rethrowMeaningfulError(new RESTError(respErr.error));
    },
  };
}
