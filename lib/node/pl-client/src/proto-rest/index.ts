//
// This file is NOT autogenerated!
//
// After generating new clients from openapi specifications, add client types here.
//

import type { paths as PlApiPaths } from './plapi';
import { default as createOpenApiClient, type Middleware, type Client } from 'openapi-fetch';
import { Dispatcher, fetch as undiciFetch } from 'undici';
import { rethrowMeaningfulError } from '../core/errors';

export { PlApiPaths };
export type PlRestClientType = Client<PlApiPaths>;

export type RestClientConfig = {
  hostAndPort: string;
  ssl: boolean;
  dispatcher: Dispatcher;
  middlewares: Middleware[];
}

export function createClient<Paths extends {}>(opts: RestClientConfig): Client<Paths> {
  const scheme = opts.ssl ? 'https://' : 'http://';
  const client = createOpenApiClient<Paths>({
    baseUrl: `${scheme}${opts.hostAndPort}`,
    fetch: async (input: Request): Promise<Response> => {
      console.log('Requesting: ', input);
      const response = await undiciFetch(input.url, { 
        ...input,
        dispatcher: opts.dispatcher,
      });

      return response;
    },
  });
  client.use(errorHandlerMiddleware(), ...opts.middlewares);
  return client;
}

export type ErrorResponse = {
  code: number,
  message: string,
  details: any[],
}
export async function parseResponseError(response: Response): Promise<{
  error?: ErrorResponse | string,
  origBody?: string,
}>{
  if (response.status < 400) {
    return {};
  }

  let error: any = await response.clone().text();
  const origBody = error;
  try {
    error = JSON.parse(error) as ErrorResponse;
  } catch {
  }
  return {
    error: error,
    origBody
  };
}

/**
 * Parses all API responses and thrown error in case of error response.
 * Allows all callers to not bother about .error response field checking.
 */
function errorHandlerMiddleware(): Middleware {
  return {
    onResponse: async ({ request: _request, response, options: _options }) => {
      const respErr = await parseResponseError(response);
      if (!respErr.error) {
        const { body, ...resOptions } = response;
        return new Response(body, { ...resOptions, status: response.status });
      }

      if (typeof respErr === 'string') {
        throw new Error(respErr);
      }

      rethrowMeaningfulError(respErr);
    },
  };
}
