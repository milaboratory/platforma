// @generated by protobuf-ts 2.9.4 with parameter client_generic,optimize_speed,generate_dependencies,force_server_none
// @generated from protobuf file "github.com/milaboratory/pl/controllers/shared/grpc/streamingapi/protocol.proto" (package "MiLaboratories.Controller.Shared", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Streaming } from "./protocol";
import type { StreamingAPI_LastLines } from "./protocol";
import type { StreamingAPI_ReadText } from "./protocol";
import type { StreamingAPI_StreamText } from "./protocol";
import type { StreamingAPI_ReadBinary } from "./protocol";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { StreamingAPI_Response } from "./protocol";
import type { StreamingAPI_StreamBinary } from "./protocol";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 *
 * Streaming provides access to online data stream from item in storage. Whenever item is appended with data,
 * the caller receives this fresh data in stream from server.
 *
 *
 * @generated from protobuf service MiLaboratories.Controller.Shared.Streaming
 */
export interface IStreamingClient {
    /**
     * StreamBinary provides stream of binary file. Each response message keeps
     * one single chunk of binary data from data source. See StreamingAPI.Binary message
     * for more info on available options.
     *
     * @generated from protobuf rpc: StreamBinary(MiLaboratories.Controller.Shared.StreamingAPI.StreamBinary) returns (stream MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    streamBinary(input: StreamingAPI_StreamBinary, options?: RpcOptions): ServerStreamingCall<StreamingAPI_StreamBinary, StreamingAPI_Response>;
    /**
     * ReadBinary allows to read remote item in chunks using stream-like API.
     * The difference to StreamBinary is that the client receives single response for each
     * call and has to send new calls to the server to get fresh data from remote item.
     * Each response (each chunk from server) keeps not more than 3.9MiB of data.
     *
     * @generated from protobuf rpc: ReadBinary(MiLaboratories.Controller.Shared.StreamingAPI.ReadBinary) returns (MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    readBinary(input: StreamingAPI_ReadBinary, options?: RpcOptions): UnaryCall<StreamingAPI_ReadBinary, StreamingAPI_Response>;
    /**
     * StreamText provides stream of textual file, splitting the data by newline symbol.
     * Each response message keeps one single line of text from data source.
     *
     * @generated from protobuf rpc: StreamText(MiLaboratories.Controller.Shared.StreamingAPI.StreamText) returns (stream MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    streamText(input: StreamingAPI_StreamText, options?: RpcOptions): ServerStreamingCall<StreamingAPI_StreamText, StreamingAPI_Response>;
    /**
     * ReadBinary allows to read remote item in chunks using stream-like API.
     * The difference to StreamBinary is that the client receives single response for each
     * call and has to send new calls to the server to get fresh data from remote item.
     * Each response (each chunk from server) keeps not more than 3.9MiB of data.
     *
     * @generated from protobuf rpc: ReadText(MiLaboratories.Controller.Shared.StreamingAPI.ReadText) returns (MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    readText(input: StreamingAPI_ReadText, options?: RpcOptions): UnaryCall<StreamingAPI_ReadText, StreamingAPI_Response>;
    /**
     * LastLines provides single message with the last lines from data source.
     * When search pattern is specified, the last lines matching the given pattern are returned.
     * The lines are returned in reversed order, as server reads data source from the end.
     * Consider it as equivalent to 'tac <file> | grep <search> | head -n <line_count>'
     * The <new_offset> returned in the response points to the _beginning_ of the last
     * line found, so client can continue reading the file backwards in subsequent calls.
     * This means, that use of this <new_offset> in ReadText() will return you the same line
     * returned last in LastLines() data.
     *
     * @generated from protobuf rpc: LastLines(MiLaboratories.Controller.Shared.StreamingAPI.LastLines) returns (MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    lastLines(input: StreamingAPI_LastLines, options?: RpcOptions): UnaryCall<StreamingAPI_LastLines, StreamingAPI_Response>;
}
/**
 *
 * Streaming provides access to online data stream from item in storage. Whenever item is appended with data,
 * the caller receives this fresh data in stream from server.
 *
 *
 * @generated from protobuf service MiLaboratories.Controller.Shared.Streaming
 */
export class StreamingClient implements IStreamingClient, ServiceInfo {
    typeName = Streaming.typeName;
    methods = Streaming.methods;
    options = Streaming.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * StreamBinary provides stream of binary file. Each response message keeps
     * one single chunk of binary data from data source. See StreamingAPI.Binary message
     * for more info on available options.
     *
     * @generated from protobuf rpc: StreamBinary(MiLaboratories.Controller.Shared.StreamingAPI.StreamBinary) returns (stream MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    streamBinary(input: StreamingAPI_StreamBinary, options?: RpcOptions): ServerStreamingCall<StreamingAPI_StreamBinary, StreamingAPI_Response> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamingAPI_StreamBinary, StreamingAPI_Response>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * ReadBinary allows to read remote item in chunks using stream-like API.
     * The difference to StreamBinary is that the client receives single response for each
     * call and has to send new calls to the server to get fresh data from remote item.
     * Each response (each chunk from server) keeps not more than 3.9MiB of data.
     *
     * @generated from protobuf rpc: ReadBinary(MiLaboratories.Controller.Shared.StreamingAPI.ReadBinary) returns (MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    readBinary(input: StreamingAPI_ReadBinary, options?: RpcOptions): UnaryCall<StreamingAPI_ReadBinary, StreamingAPI_Response> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamingAPI_ReadBinary, StreamingAPI_Response>("unary", this._transport, method, opt, input);
    }
    /**
     * StreamText provides stream of textual file, splitting the data by newline symbol.
     * Each response message keeps one single line of text from data source.
     *
     * @generated from protobuf rpc: StreamText(MiLaboratories.Controller.Shared.StreamingAPI.StreamText) returns (stream MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    streamText(input: StreamingAPI_StreamText, options?: RpcOptions): ServerStreamingCall<StreamingAPI_StreamText, StreamingAPI_Response> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamingAPI_StreamText, StreamingAPI_Response>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * ReadBinary allows to read remote item in chunks using stream-like API.
     * The difference to StreamBinary is that the client receives single response for each
     * call and has to send new calls to the server to get fresh data from remote item.
     * Each response (each chunk from server) keeps not more than 3.9MiB of data.
     *
     * @generated from protobuf rpc: ReadText(MiLaboratories.Controller.Shared.StreamingAPI.ReadText) returns (MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    readText(input: StreamingAPI_ReadText, options?: RpcOptions): UnaryCall<StreamingAPI_ReadText, StreamingAPI_Response> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamingAPI_ReadText, StreamingAPI_Response>("unary", this._transport, method, opt, input);
    }
    /**
     * LastLines provides single message with the last lines from data source.
     * When search pattern is specified, the last lines matching the given pattern are returned.
     * The lines are returned in reversed order, as server reads data source from the end.
     * Consider it as equivalent to 'tac <file> | grep <search> | head -n <line_count>'
     * The <new_offset> returned in the response points to the _beginning_ of the last
     * line found, so client can continue reading the file backwards in subsequent calls.
     * This means, that use of this <new_offset> in ReadText() will return you the same line
     * returned last in LastLines() data.
     *
     * @generated from protobuf rpc: LastLines(MiLaboratories.Controller.Shared.StreamingAPI.LastLines) returns (MiLaboratories.Controller.Shared.StreamingAPI.Response);
     */
    lastLines(input: StreamingAPI_LastLines, options?: RpcOptions): UnaryCall<StreamingAPI_LastLines, StreamingAPI_Response> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamingAPI_LastLines, StreamingAPI_Response>("unary", this._transport, method, opt, input);
    }
}
